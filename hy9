<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFPA 13 Calculator</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM & Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Import Map for Modules -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.263.1"
        }
    }
    </script>

    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        ::-webkit-scrollbar { width: 4px; height: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 2px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        .canvas-grid {
            background-size: 50px 50px;
            background-image: linear-gradient(to right, #e2e8f0 1px, transparent 1px),
                              linear-gradient(to bottom, #e2e8f0 1px, transparent 1px);
        }
        @media print {
            .no-print { display: none !important; }
            .print-only { display: block !important; }
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 overflow-hidden">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
          Plus, Trash2, Calculator, FileText, Droplets, Upload, Ruler, 
          Maximize, Target, ZoomIn, ZoomOut, Edit3, Check, Info, PlayCircle, 
          Magnet, Flame, AlertTriangle, CornerDownRight, X,
          RotateCcw, RotateCw, Eye, EyeOff
        } from 'lucide-react';

        const pipeSpecs = [
            { nominal: "1", internal: 1.049, color: "#3b82f6" },
            { nominal: "1.25", internal: 1.380, color: "#10b981" },
            { nominal: "1.5", internal: 1.610, color: "#f59e0b" },
            { nominal: "2", internal: 2.067, color: "#ef4444" },
            { nominal: "2.5", internal: 2.469, color: "#8b5cf6" },
            { nominal: "3", internal: 3.068, color: "#ec4899" },
            { nominal: "4", internal: 4.026, color: "#06b6d4" },
            { nominal: "6", internal: 6.065, color: "#14b8a6" },
            { nominal: "8", internal: 7.981, color: "#475569" },
        ];

        const hazardClasses = [
            { id: "LH", label: "Light Hazard", density: 0.10, defaultArea: 130 },
            { id: "OH1", label: "Ordinary Hazard Group 1", density: 0.15, defaultArea: 130 },
            { id: "OH2", label: "Ordinary Hazard Group 2", density: 0.20, defaultArea: 130 },
            { id: "EH1", label: "Extra Hazard Group 1", density: 0.30, defaultArea: 100 },
            { id: "EH2", label: "Extra Hazard Group 2", density: 0.40, defaultArea: 100 },
        ];

        const App = () => {
            const [kFactor, setKFactor] = useState(5.6);
            const [cFactor, setCFactor] = useState(120);
            const [selectedHazard, setSelectedHazard] = useState("LH");
            const [designDensity, setDesignDensity] = useState(0.10);
            const [areaPerHead, setAreaPerHead] = useState(130);
            const [pdfUrl, setPdfUrl] = useState(null);
            const [mode, setMode] = useState('pan');
            const [selectedPipeSize, setSelectedPipeSize] = useState("1");
            const [scalePoints, setScalePoints] = useState([]);
            const [pixelsPerMeter, setPixelsPerMeter] = useState(null);
            const [realWorldDist, setRealWorldDist] = useState('');
            const [showScaleDialog, setShowScaleDialog] = useState(false);
            const [drawnPipes, setDrawnPipes] = useState([]);
            const [tempPipe, setTempPipe] = useState(null);
            const [placedSprinklers, setPlacedSprinklers] = useState([]);
            const [snapPoint, setSnapPoint] = useState(null);
            const [startSnapInfo, setStartSnapInfo] = useState(null);
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const containerRef = useRef(null);
            const [results, setResults] = useState([]);
            const [totalDemand, setTotalDemand] = useState({ flow: 0, pressure: 0 });
            const [visualNodes, setVisualNodes] = useState([]);
            const [sourceNodeId, setSourceNodeId] = useState(null);
            
            const [showTags, setShowTags] = useState(true);
            const [history, setHistory] = useState([{ pipes: [], sprinklers: [] }]);
            const [historyIndex, setHistoryIndex] = useState(0);
            const [showReport, setShowReport] = useState(false);

            const safeNum = (val, fallback = 0) => {
                const n = parseFloat(val);
                return isNaN(n) ? fallback : n;
            };
            const safeFixed = (val, dec = 2) => safeNum(val).toFixed(dec);

            const commitToHistory = (newPipes, newSprinklers) => {
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push({ pipes: newPipes, sprinklers: newSprinklers });
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
            };

            const handleUndo = () => {
                if (historyIndex > 0) {
                    const prevIndex = historyIndex - 1;
                    const prevState = history[prevIndex];
                    setDrawnPipes(prevState.pipes);
                    setPlacedSprinklers(prevState.sprinklers);
                    setHistoryIndex(prevIndex);
                    setResults([]); 
                    setTotalDemand({ flow: 0, pressure: 0 });
                }
            };

            const handleRedo = () => {
                if (historyIndex < history.length - 1) {
                    const nextIndex = historyIndex + 1;
                    const nextState = history[nextIndex];
                    setDrawnPipes(nextState.pipes);
                    setPlacedSprinklers(nextState.sprinklers);
                    setHistoryIndex(nextIndex);
                    setResults([]);
                    setTotalDemand({ flow: 0, pressure: 0 });
                }
            };

            useEffect(() => {
                const nodes = {};
                let idCounter = 1;
                const getKey = (pt) => `${pt.x.toFixed(1)},${pt.y.toFixed(1)}`;
                
                drawnPipes.forEach(p => {
                    [p.start, p.end].forEach(pt => {
                        const key = getKey(pt);
                        if (!nodes[key]) {
                            nodes[key] = { 
                                id: key, 
                                displayId: idCounter++, 
                                x: pt.x, 
                                y: pt.y, 
                                degree: 0 
                            };
                        }
                    });
                    nodes[getKey(p.start)].degree++;
                    nodes[getKey(p.end)].degree++;
                });
                setVisualNodes(Object.values(nodes));
            }, [drawnPipes]);

            const handleHazardChange = (e) => {
                const hazardId = e.target.value;
                setSelectedHazard(hazardId);
                const hazard = hazardClasses.find(h => h.id === hazardId);
                if (hazard) {
                    setDesignDensity(hazard.density);
                    if (hazard.defaultArea) {
                        setAreaPerHead(hazard.defaultArea);
                    }
                }
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                if (pdfUrl && pdfUrl.startsWith('blob:')) URL.revokeObjectURL(pdfUrl);
                setPdfUrl(URL.createObjectURL(file));
                setScalePoints([]);
                setDrawnPipes([]);
                setPlacedSprinklers([]);
                setResults([]);
                setVisualNodes([]);
                setTotalDemand({ flow: 0, pressure: 0 });
                setTransform({ x: 0, y: 0, scale: 1 });
                setMode('pan');
                setSourceNodeId(null);
                setHistory([{ pipes: [], sprinklers: [] }]);
                setHistoryIndex(0);
            };

            const getCanvasCoords = (e) => {
                if (!containerRef.current) return { x: 0, y: 0 };
                const rect = containerRef.current.getBoundingClientRect();
                return {
                    x: (e.clientX - rect.left - transform.x) / transform.scale,
                    y: (e.clientY - rect.top - transform.y) / transform.scale
                };
            };

            const projectPointToSegment = (P, A, B) => {
                const distAB2 = Math.pow(B.x - A.x, 2) + Math.pow(B.y - A.y, 2);
                if (distAB2 === 0) return A;
                let t = ((P.x - A.x) * (B.x - A.x) + (P.y - A.y) * (B.y - A.y)) / distAB2;
                t = Math.max(0, Math.min(1, t));
                return { x: A.x + t * (B.x - A.x), y: A.y + t * (B.y - A.y) };
            };

            const getSnappedCoords = (rawCoords) => {
                if (mode !== 'draw' && mode !== 'sprinkler') return { coords: rawCoords, isSnapped: false };

                const snapThreshold = 15 / transform.scale;
                let closestPoint = null;
                let minDistance = Infinity;
                let snapType = null;
                let snapTarget = null;

                placedSprinklers.forEach(s => {
                    const dist = Math.sqrt(Math.pow(s.x - rawCoords.x, 2) + Math.pow(s.y - rawCoords.y, 2));
                    if (dist < snapThreshold && dist < minDistance) {
                        minDistance = dist;
                        closestPoint = { x: s.x, y: s.y };
                        snapType = 'node';
                        snapTarget = s;
                    }
                });

                drawnPipes.forEach(pipe => {
                    [pipe.start, pipe.end].forEach(pt => {
                        const dist = Math.sqrt(Math.pow(pt.x - rawCoords.x, 2) + Math.pow(pt.y - rawCoords.y, 2));
                        if (dist < snapThreshold && dist < minDistance) {
                            minDistance = dist;
                            closestPoint = pt;
                            snapType = 'node';
                            snapTarget = pipe;
                        }
                    });
                });

                if (!closestPoint) {
                    drawnPipes.forEach(pipe => {
                        const projected = projectPointToSegment(rawCoords, pipe.start, pipe.end);
                        const dist = Math.sqrt(Math.pow(projected.x - rawCoords.x, 2) + Math.pow(projected.y - rawCoords.y, 2));
                        if (dist < snapThreshold && dist < minDistance) {
                            minDistance = dist;
                            closestPoint = projected;
                            snapType = 'edge';
                            snapTarget = pipe;
                        }
                    });
                }

                if (closestPoint) return { coords: closestPoint, isSnapped: true, snapType, snapTarget };
                return { coords: rawCoords, isSnapped: false, snapType: null, snapTarget: null };
            };

            const splitPipeAtPoint = (pipes, targetPipe, splitPoint) => {
                const remainingPipes = pipes.filter(p => p.id !== targetPipe.id);
                const dist1 = Math.sqrt(Math.pow(splitPoint.x - targetPipe.start.x, 2) + Math.pow(splitPoint.y - targetPipe.start.y, 2));
                const dist2 = Math.sqrt(Math.pow(targetPipe.end.x - splitPoint.x, 2) + Math.pow(targetPipe.end.y - splitPoint.y, 2));

                const newSegments = [];
                if (dist1 > 0.1) {
                    newSegments.push({ ...targetPipe, id: Date.now() + Math.random(), end: splitPoint, pixelLength: dist1 });
                }
                if (dist2 > 0.1) {
                    newSegments.push({ ...targetPipe, id: Date.now() + Math.random() + 1, start: splitPoint, pixelLength: dist2 });
                }
                return [...remainingPipes, ...newSegments];
            };

            const handleMouseDown = (e) => {
                if (showScaleDialog) return;
                const rawCoords = getCanvasCoords(e);
                const { coords, isSnapped, snapType, snapTarget } = getSnappedCoords(rawCoords);

                if (mode === 'pan') {
                    setIsDragging(true);
                    setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
                } else if (mode === 'scale') {
                    setIsDragging(true);
                    setScalePoints([coords, coords]);
                } else if (mode === 'draw') {
                    setIsDragging(true);
                    setStartSnapInfo(isSnapped ? { type: snapType, target: snapTarget, coords: coords } : null);
                    setTempPipe({ start: coords, end: coords, size: selectedPipeSize });
                }
            };

            const handleMouseMove = (e) => {
                if (showScaleDialog) return;
                const rawCoords = getCanvasCoords(e);
                const { coords, isSnapped } = getSnappedCoords(rawCoords);
                setSnapPoint(isSnapped ? coords : null);

                if (isDragging) {
                    if (mode === 'pan') {
                        setTransform(prev => ({ ...prev, x: e.clientX - dragStart.x, y: e.clientY - dragStart.y }));
                    } else if (mode === 'scale') {
                        setScalePoints(prev => [prev[0], rawCoords]);
                    } else if (mode === 'draw') {
                        setTempPipe(prev => ({ ...prev, end: coords }));
                    }
                }
            };

            const handleMouseUp = () => {
                if (showScaleDialog) return;

                if (mode === 'scale' && isDragging) {
                    const dx = scalePoints[1].x - scalePoints[0].x;
                    const dy = scalePoints[1].y - scalePoints[0].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 5) {
                        setShowScaleDialog(true);
                        setRealWorldDist('');
                        setIsDragging(false);
                        return;
                    } else {
                        setScalePoints([]);
                    }
                } else if (mode === 'draw' && isDragging && tempPipe) {
                    const endSnapInfo = getSnappedCoords(tempPipe.end);
                    const finalEnd = endSnapInfo.isSnapped ? endSnapInfo.coords : tempPipe.end;

                    const dx = finalEnd.x - tempPipe.start.x;
                    const dy = finalEnd.y - tempPipe.start.y;
                    const pixelLen = Math.sqrt(dx * dx + dy * dy);

                    if (pixelLen > 2) {
                        let nextPipes = [...drawnPipes];
                        let actualStart = tempPipe.start;
                        let actualEnd = finalEnd;

                        if (startSnapInfo && startSnapInfo.type === 'edge' && startSnapInfo.target) {
                            const targetPipe = nextPipes.find(p => p.id === startSnapInfo.target.id);
                            if (targetPipe) {
                                nextPipes = splitPipeAtPoint(nextPipes, targetPipe, startSnapInfo.coords);
                                actualStart = startSnapInfo.coords;
                            }
                        }

                        if (endSnapInfo.isSnapped && endSnapInfo.snapType === 'edge' && endSnapInfo.snapTarget) {
                            const targetPipe = nextPipes.find(p => p.id === endSnapInfo.snapTarget.id);
                            if (targetPipe) {
                                nextPipes = splitPipeAtPoint(nextPipes, targetPipe, endSnapInfo.coords);
                                actualEnd = endSnapInfo.coords;
                            }
                        }

                        const newPipe = {
                            id: Date.now() + Math.random(),
                            start: actualStart,
                            end: actualEnd,
                            size: tempPipe.size,
                            pixelLength: pixelLen
                        };
                        nextPipes.push(newPipe);
                        
                        setDrawnPipes(nextPipes);
                        commitToHistory(nextPipes, placedSprinklers);
                    }
                    setTempPipe(null);
                    setStartSnapInfo(null);
                }
                setIsDragging(false);
            };

            const distanceToSegment = (P, A, B) => {
                const distAB2 = Math.pow(B.x - A.x, 2) + Math.pow(B.y - A.y, 2);
                if (distAB2 === 0) return Math.sqrt(Math.pow(P.x - A.x, 2) + Math.pow(P.y - A.y, 2));
                let t = ((P.x - A.x) * (B.x - A.x) + (P.y - A.y) * (B.y - A.y)) / distAB2;
                t = Math.max(0, Math.min(1, t));
                return Math.sqrt(Math.pow(P.x - (A.x + t * (B.x - A.x)), 2) + Math.pow(P.y - (A.y + t * (B.y - A.y)), 2));
            };

            const handleCanvasClick = (e) => {
                if (showScaleDialog) return;
                const rawCoords = getCanvasCoords(e);
                const { coords, isSnapped, snapType, snapTarget } = getSnappedCoords(rawCoords);

                if (mode === 'sprinkler') {
                    const newSprinklers = [...placedSprinklers, { ...coords, id: Date.now() }];
                    setPlacedSprinklers(newSprinklers);
                    
                    let nextPipes = drawnPipes;
                    if (isSnapped && snapType === 'edge' && snapTarget) {
                        nextPipes = splitPipeAtPoint(drawnPipes, snapTarget, coords);
                        setDrawnPipes(nextPipes);
                    }
                    commitToHistory(nextPipes, newSprinklers);

                } else if (mode === 'delete') {
                    const clickThreshold = 10 / transform.scale;
                    const pipeToDelete = drawnPipes.find(pipe => {
                        const dist = distanceToSegment(rawCoords, pipe.start, pipe.end);
                        return dist < clickThreshold;
                    });

                    if (pipeToDelete) {
                        const nextPipes = drawnPipes.filter(p => p.id !== pipeToDelete.id);
                        setDrawnPipes(nextPipes);
                        commitToHistory(nextPipes, placedSprinklers);
                    } else {
                        const sprinklerToDelete = placedSprinklers.find(s => {
                            const dist = Math.sqrt(Math.pow(s.x - rawCoords.x, 2) + Math.pow(s.y - rawCoords.y, 2));
                            return dist < clickThreshold;
                        });
                        if (sprinklerToDelete) {
                            const nextSprinklers = placedSprinklers.filter(s => s.id !== sprinklerToDelete.id);
                            setPlacedSprinklers(nextSprinklers);
                            commitToHistory(drawnPipes, nextSprinklers);
                        }
                    }
                }
            };

            const applyScale = () => {
                if (scalePoints.length < 2) return;
                const dx = scalePoints[1].x - scalePoints[0].x;
                const dy = scalePoints[1].y - scalePoints[0].y;
                const pixelDist = Math.sqrt(dx * dx + dy * dy);
                const rDist = parseFloat(realWorldDist);

                if (pixelDist > 0 && rDist > 0) {
                    setPixelsPerMeter(pixelDist / rDist);
                    setMode('pan');
                    setShowScaleDialog(false);
                    setScalePoints([]);
                } else {
                    alert("กรุณาระบุระยะทางที่ถูกต้อง");
                }
            };

            const adjustZoom = (delta) => {
                if (!containerRef.current) return;
                const zoomStep = 0.15;
                const oldScale = transform.scale;
                const newScale = Math.min(Math.max(oldScale + (delta > 0 ? zoomStep : -zoomStep), 0.1), 10);
                
                const rect = containerRef.current.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                const worldX = (centerX - transform.x) / oldScale;
                const worldY = (centerY - transform.y) / oldScale;
                
                const newX = centerX - worldX * newScale;
                const newY = centerY - worldY * newScale;
                
                setTransform({ x: newX, y: newY, scale: newScale });
            };

            const calculateLoss = (Q, L_ft, d_in, C) => {
                if (Q <= 0 || L_ft <= 0) return 0;
                return (4.52 * Math.pow(Q, 1.85) * L_ft) / (Math.pow(C, 1.85) * Math.pow(d_in, 4.87));
            };

            const handleCalculate = () => {
                if (!pixelsPerMeter) {
                    alert("กรุณากำหนดสเกล (Set Scale) ก่อนคำนวณ");
                    return;
                }
                if (drawnPipes.length === 0) {
                    alert("กรุณาวาดท่ออย่างน้อย 1 เส้น");
                    return;
                }

                const M_TO_FT = 3.28084;
                const K = safeNum(kFactor, 5.6);
                const C = safeNum(cFactor, 120);
                const RISER_NIPPLE_FT = 0.1 * M_TO_FT;
                const NIPPLE_ID = 1.049;
                const density = safeNum(designDensity, 0.40);
                const areaFt2 = safeNum(areaPerHead, 100);

                const qMinHead = density * areaFt2;
                const minP_Req = Math.pow(qMinHead / K, 2);
                const startPressureReq = Math.max(7, minP_Req);

                // Build Graph
                const nodes = {};
                const coordToDisplayId = {};
                let idCounter = 1;
                const getKey = (pt) => `${pt.x.toFixed(1)},${pt.y.toFixed(1)}`;
                
                drawnPipes.forEach(p => {
                    [p.start, p.end].forEach(pt => {
                        const key = getKey(pt);
                        if (!coordToDisplayId[key]) {
                            coordToDisplayId[key] = idCounter++;
                        }
                    });
                });

                const getOrCreateNode = (pt) => {
                    const key = getKey(pt);
                    if (!nodes[key]) nodes[key] = { id: key, x: pt.x, y: pt.y, connections: [], heads: [] };
                    return nodes[key];
                };

                drawnPipes.forEach(p => {
                    const n1 = getOrCreateNode(p.start);
                    const n2 = getOrCreateNode(p.end);
                    const spec = pipeSpecs.find(s => s.nominal === p.size) || pipeSpecs[0];
                    
                    const uDisp = coordToDisplayId[getKey(p.start)];
                    const vDisp = coordToDisplayId[getKey(p.end)];

                    const edge = {
                        id: p.id,
                        u: n1.id,
                        v: n2.id,
                        u_disp: uDisp,
                        v_disp: vDisp,
                        pipe: p,
                        size: p.size,
                        heads: [], 
                        d_in: spec.internal,
                        len_ft: (p.pixelLength / pixelsPerMeter) * M_TO_FT,
                        flow: 0,
                        loss: 0,
                        velocity: 0,
                        flowDir: null
                    };
                    n1.connections.push({ target: n2.id, edge });
                    n2.connections.push({ target: n1.id, edge });
                });

                const tolerance = 5 / transform.scale;
                placedSprinklers.forEach(s => {
                    for (const nodeId in nodes) {
                        const node = nodes[nodeId];
                        const dist = Math.sqrt(Math.pow(s.x - node.x, 2) + Math.pow(s.y - node.y, 2));
                        if (dist < tolerance) {
                            node.heads.push(s);
                            break;
                        }
                    }
                });

                let sourceId = null;
                let maxDia = -1;
                const allNodes = Object.values(nodes);
                const endPoints = allNodes.filter(n => n.connections.length === 1);

                if (endPoints.length > 0) {
                    endPoints.forEach(n => {
                        const pipeSize = parseFloat(n.connections[0].edge.size);
                        if (pipeSize > maxDia) {
                            maxDia = pipeSize;
                            sourceId = n.id;
                        }
                    });
                }

                if (!sourceId && allNodes.length > 0) {
                    allNodes.forEach(n => {
                        const localMax = n.connections.reduce((m, c) => Math.max(m, parseFloat(c.edge.size)), 0);
                        if (localMax > maxDia) {
                            maxDia = localMax;
                            sourceId = n.id;
                        }
                    });
                    if (!sourceId) sourceId = allNodes[0].id;
                }

                setSourceNodeId(sourceId);

                const parentMap = {}; 
                const processingOrder = []; 
                const visited = new Set([sourceId]);
                const queue = [sourceId];

                while(queue.length > 0) {
                    const uId = queue.shift();
                    processingOrder.push(uId);
                    const uNode = nodes[uId];
                    if(uNode && uNode.connections) {
                        uNode.connections.forEach(conn => {
                            if (!visited.has(conn.target)) {
                                visited.add(conn.target);
                                parentMap[conn.target] = { parentId: uId, edge: conn.edge };
                                queue.push(conn.target);
                            }
                        });
                    }
                }

                const nodeReqP = {};
                const nodeTotalQ = {};
                const nodeActualP = {}; // Store ACTUAL balanced pressure
                Object.keys(nodes).forEach(k => {
                    nodeReqP[k] = 0;
                    nodeTotalQ[k] = 0;
                    nodeActualP[k] = 0;
                });

                const tempReport = {}; // Use dict for easier update

                // 1. Backward Pass (Demand & Flow Balancing)
                for (let i = processingOrder.length - 1; i >= 0; i--) {
                    const uId = processingOrder[i];
                    let maxP_RequiredAtU = 0;
                    let totalQ_AtU = 0;
                    
                    const uNode = nodes[uId];
                    if(!uNode) continue;

                    const childConnections = uNode.connections.filter(conn => parentMap[conn.target]?.parentId === uId);

                    childConnections.forEach(child => {
                        const vId = child.target;
                        const edge = child.edge;
                        const qChild = nodeTotalQ[vId] || 0;
                        const pChild = nodeReqP[vId] || 0;

                        if (qChild > 0 || pChild > 0) {
                            const loss = calculateLoss(qChild, edge.len_ft, edge.d_in, C);
                            const pReqUpstream = pChild + loss;
                            maxP_RequiredAtU = Math.max(maxP_RequiredAtU, pReqUpstream);
                        }
                    });

                    // Add Heads
                    if (uNode.heads.length > 0) {
                        // FIX: Ensure minimum head pressure is met properly
                        // If current calculated required pressure is less than min, bump it up.
                        // But importantly, ensure node pressure accounts for loss in riser nipple.
                        let pMinHead = startPressureReq; // e.g. 7 psi
                        let qHead = K * Math.sqrt(pMinHead);
                        let lossNip = calculateLoss(qHead, RISER_NIPPLE_FT, NIPPLE_ID, C);
                        let pReqAtNodeForHead = pMinHead + lossNip;

                        maxP_RequiredAtU = Math.max(maxP_RequiredAtU, pReqAtNodeForHead);
                        
                        uNode.heads.forEach(() => {
                            // Calculate actual flow based on balanced pressure at node U
                            // Note: during backward pass, we accumulate Q based on demand.
                            // The true Q will be recalculated in forward pass or implicitly handled by balancing.
                            // For simplicity, we use Q based on maxP_RequiredAtU here.
                            
                            // Approximate P_head from P_node (iterative)
                            let pHeadEst = maxP_RequiredAtU;
                            for(let k=0; k<2; k++) {
                                let q = K * Math.sqrt(pHeadEst > 0 ? pHeadEst : 0);
                                let loss = calculateLoss(q, RISER_NIPPLE_FT, NIPPLE_ID, C);
                                pHeadEst = maxP_RequiredAtU - loss;
                            }
                            if(pHeadEst < 0) pHeadEst = 0;
                            totalQ_AtU += K * Math.sqrt(pHeadEst);
                        });
                    }

                    // Balance Flow from branches
                    childConnections.forEach(child => {
                        const vId = child.target;
                        const edge = child.edge;
                        let qBranch = nodeTotalQ[vId] || 0;
                        const pChildReq = nodeReqP[vId] || 0;
                        
                        const lossBase = calculateLoss(qBranch, edge.len_ft, edge.d_in, C);
                        const pBranchReqAtU = pChildReq + lossBase;

                        if (maxP_RequiredAtU > pBranchReqAtU && pBranchReqAtU > 0.01 && qBranch > 0) {
                            const kBranch = qBranch / Math.sqrt(pBranchReqAtU);
                            qBranch = kBranch * Math.sqrt(maxP_RequiredAtU);
                        }

                        edge.flow = qBranch;
                        edge.loss = calculateLoss(qBranch, edge.len_ft, edge.d_in, C);
                        edge.velocity = (0.4085 * qBranch) / Math.pow(edge.d_in, 2);
                        edge.flowDir = (edge.u === uId) ? 'u->v' : 'v->u';
                        
                        totalQ_AtU += qBranch;

                        tempReport[edge.id] = {
                            pipeId: edge.id,
                            id: `Pipe ${edge.size}"`,
                            size: edge.size,
                            lengthM: edge.len_ft / M_TO_FT,
                            flow: qBranch,
                            loss: edge.loss,
                            pressure: 0, // Will be updated in forward pass
                            velocity: edge.velocity,
                            flowDir: edge.flowDir || 'N/A',
                            nodes: edge.flowDir === 'u->v' 
                                ? `#${edge.u_disp}-#${edge.v_disp}` 
                                : `#${edge.v_disp}-#${edge.u_disp}`
                        };
                    });

                    nodeReqP[uId] = maxP_RequiredAtU;
                    nodeTotalQ[uId] = totalQ_AtU;
                }

                // 2. Forward Pass (Actual Pressure Calculation)
                // Start with the Source Pressure derived from the backward pass
                nodeActualP[sourceId] = nodeReqP[sourceId];
                
                // Processing order is BFS (Source -> Leaves), which matches queue logic nicely
                const forwardQueue = [sourceId];
                const forwardVisited = new Set([sourceId]);

                while(forwardQueue.length > 0) {
                    const uId = forwardQueue.shift();
                    const currentP = nodeActualP[uId];
                    const uNode = nodes[uId];

                    // Find children (pipes flowing OUT from u)
                    const childConnections = uNode.connections.filter(conn => parentMap[conn.target]?.parentId === uId);
                    
                    childConnections.forEach(child => {
                        const vId = child.target;
                        const edge = child.edge;
                        
                        // Update report with Upstream Pressure (P at u)
                        if (tempReport[edge.id]) {
                            tempReport[edge.id].pressure = currentP;
                        }

                        // Calculate P at v
                        const nextP = currentP - edge.loss; // Loss was updated in backward pass based on balanced flow
                        nodeActualP[vId] = nextP;

                        if (!forwardVisited.has(vId)) {
                            forwardVisited.add(vId);
                            forwardQueue.push(vId);
                        }
                    });
                }

                setResults(Object.values(tempReport).reverse());
                setTotalDemand({ flow: nodeTotalQ[sourceId] || 0, pressure: nodeReqP[sourceId] || 0 });
            };

            const lineIntersectsRect = (x1, y1, x2, y2, rx, ry, rw, rh) => {
                const left = rx, right = rx + rw, top = ry, bottom = ry + rh;
                const minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2), maxY = Math.max(y1, y2);

                if (maxX < left || minX > right || maxY < top || minY > bottom) return false;

                const intersect = (p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) => {
                    const det = (p2x - p1x) * (p4y - p3y) - (p4x - p3x) * (p2y - p1y);
                    if (det === 0) return false;
                    const lambda = ((p4y - p3y) * (p4x - p1x) + (p3x - p4x) * (p4y - p1y)) / det;
                    const gamma = ((p1y - p2y) * (p4x - p1x) + (p2x - p1x) * (p4y - p1y)) / det;
                    return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
                };

                if (intersect(x1, y1, x2, y2, left, top, right, top)) return true;
                if (intersect(x1, y1, x2, y2, right, top, right, bottom)) return true;
                if (intersect(x1, y1, x2, y2, right, bottom, left, bottom)) return true;
                if (intersect(x1, y1, x2, y2, left, bottom, left, top)) return true;
                
                if (x1 > left && x1 < right && y1 > top && y1 < bottom) return true;

                return false;
            };

            // Improved Layout Engine with Sliding Anchors
            const getTagLayout = () => {
                if (!results || results.length === 0) return [];
                const layout = [];
                const occupiedRects = [];
                const tagW = 90 / transform.scale;
                const tagH = 65 / transform.scale; 
                const padding = 10 / transform.scale; // Padding between tags

                // Sort pipes? Maybe longer pipes first easier to find space? 
                // For now, process in order.

                drawnPipes.forEach(pipe => {
                    const res = results.find(r => r.pipeId === pipe.id);
                    if (!res) return;

                    let startX = pipe.start.x, startY = pipe.start.y;
                    let endX = pipe.end.x, endY = pipe.end.y;

                    // Visual Arrow Angle Calculation (Uses logic direction)
                    let arrowAngle = 0;
                    if (res.flowDir === 'v->u') {
                        arrowAngle = Math.atan2(pipe.start.y - pipe.end.y, pipe.start.x - pipe.end.x);
                    } else {
                        arrowAngle = Math.atan2(pipe.end.y - pipe.start.y, pipe.end.x - pipe.start.x);
                    }

                    // Geometry for Tag Placement (Uses visual pipe segment)
                    const dx = endX - startX;
                    const dy = endY - startY;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    
                    // Unit vector along pipe
                    const ux = dx / (len || 1);
                    const uy = dy / (len || 1);

                    // Normal vector (perpendicular)
                    const nx = -uy;
                    const ny = ux;

                    const baseDist = 45 / transform.scale; 
                    
                    let bestTagX = 0, bestTagY = 0, bestAnchorX = 0, bestAnchorY = 0;
                    let found = false;

                    // SEARCH STRATEGY:
                    // 1. Iterate Distance Layers (Close -> Far)
                    // 2. Iterate Position along pipe (Center -> Ends) : 50%, 30%, 70%, etc.
                    // 3. Iterate Sides (Left/Right)
                    
                    const distSteps = [1, 1.6, 2.2, 3]; // Multipliers of baseDist
                    const posSteps = [0.5, 0.35, 0.65, 0.2, 0.8]; // Positions t on pipe (0 to 1)

                    outerLoop:
                    for (let distMult of distSteps) {
                        const dist = baseDist * distMult;
                        
                        for (let t of posSteps) {
                            // Calculate Anchor Point on pipe
                            const ax = startX + dx * t;
                            const ay = startY + dy * t;

                            for (let side of [1, -1]) {
                                // Calculate Candidate Tag Center
                                const cx = ax + (nx * dist * side);
                                const cy = ay + (ny * dist * side);

                                // Define Bounding Box for Collision
                                const rect = {
                                    x: cx - tagW / 2 - padding/2,
                                    y: cy - tagH / 2 - padding/2,
                                    w: tagW + padding,
                                    h: tagH + padding
                                };

                                // 1. Check Rect-Rect Collision (Tag vs Tag)
                                let collision = false;
                                for (const r of occupiedRects) {
                                    if (rect.x < r.x + r.w && rect.x + rect.w > r.x &&
                                        rect.y < r.y + r.h && rect.y + rect.h > r.y) {
                                        collision = true;
                                        break;
                                    }
                                }

                                // 2. Check Rect-Line Collision (Tag vs Pipes)
                                // Prevent tag from sitting directly ON TOP of any pipe
                                if (!collision) {
                                    for (const p of drawnPipes) {
                                        if (lineIntersectsRect(p.start.x, p.start.y, p.end.x, p.end.y, rect.x, rect.y, rect.w, rect.h)) {
                                            collision = true;
                                            break;
                                        }
                                    }
                                }

                                if (!collision) {
                                    bestTagX = cx;
                                    bestTagY = cy;
                                    bestAnchorX = ax;
                                    bestAnchorY = ay;
                                    found = true;
                                    // Add slightly larger rect to occupied to act as buffer
                                    occupiedRects.push(rect);
                                    break outerLoop;
                                }
                            }
                        }
                    }
                    
                    // Fallback if absolutely no space found (very crowded)
                    if (!found) {
                         const dist = baseDist * 3.5;
                         bestAnchorX = startX + dx * 0.5;
                         bestAnchorY = startY + dy * 0.5;
                         bestTagX = bestAnchorX + (nx * dist);
                         bestTagY = bestAnchorY + (ny * dist);
                         occupiedRects.push({ x: bestTagX - tagW/2, y: bestTagY - tagH/2, w: tagW, h: tagH });
                    }

                    layout.push({ 
                        id: pipe.id, 
                        tagX: bestTagX, 
                        tagY: bestTagY, 
                        // IMPORTANT: Line connects to anchor on pipe, not just center
                        anchorX: bestAnchorX, 
                        anchorY: bestAnchorY,
                        // Arrow still stays at physical center
                        midX: (startX + endX)/2, 
                        midY: (startY + endY)/2, 
                        res, 
                        angle: arrowAngle 
                    });
                });
                return layout;
            };

            const tagLayout = getTagLayout();

            return (
                <div className="flex h-screen w-full bg-slate-50 overflow-hidden font-sans select-none">
                    {/* Side Panel - Compacted */}
                    <div className="w-80 bg-white border-r border-slate-200 flex flex-col shadow-xl z-20 shrink-0">
                        <div className="px-4 py-3 bg-slate-900 text-white flex justify-between items-center shrink-0">
                            <h1 className="font-bold text-lg flex items-center gap-2">
                                <Flame size={20} className="text-orange-500" />
                                NFPA 13
                            </h1>
                            <label className="cursor-pointer bg-slate-700 hover:bg-slate-600 text-white text-xs px-2 py-1.5 rounded flex items-center gap-1 transition-colors">
                                <input type="file" className="hidden" onChange={handleFileChange} accept="image/*" />
                                <Upload size={12} /> Open
                            </label>
                        </div>

                        <div className="flex-1 flex flex-col p-2 overflow-hidden gap-3">
                            {/* Parameters */}
                            <div className="border-b border-slate-200 pb-2">
                                <h3 className="font-semibold text-slate-700 text-xs flex items-center gap-1 mb-1">
                                    <Target size={14} /> Parameters
                                </h3>
                                <div className="grid grid-cols-2 gap-1 text-[10px]">
                                    <div className="col-span-2">
                                        <select value={selectedHazard} onChange={handleHazardChange} className="w-full p-1 border rounded bg-slate-50">
                                            {hazardClasses.map(h => <option key={h.id} value={h.id}>{h.label}</option>)}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="text-slate-500">Density (gpm/ft²)</label>
                                        <input type="number" value={designDensity} onChange={e => setDesignDensity(e.target.value)} className="w-full p-1 border rounded" step="0.05" />
                                    </div>
                                    <div>
                                        <label className="text-slate-500">Area/head (ft²)</label>
                                        <input type="number" value={areaPerHead} onChange={e => setAreaPerHead(e.target.value)} className="w-full p-1 border rounded" />
                                    </div>
                                    <div>
                                        <label className="text-slate-500">K Factor</label>
                                        <input type="number" value={kFactor} onChange={e => setKFactor(e.target.value)} className="w-full p-1 border rounded" />
                                    </div>
                                     <div>
                                        <label className="text-slate-500">C Value</label>
                                        <input type="number" value={cFactor} onChange={e => setCFactor(e.target.value)} className="w-full p-1 border rounded" />
                                    </div>
                                </div>
                            </div>

                            {/* Pipe Selector - Modified to Transparent */}
                            <div className="border-b border-slate-200 pb-2">
                                <h3 className="font-semibold text-slate-700 text-xs flex items-center gap-1 mb-1">
                                    <Ruler size={14} /> Pipe Size
                                </h3>
                                <div className="grid grid-cols-3 gap-1">
                                    {pipeSpecs.map(spec => (
                                        <button
                                            key={spec.nominal}
                                            onClick={() => setSelectedPipeSize(spec.nominal)}
                                            className={`text-[10px] h-7 rounded border transition-all flex items-center justify-center ${
                                                selectedPipeSize === spec.nominal 
                                                ? 'ring-2 ring-offset-1 font-bold shadow-md scale-105' 
                                                : 'hover:bg-slate-50'
                                            }`}
                                            style={{ 
                                                backgroundColor: selectedPipeSize === spec.nominal ? spec.color : 'transparent',
                                                borderColor: spec.color,
                                                color: selectedPipeSize === spec.nominal ? 'white' : spec.color
                                            }}
                                        >
                                            {spec.nominal}"
                                        </button>
                                    ))}
                                </div>
                            </div>

                            {/* Tools */}
                            <div className="flex flex-col gap-1">
                                <h3 className="font-semibold text-slate-700 text-xs flex items-center gap-1">
                                    <Edit3 size={14} /> Tools
                                </h3>
                                <div className="grid grid-cols-4 gap-1.5">
                                    {/* Row 1: View & Edit Tools */}
                                    <button onClick={() => setMode('pan')} className={`flex items-center justify-center gap-1 px-1 py-1.5 rounded text-[10px] border transition-colors ${mode === 'pan' ? 'bg-slate-800 text-white' : 'bg-white hover:bg-slate-50'}`} title="Pan/Zoom">
                                        <Maximize size={12} /> Pan
                                    </button>
                                    <button onClick={() => setMode('scale')} className={`flex items-center justify-center gap-1 px-1 py-1.5 rounded text-[10px] border transition-colors ${mode === 'scale' ? 'bg-indigo-600 text-white' : 'bg-white hover:bg-slate-50'}`} title="Set Scale">
                                        <Ruler size={12} /> Scale
                                    </button>
                                    {/* Expanded Tag button */}
                                    <button onClick={() => setShowTags(!showTags)} className={`col-span-2 flex items-center justify-center gap-1 px-1 py-1.5 rounded text-[10px] border transition-colors ${!showTags ? 'bg-slate-200 text-slate-500' : 'bg-white hover:bg-slate-50'}`} title="Toggle Tags">
                                        {showTags ? <Eye size={12} /> : <EyeOff size={12} />} {showTags ? "Hide Tags" : "Show Tags"}
                                    </button>

                                    {/* Row 2: Drawing Tools */}
                                    <button onClick={() => setMode('draw')} className={`col-span-2 flex items-center justify-center gap-1 px-2 py-1.5 rounded text-[10px] border transition-colors ${mode === 'draw' ? 'bg-blue-600 text-white' : 'bg-white hover:bg-slate-50'}`}>
                                        <Plus size={12} /> Draw Pipe
                                    </button>
                                    <button onClick={() => setMode('sprinkler')} className={`col-span-2 flex items-center justify-center gap-1 px-2 py-1.5 rounded text-[10px] border transition-colors ${mode === 'sprinkler' ? 'bg-emerald-600 text-white' : 'bg-white hover:bg-slate-50'}`}>
                                        <Droplets size={12} /> Add Head
                                    </button>

                                    {/* Row 3: Action Tools */}
                                    <button onClick={handleUndo} disabled={historyIndex <= 0} className="flex items-center justify-center gap-1 px-1 py-1.5 rounded text-[10px] border bg-white hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed" title="Undo">
                                        <RotateCcw size={12} /> Undo
                                    </button>
                                    <button onClick={handleRedo} disabled={historyIndex >= history.length - 1} className="flex items-center justify-center gap-1 px-1 py-1.5 rounded text-[10px] border bg-white hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed" title="Redo">
                                        <RotateCw size={12} /> Redo
                                    </button>
                                    <button onClick={() => setMode('delete')} className={`col-span-2 flex items-center justify-center gap-1 px-2 py-1.5 rounded text-[10px] border transition-colors ${mode === 'delete' ? 'bg-red-600 text-white' : 'bg-white hover:bg-slate-50'}`}>
                                        <Trash2 size={12} /> Delete
                                    </button>
                                </div>
                            </div>

                            {/* Calculate Button & Report Button in Grid */}
                            <div className="flex gap-2 mt-3 shrink-0">
                                <button 
                                    onClick={handleCalculate}
                                    className="flex-1 py-2 bg-slate-900 hover:bg-slate-800 text-white rounded shadow text-sm flex items-center justify-center gap-2 font-bold transition-transform active:scale-95"
                                >
                                    <Calculator size={16} /> Calculate
                                </button>
                                <button 
                                    onClick={() => setShowReport(true)}
                                    className="flex-none w-10 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded shadow flex items-center justify-center transition-transform active:scale-95"
                                    title="View Calculation Report"
                                >
                                    <FileText size={18} />
                                </button>
                            </div>

                            {/* Results Summary */}
                            {totalDemand.flow > 0 && (
                                <div className="bg-slate-100 p-2 mt-2 rounded border border-slate-300 space-y-1 animate-in fade-in slide-in-from-bottom-2 shrink-0">
                                    <div className="flex justify-between items-baseline">
                                        <span className="text-[10px] text-slate-600">Total Flow:</span>
                                        <span className="text-sm font-bold text-blue-700">{safeFixed(totalDemand.flow)} <span className="text-[9px] text-slate-500 font-normal">gpm</span></span>
                                    </div>
                                    <div className="flex justify-between items-baseline">
                                        <span className="text-[10px] text-slate-600">Max Pressure:</span>
                                        <span className="text-sm font-bold text-red-700">{safeFixed(totalDemand.pressure)} <span className="text-[9px] text-slate-500 font-normal">psi</span></span>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Main Canvas Area */}
                    <div 
                        className="flex-1 relative bg-slate-200 overflow-hidden cursor-crosshair canvas-grid"
                        ref={containerRef}
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onClick={handleCanvasClick}
                        onWheel={(e) => adjustZoom(e.deltaY > 0 ? -1 : 1)}
                    >
                        {/* Info Overlay */}
                        <div className="absolute top-4 left-4 z-10 bg-white/90 backdrop-blur px-3 py-1.5 rounded-full border shadow-sm text-[10px] text-slate-600 pointer-events-none flex items-center gap-2">
                            <span className="flex items-center gap-1"><Info size={12}/> Mode: <span className="font-bold uppercase text-slate-900">{mode}</span></span>
                            <span className="w-px h-3 bg-slate-300"></span>
                            <span>Scale: {pixelsPerMeter ? `${safeFixed(pixelsPerMeter)} px/m` : 'Not Set'}</span>
                        </div>

                        {/* Zoom Controls */}
                        <div className="absolute bottom-6 right-6 z-10 flex flex-col gap-2">
                            <button onClick={() => adjustZoom(1)} className="p-2 bg-white rounded-full shadow-lg hover:bg-slate-50 text-slate-700 transition-transform active:scale-90"><ZoomIn size={16}/></button>
                            <button onClick={() => adjustZoom(-1)} className="p-2 bg-white rounded-full shadow-lg hover:bg-slate-50 text-slate-700 transition-transform active:scale-90"><ZoomOut size={16}/></button>
                        </div>

                        {/* Transform Container */}
                        <div 
                            style={{ 
                                transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`,
                                transformOrigin: '0 0',
                                width: '100%', height: '100%',
                                pointerEvents: 'none'
                            }}
                        >
                             {/* Background Image */}
                            {pdfUrl && <img src={pdfUrl} className="absolute top-0 left-0 opacity-80" style={{ maxWidth: 'none', pointerEvents: 'none' }} />}

                            <svg className="absolute top-0 left-0 overflow-visible" style={{ width: '1px', height: '1px' }}>
                                {/* Drawn Pipes */}
                                {drawnPipes.map(pipe => {
                                    const spec = pipeSpecs.find(s => s.nominal === pipe.size) || pipeSpecs[0];
                                    return (
                                        <g key={pipe.id}>
                                            <line 
                                                x1={pipe.start.x} y1={pipe.start.y} 
                                                x2={pipe.end.x} y2={pipe.end.y} 
                                                stroke={spec.color} 
                                                strokeWidth={4 / transform.scale}
                                                strokeLinecap="round"
                                            />
                                        </g>
                                    );
                                })}

                                {/* Nodes (Joints) with IDs - Modified style */}
                                {/* Removed 'showTags &&' condition here so nodes remain visible */}
                                {visualNodes.map(node => (
                                    <g key={node.id} transform={`translate(${node.x}, ${node.y})`}>
                                        {/* Connection Dot */}
                                        <circle 
                                            r={2.5 / transform.scale} 
                                            fill="#334155" 
                                            stroke="white"
                                            strokeWidth={1 / transform.scale}
                                        />
                                        {/* Label Offset from center */}
                                        <text
                                            x={4 / transform.scale}
                                            y={-4 / transform.scale}
                                            fontSize={9 / transform.scale}
                                            fill="#0f172a"
                                            fontWeight="bold"
                                            style={{ 
                                                textShadow: '1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff',
                                                pointerEvents: 'none'
                                            }}
                                        >
                                            #{node.displayId}
                                        </text>
                                    </g>
                                ))}

                                {/* Sprinklers */}
                                {placedSprinklers.map(s => (
                                    <g key={s.id} transform={`translate(${s.x}, ${s.y})`}>
                                        <circle r={6 / transform.scale} fill="#10b981" fillOpacity="0.2" stroke="#059669" strokeWidth={1/transform.scale} />
                                        <circle r={2 / transform.scale} fill="#059669" />
                                    </g>
                                ))}

                                {/* Results Tags and Arrows - Decoupled in JSX */}
                                {tagLayout.map(tag => (
                                    <React.Fragment key={tag.id}>
                                        {/* Tag Group - Show ONLY if showTags is true */}
                                        {showTags && (
                                            <g transform={`translate(${tag.tagX}, ${tag.tagY})`}>
                                                <line 
                                                    x1={(tag.anchorX - tag.tagX)} y1={(tag.anchorY - tag.tagY)} 
                                                    x2={0} y2={0} 
                                                    stroke="#94a3b8" strokeWidth={1/transform.scale} strokeDasharray="4,2"
                                                />
                                                <foreignObject 
                                                    x={-45 / transform.scale} 
                                                    y={-32 / transform.scale} 
                                                    width={90 / transform.scale} 
                                                    height={65 / transform.scale}
                                                >
                                                    <div xmlns="http://www.w3.org/1999/xhtml" 
                                                         className="bg-white/95 border border-slate-300 rounded shadow-sm flex flex-col items-center justify-center text-center leading-none p-0.5"
                                                         style={{ fontSize: `${10/transform.scale}px`, height: '100%', width: '100%' }}>
                                                        {/* Node Info Line */}
                                                        <div className="text-[0.7em] text-blue-800 font-bold mb-0.5">Node {tag.res.nodes}</div>
                                                        <div className="text-[0.75em] text-black font-medium leading-tight">{tag.res.size}" {safeFixed(tag.res.lengthM, 1)} m.</div>
                                                        <div className="text-[0.75em] text-black font-bold leading-tight">{safeFixed(tag.res.flow)} GPM</div>
                                                        <div className="text-[0.75em] text-black leading-tight">{safeFixed(tag.res.pressure)} psi</div>
                                                    </div>
                                                </foreignObject>
                                            </g>
                                        )}

                                        {/* Flow Arrow - Always visible regardless of showTags */}
                                        <g transform={`translate(${tag.midX}, ${tag.midY}) rotate(${tag.angle * 180 / Math.PI})`}>
                                            <circle r={7/transform.scale} fill="white" fillOpacity="1" stroke="#e2e8f0" strokeWidth={1/transform.scale} />
                                            <path 
                                                d={`M ${-5/transform.scale} 0 L ${5/transform.scale} 0 M ${0} ${-4/transform.scale} L ${5/transform.scale} 0 L ${0} ${4/transform.scale}`} 
                                                stroke="#ef4444" 
                                                strokeWidth={2.5/transform.scale} 
                                                fill="none" 
                                                strokeLinecap="round" 
                                                strokeLinejoin="round"
                                            />
                                        </g>
                                    </React.Fragment>
                                ))}

                                {/* Temp Pipe (Ghost) */}
                                {tempPipe && (
                                    <line 
                                        x1={tempPipe.start.x} y1={tempPipe.start.y} 
                                        x2={tempPipe.end.x} y2={tempPipe.end.y} 
                                        stroke={pipeSpecs.find(s => s.nominal === tempPipe.size)?.color || 'black'} 
                                        strokeWidth={4 / transform.scale}
                                        strokeOpacity="0.5"
                                        strokeDasharray="5,5"
                                    />
                                )}

                                {/* Snap Marker */}
                                {snapPoint && (
                                    <circle 
                                        cx={snapPoint.x} cy={snapPoint.y} 
                                        r={5 / transform.scale} 
                                        fill="none" stroke="#ef4444" strokeWidth={2 / transform.scale}
                                    />
                                )}

                                {/* Scale Line */}
                                {scalePoints.length === 2 && (
                                    <line 
                                        x1={scalePoints[0].x} y1={scalePoints[0].y} 
                                        x2={scalePoints[1].x} y2={scalePoints[1].y} 
                                        stroke="#f00" strokeWidth={2 / transform.scale}
                                    />
                                )}
                            </svg>
                        </div>
                    </div>

                    {/* Scale Dialog Modal */}
                    {showScaleDialog && (
                        <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center">
                            <div className="bg-white p-6 rounded-lg shadow-2xl w-80 animate-in zoom-in-95">
                                <h3 className="font-bold text-lg mb-4 flex items-center gap-2">
                                    <Ruler className="text-indigo-600" /> Set Scale
                                </h3>
                                <p className="text-sm text-slate-500 mb-4">
                                    Enter the real-world distance for the line you just drew.
                                </p>
                                <input 
                                    type="number" 
                                    autoFocus
                                    placeholder="Distance in meters"
                                    className="w-full p-2 border rounded mb-4 text-lg"
                                    value={realWorldDist}
                                    onChange={e => setRealWorldDist(e.target.value)}
                                    onKeyDown={e => e.key === 'Enter' && applyScale()}
                                />
                                <div className="flex justify-end gap-2">
                                    <button onClick={() => { setShowScaleDialog(false); setScalePoints([]); }} className="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded">Cancel</button>
                                    <button onClick={applyScale} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded font-medium">Apply Scale</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Report Modal */}
                    {showReport && (
                        <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 print:p-0 print:bg-white print:static">
                            <div className="bg-white rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col animate-in zoom-in-95 print:shadow-none print:w-full print:h-auto print:max-h-none print:rounded-none">
                                <div className="p-4 border-b flex justify-between items-center bg-slate-50 rounded-t-lg print:hidden">
                                    <h3 className="font-bold text-lg text-slate-800 flex items-center gap-2">
                                        <FileText className="text-blue-600" /> Hydraulic Calculations Sheet
                                    </h3>
                                    <button onClick={() => setShowReport(false)} className="p-1 hover:bg-slate-200 rounded-full transition-colors text-slate-500">
                                        <X size={20} />
                                    </button>
                                </div>
                                <div className="p-6 overflow-auto print:p-0 print:overflow-visible">
                                    <div className="mb-4 text-center hidden print:block">
                                        <h2 className="text-xl font-bold uppercase">Hydraulic Calculations Sheet</h2>
                                        <p className="text-sm text-slate-500">NFPA 13 Standard</p>
                                    </div>
                                    <table className="w-full text-sm text-left border-collapse">
                                        <thead className="bg-slate-100 font-bold text-slate-700 border-b-2 border-slate-300">
                                            <tr>
                                                <th className="p-3 border-r border-slate-200">Node</th>
                                                <th className="p-3 border-r border-slate-200">Flow (gpm)</th>
                                                <th className="p-3 border-r border-slate-200">Pipe Size (in)</th>
                                                <th className="p-3 border-r border-slate-200">Length (m)</th>
                                                <th className="p-3 border-r border-slate-200">Friction Loss (psi)</th>
                                                <th className="p-3 border-r border-slate-200">Required Pressure (psi)</th>
                                                <th className="p-3">Velocity (ft/s)</th>
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y divide-slate-100">
                                            {results.length > 0 ? (
                                                results.map((row, i) => (
                                                    <tr key={i} className="hover:bg-slate-50 transition-colors">
                                                        <td className="p-3 font-medium text-blue-700 border-r border-slate-200">{row.nodes}</td>
                                                        <td className="p-3 font-bold text-slate-800 border-r border-slate-200">{safeFixed(row.flow)}</td>
                                                        <td className="p-3 text-slate-600 border-r border-slate-200">{row.size}"</td>
                                                        <td className="p-3 text-slate-600 border-r border-slate-200">{safeFixed(row.lengthM)}</td>
                                                        <td className="p-3 text-slate-600 border-r border-slate-200">{safeFixed(row.loss)}</td>
                                                        <td className="p-3 font-medium text-red-700 border-r border-slate-200">{safeFixed(row.pressure)}</td>
                                                        <td className="p-3 text-slate-500">{safeFixed(row.velocity)}</td>
                                                    </tr>
                                                ))
                                            ) : (
                                                <tr>
                                                    <td colSpan="7" className="p-8 text-center text-slate-400 italic">
                                                        No calculation data available. Please draw pipes and calculate first.
                                                    </td>
                                                </tr>
                                            )}
                                        </tbody>
                                        {results.length > 0 && (
                                            <tfoot className="bg-slate-50 font-bold border-t-2 border-slate-300">
                                                <tr>
                                                    <td className="p-3 border-r border-slate-200">System Total</td>
                                                    <td className="p-3 text-blue-700 border-r border-slate-200">{safeFixed(totalDemand.flow)}</td>
                                                    <td colSpan="3" className="border-r border-slate-200"></td>
                                                    <td className="p-3 text-red-700 border-r border-slate-200">{safeFixed(totalDemand.pressure)} (Max)</td>
                                                    <td></td>
                                                </tr>
                                            </tfoot>
                                        )}
                                    </table>
                                </div>
                                <div className="p-4 border-t flex justify-end gap-2 bg-slate-50 rounded-b-lg print:hidden">
                                    <button 
                                        onClick={() => window.print()} 
                                        className="px-4 py-2 bg-white border border-slate-300 text-slate-700 rounded hover:bg-slate-50 font-medium flex items-center gap-2"
                                    >
                                        Print
                                    </button>
                                    <button 
                                        onClick={() => setShowReport(false)} 
                                        className="px-4 py-2 bg-slate-900 text-white rounded hover:bg-slate-800 font-medium"
                                    >
                                        Close
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
