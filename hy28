<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hydraulic Calculation Tools (NFPA 13) V.1.3 By วัยรุ่นเซินเจิ้น</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM & Babel -->
    <!-- FIX: Pinned Babel version to 7.23.6 to prevent "targets.esmodules" error -->
    <script src="https://unpkg.com/@babel/standalone@7.23.6/babel.min.js"></script>

    <!-- Import Map for Modules -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.263.1"
        }
    }
    </script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        ::-webkit-scrollbar {
            width: 4px;
            height: 4px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 2px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Engineering Graph Paper Grid Style */
        .canvas-grid {
            background-color: #ffffff;
            background-size: 50px 50px;
            background-image:
                linear-gradient(to right, #f1f5f9 1px, transparent 1px),
                linear-gradient(to bottom, #f1f5f9 1px, transparent 1px);
        }

        @media print {
            @page {
                margin: 1cm;
                size: auto;
            }

            body {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                background-color: white;
            }

            #root {
                height: auto;
                overflow: visible;
            }

            .no-print {
                display: none !important;
            }

            table {
                width: 100%;
            }

            .print-page-break {
                page-break-before: always;
                break-before: page;
                display: block;
                height: 0;
            }
        }
    </style>
</head>

<body class="bg-gray-100 text-gray-900 overflow-hidden print:bg-white print:overflow-visible">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import {
            Plus, Trash2, Calculator, FileText, Droplets, Upload, Ruler,
            Maximize, Target, ZoomIn, ZoomOut, Edit3, Info, Flame, X,
            RotateCcw, RotateCw, Eye, EyeOff, Save, FolderOpen, Image as ImageIcon, FilePlus, LayoutGrid
        } from 'lucide-react';

        // Adjusted Pipe Colors
        const pipeSpecs = [
            { nominal: "1", internal: 1.049, color: "#eab308" },    // Yellow 500
            { nominal: "1.25", internal: 1.380, color: "#fb923c" }, // Orange 400
            { nominal: "1.5", internal: 1.610, color: "#b91c1c" },  // Red 700
            { nominal: "2", internal: 2.067, color: "#ec4899" },    // Pink 500
            { nominal: "2.5", internal: 2.469, color: "#a855f7" },  // Purple 500
            { nominal: "3", internal: 3.068, color: "#3b82f6" },    // Blue 500
            { nominal: "4", internal: 4.026, color: "#06b6d4" },    // Cyan 500
            { nominal: "6", internal: 6.065, color: "#10b981" },    // Emerald 500
            { nominal: "8", internal: 7.981, color: "#475569" },    // Slate 600
        ];

        // Centralized NFPA Data Source
        const nfpaData = {
            displaySizes: ["0.75", "1", "1.25", "1.5", "2", "2.5", "3", "3.5", "4", "5", "6", "8", "10", "12"],
            calcSizes: ["0.5", "0.75", "1", "1.25", "1.5", "2", "2.5", "3", "3.5", "4", "5", "6", "8", "10", "12"],
            fittings: [
                { name: "45° Elbow", code: "HE", type: "45elbow", values: { "0.75": 1, "1": 1, "1.25": 1, "1.5": 2, "2": 2, "2.5": 3, "3": 3, "3.5": 3, "4": 4, "5": 5, "6": 7, "8": 9, "10": 11, "12": 13 } },
                { name: "90° Standard Elbow", code: "SE", type: "elbow", values: { "0.75": 2, "1": 2, "1.25": 3, "1.5": 4, "2": 5, "2.5": 6, "3": 7, "3.5": 8, "4": 10, "5": 12, "6": 14, "8": 18, "10": 22, "12": 27 } },
                { name: "90° Long Turn Elbow", code: "LE", type: "lrelbow", values: { "0.75": 1, "1": 2, "1.25": 2, "1.5": 2, "2": 3, "2.5": 4, "3": 5, "3.5": 5, "4": 6, "5": 8, "6": 9, "8": 13, "10": 16, "12": 18 } },
                { name: "Tee or Cross (Flow Turned 90°)", code: "TT", type: "tee", values: { "0.75": 3, "1": 5, "1.25": 6, "1.5": 8, "2": 10, "2.5": 12, "3": 15, "3.5": 17, "4": 20, "5": 25, "6": 30, "8": 35, "10": 50, "12": 60 } },
                { name: "Butterfly Valve", code: "BV", type: "valve", values: { "0.75": "-", "1": "-", "1.25": "-", "1.5": "-", "2": 6, "2.5": 7, "3": 10, "3.5": "-", "4": 12, "5": 9, "6": 10, "8": 12, "10": 19, "12": 21 } },
                { name: "Gate Valve", code: "GV", type: "valve", values: { "0.75": "-", "1": "-", "1.25": "-", "1.5": "-", "2": 1, "2.5": 1, "3": 1, "3.5": 1, "4": 2, "5": 2, "6": 3, "8": 4, "10": 5, "12": 6 } },
                { name: "Vane type flow switch", code: "FS", type: "valve", values: { "0.75": "-", "1": 6, "1.25": 9, "1.5": 10, "2": 14, "2.5": 17, "3": 22, "3.5": "-", "4": 30, "5": "-", "6": 16, "8": 22, "10": 29, "12": 36 } },
                { name: "Swing Check*", code: "CV", type: "check", values: { "0.75": "-", "1": 5, "1.25": 7, "1.5": 9, "2": 11, "2.5": 14, "3": 16, "3.5": 19, "4": 22, "5": "-", "6": 32, "8": 45, "10": 55, "12": 65 } }
            ]
        };

        const hazardClasses = [
            { id: "LH", label: "Light Hazard", density: 0.10, defaultArea: 170, maxSpacing: 13.12 },
            { id: "OH1", label: "Ordinary Hazard Group 1", density: 0.15, defaultArea: 130, maxSpacing: 13.12 },
            { id: "OH2", label: "Ordinary Hazard Group 2", density: 0.20, defaultArea: 130, maxSpacing: 13.12 },
            { id: "EH1", label: "Extra Hazard Group 1", density: 0.30, defaultArea: 100, maxSpacing: 9.84 },
            { id: "EH2", label: "Extra Hazard Group 2", density: 0.40, defaultArea: 100, maxSpacing: 9.84 },
        ];

        const cFactors = [
            { value: 150, label: "150 - Plastic (listed) - Underground" },
            { value: 150, label: "150 - Plastic (listed) - Aboveground" },
            { value: 150, label: "150 - Copper Tube or Stainless Steel" },
            { value: 140, label: "140 - Cement-Lined Cast or Ductile Iron" },
            { value: 140, label: "140 - Asbestos Cement" },
            { value: 120, label: "120 - Steel (Wet System or Deluge System)" },
            { value: 100, label: "100 - Steel (Dry System or Preaction System)" },
            { value: 100, label: "100 - Cast or Ductile Iron, Unlined" },
        ];

        const kFactors = [5.6, 8.0, 11.2, 14.0, 16.8, 19.6, 22.4, 25.2, 28.0, 33.6];

        const App = () => {
            const [kFactor, setKFactor] = useState(5.6);
            const [cFactor, setCFactor] = useState(120);
            const [selectedHazard, setSelectedHazard] = useState("LH");
            const [designDensity, setDesignDensity] = useState(0.10);
            const [areaPerHead, setAreaPerHead] = useState(170);
            const [pdfUrl, setPdfUrl] = useState(null);
            const [mode, setMode] = useState('pan');
            const [selectedPipeSize, setSelectedPipeSize] = useState("1");
            const [scalePoints, setScalePoints] = useState([]);
            const [pixelsPerMeter, setPixelsPerMeter] = useState(null);
            const [realWorldDist, setRealWorldDist] = useState('');
            const [showScaleDialog, setShowScaleDialog] = useState(false);
            const [drawnPipes, setDrawnPipes] = useState([]);
            const [tempPipe, setTempPipe] = useState(null);
            const [placedSprinklers, setPlacedSprinklers] = useState([]);
            const [snapPoint, setSnapPoint] = useState(null);
            const [startSnapInfo, setStartSnapInfo] = useState(null);
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const containerRef = useRef(null);
            const [results, setResults] = useState([]);
            const [totalDemand, setTotalDemand] = useState({ flow: 0, pressure: 0 });
            const [visualNodes, setVisualNodes] = useState([]);


            const [sourceNodeId, setSourceNodeId] = useState(null);
            const [tempRect, setTempRect] = useState(null);

            const [showTags, setShowTags] = useState(true);


            const [history, setHistory] = useState([{ pipes: [], sprinklers: [] }]);
            const [historyIndex, setHistoryIndex] = useState(0);
            const [showReport, setShowReport] = useState(false);

            const [editingPipeId, setEditingPipeId] = useState(null);
            const [alignmentLines, setAlignmentLines] = useState([]);
            const [sprinklerDistanceGuide, setSprinklerDistanceGuide] = useState(null);
            const [pipeAlignmentGuide, setPipeAlignmentGuide] = useState(null);

            // New State for Project Management
            const projectHandle = useRef(null);
            const projectInputRef = useRef(null);

            // Access Control State
            const [accessLevel, setAccessLevel] = useState(() => sessionStorage.getItem('hydraulic_auth_level')); // null = locked
            const [unlockCode, setUnlockCode] = useState('');

            const handleUnlock = () => {
                if (unlockCode === '1234') {
                    setAccessLevel('restricted');
                    sessionStorage.setItem('hydraulic_auth_level', 'restricted');
                    alert("Logged in as Restricted User (No Save/Save As)");
                } else if (btoa(unlockCode) === 'MjAxNw==') { // Full Version Check
                    setAccessLevel('full');
                    sessionStorage.setItem('hydraulic_auth_level', 'full');
                    alert("Full Version Unlocked!");
                } else {
                    alert("Invalid Code");
                }
            };


            const safeNum = (val, fallback = 0) => {
                const n = parseFloat(val);
                return isNaN(n) ? fallback : n;
            };
            const safeFixed = (val, dec = 2) => safeNum(val).toFixed(dec);

            // --- File Helpers ---
            const blobToBase64 = (blob) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            };

            // --- Project Management Functions ---

            const saveProject = async (saveAs = false) => {
                try {
                    // Prepare Data
                    let bgImageData = null;
                    if (pdfUrl) {
                        if (pdfUrl.startsWith('blob:')) {
                            // Fetch and convert to base64
                            const response = await fetch(pdfUrl);
                            const blob = await response.blob();
                            bgImageData = await blobToBase64(blob);
                        } else {
                            // Already base64
                            bgImageData = pdfUrl;
                        }
                    }

                    const projectData = {
                        version: "1.3",
                        timestamp: Date.now(),
                        state: {
                            kFactor, cFactor, selectedHazard, designDensity, areaPerHead,
                            pixelsPerMeter, scalePoints,
                            drawnPipes, placedSprinklers,
                            results, totalDemand, sourceNodeId,
                            visualNodes,
                            bgImageData
                        }
                    };

                    const jsonString = JSON.stringify(projectData, null, 2);

                    // 1. Try Saving to existing Handle
                    if (!saveAs && projectHandle.current) {
                        try {
                            const writable = await projectHandle.current.createWritable();
                            await writable.write(jsonString);
                            await writable.close();
                            alert("Project Saved!");
                            return;
                        } catch (e) {
                            console.warn("Handle invalid or permission denied, falling back to Save As flow", e);
                            // If handle fails, fall through to try "Save As" logic below
                        }
                    }

                    // 2. Try "Save As" using File System Access API
                    if (window.showSaveFilePicker) {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: 'Hydraulic_Project.json',
                                types: [{
                                    description: 'Hydraulic Project File',
                                    accept: { 'application/json': ['.json'] },
                                }],
                            });
                            projectHandle.current = handle;
                            const writable = await handle.createWritable();
                            await writable.write(jsonString);
                            await writable.close();
                            alert("Project Saved As New File!");
                            return; // Success, exit
                        } catch (err) {
                            // If user cancelled, stop.
                            if (err.name === 'AbortError') return;
                            // If SecurityError or other error, catch and fall through to Blob download
                            console.warn("File System Access API failed, falling back to download:", err);
                        }
                    }

                    // 3. Fallback: Classic Download Method (Works in iFrames/Cross-origin)
                    const blob = new Blob([jsonString], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `project_${Date.now()}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);

                } catch (err) {
                    console.error("Save failed", err);
                    alert("Error saving project: " + err.message);
                }
            };

            const loadProject = async () => {
                try {
                    let usedPicker = false;
                    // 1. Try File System Access API
                    if (window.showOpenFilePicker) {
                        try {
                            const [handle] = await window.showOpenFilePicker({
                                types: [{
                                    description: 'Hydraulic Project File',
                                    accept: { 'application/json': ['.json'] },
                                }],
                                multiple: false
                            });
                            projectHandle.current = handle;
                            const file = await handle.getFile();
                            const text = await file.text();
                            const data = JSON.parse(text);
                            restoreState(data);
                            usedPicker = true;
                        } catch (err) {
                            if (err.name === 'AbortError') return;
                            console.warn("File System Access API failed, falling back to input:", err);
                        }
                    }

                    // 2. Fallback: Hidden Input Click
                    if (!usedPicker) {
                        if (projectInputRef.current) projectInputRef.current.click();
                    }
                } catch (err) {
                    console.error(err);
                }
            };

            const handleProjectFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        projectHandle.current = null; // Reset handle as we can't save back to input file directly
                        restoreState(data);
                    } catch (err) {
                        alert("Invalid project file");
                    }
                };
                reader.readAsText(file);
                // Reset value so same file can be selected again
                e.target.value = '';
            };

            const restoreState = (data) => {
                if (data.state) {
                    const s = data.state;
                    setKFactor(s.kFactor);
                    setCFactor(s.cFactor);
                    setSelectedHazard(s.selectedHazard);
                    setDesignDensity(s.designDensity);
                    setAreaPerHead(s.areaPerHead);
                    setPixelsPerMeter(s.pixelsPerMeter);
                    setScalePoints(s.scalePoints || []);
                    setDrawnPipes(s.drawnPipes || []);
                    setPlacedSprinklers(s.placedSprinklers || []);
                    setResults(s.results || []);
                    setTotalDemand(s.totalDemand || { flow: 0, pressure: 0 });
                    setSourceNodeId(s.sourceNodeId);
                    setVisualNodes(s.visualNodes || []);

                    if (s.bgImageData) {
                        setPdfUrl(s.bgImageData);
                    } else {
                        setPdfUrl(null);
                    }
                    // Reset history
                    setHistory([{ pipes: s.drawnPipes || [], sprinklers: s.placedSprinklers || [] }]);
                    setHistoryIndex(0);

                    alert("Project Loaded Successfully!");
                }
            };

            const getContrastColor = (hexcolor) => {
                if (!hexcolor) return '#000000';
                hexcolor = hexcolor.replace("#", "");
                const r = parseInt(hexcolor.substr(0, 2), 16);
                const g = parseInt(hexcolor.substr(2, 2), 16);
                const b = parseInt(hexcolor.substr(4, 2), 16);
                const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                return (yiq >= 128) ? '#000000' : '#ffffff';
            };

            const commitToHistory = (newPipes, newSprinklers) => {
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push({ pipes: newPipes, sprinklers: newSprinklers });
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
            };

            const handleUndo = () => {
                if (historyIndex > 0) {
                    const prevIndex = historyIndex - 1;
                    const prevState = history[prevIndex];
                    setDrawnPipes(prevState.pipes);
                    setPlacedSprinklers(prevState.sprinklers);
                    setHistoryIndex(prevIndex);
                    setResults([]);
                    setTotalDemand({ flow: 0, pressure: 0 });
                }
            };

            const handleRedo = () => {
                if (historyIndex < history.length - 1) {
                    const nextIndex = historyIndex + 1;
                    const nextState = history[nextIndex];
                    setDrawnPipes(nextState.pipes);
                    setPlacedSprinklers(nextState.sprinklers);
                    setHistoryIndex(nextIndex);
                    setResults([]);
                    setTotalDemand({ flow: 0, pressure: 0 });
                }
            };

            // Improved re-node logic: DFS Post-Order
            useEffect(() => {
                const uniqueNodes = new Map();
                const adj = {};
                const getKey = (pt) => `${pt.x.toFixed(1)},${pt.y.toFixed(1)}`;

                drawnPipes.forEach(p => {
                    const k1 = getKey(p.start);
                    const k2 = getKey(p.end);

                    if (!uniqueNodes.has(k1)) uniqueNodes.set(k1, { id: k1, x: p.start.x, y: p.start.y, degree: 0, maxPipeSize: 0 });
                    if (!uniqueNodes.has(k2)) uniqueNodes.set(k2, { id: k2, x: p.end.x, y: p.end.y, degree: 0, maxPipeSize: 0 });

                    uniqueNodes.get(k1).degree++;
                    uniqueNodes.get(k2).degree++;

                    const sizeVal = parseFloat(p.size);
                    uniqueNodes.get(k1).maxPipeSize = Math.max(uniqueNodes.get(k1).maxPipeSize, sizeVal);
                    uniqueNodes.get(k2).maxPipeSize = Math.max(uniqueNodes.get(k2).maxPipeSize, sizeVal);

                    if (!adj[k1]) adj[k1] = [];
                    if (!adj[k2]) adj[k2] = [];
                    adj[k1].push(k2);
                    adj[k2].push(k1);
                });

                let allNodes = Array.from(uniqueNodes.values());
                if (allNodes.length === 0) {
                    setVisualNodes([]);
                    return;
                }

                // Identify Source
                allNodes.sort((a, b) => {
                    if (b.maxPipeSize !== a.maxPipeSize) return b.maxPipeSize - a.maxPipeSize;
                    const degA = a.degree === 1 ? 1 : 0;
                    const degB = b.degree === 1 ? 1 : 0;
                    if (degA !== degB) return degB - degA;
                    if (Math.abs(a.x - b.x) > 1) return a.x - b.x;
                    return a.y - b.y;
                });
                let sourceNode = allNodes[0];

                const maxDepthMap = {};

                const calcMaxDepth = (u, p) => {
                    let maxD = 0;
                    if (adj[u]) {
                        adj[u].forEach(v => {
                            if (v !== p) {
                                maxD = Math.max(maxD, calcMaxDepth(v, u) + 1);
                            }
                        });
                    }
                    maxDepthMap[u] = maxD;
                    return maxD;
                };

                try {
                    const childrenMap = {};
                    const visitedBFS = new Set([sourceNode.id]);
                    const queue = [sourceNode.id];
                    allNodes.forEach(n => childrenMap[n.id] = []);

                    while (queue.length > 0) {
                        const u = queue.shift();
                        if (adj[u]) {
                            adj[u].forEach(v => {
                                if (!visitedBFS.has(v)) {
                                    visitedBFS.add(v);
                                    childrenMap[u].push(v);
                                    queue.push(v);
                                }
                            });
                        }
                    }

                    const calcDepthSafe = (u) => {
                        let maxD = 0;
                        childrenMap[u].forEach(v => {
                            maxD = Math.max(maxD, calcDepthSafe(v) + 1);
                        });
                        maxDepthMap[u] = maxD;
                        return maxD;
                    };
                    calcDepthSafe(sourceNode.id);

                    const finalOrder = [];
                    const dfsNumbering = (u) => {
                        const children = childrenMap[u];
                        children.sort((a, b) => {
                            const depthA = maxDepthMap[a] || 0;
                            const depthB = maxDepthMap[b] || 0;
                            if (depthA !== depthB) return depthB - depthA;
                            const nodeA = uniqueNodes.get(a);
                            const nodeB = uniqueNodes.get(b);
                            if (Math.abs(nodeA.y - nodeB.y) > 5) return nodeA.y - nodeB.y;
                            return nodeA.x - nodeB.x;
                        });
                        children.forEach(v => dfsNumbering(v));
                        finalOrder.push(u);
                    };
                    dfsNumbering(sourceNode.id);

                    let counter = 1;
                    finalOrder.forEach((nodeId) => {
                        if (uniqueNodes.has(nodeId)) {
                            uniqueNodes.get(nodeId).displayId = counter++;
                        }
                    });

                    // Handle disconnected
                    allNodes.forEach(n => {
                        if (!visitedBFS.has(n.id)) {
                            n.displayId = counter++;
                        }
                    });

                } catch (e) { console.warn("Node sorting failed", e); }

                setVisualNodes(Array.from(uniqueNodes.values()));
                setSourceNodeId(sourceNode.id);

            }, [drawnPipes]);

            const handleHazardChange = (e) => {
                const hazardId = e.target.value;
                setSelectedHazard(hazardId);
                const hazard = hazardClasses.find(h => h.id === hazardId);
                if (hazard) {
                    setDesignDensity(hazard.density);
                    if (hazard.defaultArea) {
                        setAreaPerHead(hazard.defaultArea);
                    }
                }
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                if (pdfUrl && pdfUrl.startsWith('blob:')) URL.revokeObjectURL(pdfUrl);
                setPdfUrl(URL.createObjectURL(file));
                // Only reset if loading new background manually, or ask user? 
                // Currently just setting BG, keeping pipes.
                // setScalePoints([]);
                // setDrawnPipes([]);
                // setPlacedSprinklers([]);
                // setResults([]);
                // setVisualNodes([]);
                // setTotalDemand({ flow: 0, pressure: 0 });
                // setTransform({ x: 0, y: 0, scale: 1 });
                // setMode('pan');
                // setSourceNodeId(null);
                // setHistory([{ pipes: [], sprinklers: [] }]);
                // setHistoryIndex(0);
                // Resetting project handle as the context changed
                projectHandle.current = null;
            };




            const isPointInPolygon = (point, vs) => {
                let x = point.x, y = point.y;
                let inside = false;
                for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                    let xi = vs[i].x, yi = vs[i].y;
                    let xj = vs[j].x, yj = vs[j].y;
                    let intersect = ((yi > y) !== (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            };

            const generateGridInPolygon = (points) => {
                if (!pixelsPerMeter) {
                    alert("Please Set Scale First");
                    return;
                }
                const M_TO_FT = 3.28084;

                // 1. Bounds
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                points.forEach(p => {
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                });

                const widthPx = maxX - minX;
                const heightPx = maxY - minY;

                // Restore missing definitions
                const widthM = widthPx / pixelsPerMeter;
                const heightM = heightPx / pixelsPerMeter;

                // Restore M_TO_FT for display usage if needed, though we work in M for grid now
                // widthFt, heightFt definitions removed as we use M now

                const currentHazard = hazardClasses.find(h => h.id === selectedHazard);

                let MAX_AREA_M2;
                let targetSx; // Spacing X
                let targetSy; // Spacing Y

                if (selectedHazard.startsWith('EH')) {
                    // Extra Hazard
                    MAX_AREA_M2 = 9.00;
                    targetSx = 3.0;
                    targetSy = 3.0;
                } else if (selectedHazard === 'LH') {
                    // Light Hazard
                    MAX_AREA_M2 = 16.00; // Updated to 16 m²
                    targetSx = 4.0;
                    targetSy = 4.0;      // Updated to 4x4 m
                } else {
                    // Ordinary Hazard (OH1, OH2)
                    MAX_AREA_M2 = 12.10;
                    targetSx = 4.0;
                    targetSy = 3.0;
                }

                // Calculate Grid Counts (Reduce distance if needed by ceiling the count)
                let numCols = Math.ceil(widthM / targetSx);
                let numRows = Math.ceil(heightM / targetSy);

                // Ensure strict area compliance (Iterative adjustment if area > limit)
                // Though 4x3 = 12 <= 12.10, floating point or edge cases might occur
                let isValid = false;
                while (!isValid) {
                    const spX = widthM / numCols;
                    const spY = heightM / numRows;
                    const area = spX * spY;

                    if (area <= MAX_AREA_M2) {
                        isValid = true;
                    } else {
                        // Area too big, add a row or col
                        // Prefer adding to the dimension with larger spacing to balance?
                        // Or just simple increment
                        if (spX > spY) numCols++;
                        else numRows++;
                    }
                    if (numCols > 200 || numRows > 200) break; // Safety break
                }

                // Recalculate final spacing in Pixels for placement
                const finalSxM = widthM / numCols;
                const finalSyM = heightM / numRows;

                const SpacingX_Px = finalSxM * pixelsPerMeter;
                const SpacingY_Px = finalSyM * pixelsPerMeter;

                const newSprinklers = [];
                // Shift grid to center within the bounding box
                const startX = minX + (SpacingX_Px / 2);
                const startY = minY + (SpacingY_Px / 2);

                for (let r = 0; r < numRows; r++) {
                    for (let c = 0; c < numCols; c++) {
                        const p = {
                            x: startX + c * SpacingX_Px,
                            y: startY + r * SpacingY_Px
                        };
                        if (isPointInPolygon(p, points)) {
                            newSprinklers.push({ ...p, id: Date.now() + Math.random() });
                        }
                    }
                }

                if (newSprinklers.length > 0) {
                    const selectedAreaM2 = widthM * heightM;

                    if (window.confirm(`Detected Area based on ${currentHazard?.label || 'Hazard'}.\nSelected Area: ${selectedAreaM2.toFixed(2)} m²\nMaximum Distance: ${Math.max(targetSx, targetSy).toFixed(2)} m\nmaximum area / head = ${MAX_AREA_M2.toFixed(2)} m²\nValid Heads: ${newSprinklers.length}\n\nAdd these sprinklers?`)) {
                        setPlacedSprinklers(prev => [...prev, ...newSprinklers]);
                        commitToHistory(drawnPipes, [...placedSprinklers, ...newSprinklers]);
                    }
                }
            };

            const getCanvasCoords = (e) => {
                if (!containerRef.current) return { x: 0, y: 0 };
                const rect = containerRef.current.getBoundingClientRect();
                return {
                    x: (e.clientX - rect.left - transform.x) / transform.scale,
                    y: (e.clientY - rect.top - transform.y) / transform.scale
                };
            };

            const projectPointToSegment = (P, A, B) => {
                const distAB2 = Math.pow(B.x - A.x, 2) + Math.pow(B.y - A.y, 2);
                if (distAB2 === 0) return A;
                let t = ((P.x - A.x) * (B.x - A.x) + (P.y - A.y) * (B.y - A.y)) / distAB2;
                t = Math.max(0, Math.min(1, t));
                return { x: A.x + t * (B.x - A.x), y: A.y + t * (B.y - A.y) };
            };

            const getSnappedCoords = (rawCoords) => {
                if (mode !== 'draw' && mode !== 'sprinkler') return { coords: rawCoords, isSnapped: false };

                const snapThreshold = 15 / transform.scale;
                let closestPoint = null;
                let minDistance = Infinity;
                let snapType = null;
                let snapTarget = null;

                placedSprinklers.forEach(s => {
                    const dist = Math.sqrt(Math.pow(s.x - rawCoords.x, 2) + Math.pow(s.y - rawCoords.y, 2));
                    if (dist < snapThreshold && dist < minDistance) {
                        minDistance = dist;
                        closestPoint = { x: s.x, y: s.y };
                        snapType = 'node';
                        snapTarget = s;
                    }
                });

                drawnPipes.forEach(pipe => {
                    [pipe.start, pipe.end].forEach(pt => {
                        const dist = Math.sqrt(Math.pow(pt.x - rawCoords.x, 2) + Math.pow(pt.y - rawCoords.y, 2));
                        if (dist < snapThreshold && dist < minDistance) {
                            minDistance = dist;
                            closestPoint = pt;
                            snapType = 'node';
                            snapTarget = pipe;
                        }
                    });
                });

                if (!closestPoint) {
                    drawnPipes.forEach(pipe => {
                        const projected = projectPointToSegment(rawCoords, pipe.start, pipe.end);
                        const dist = Math.sqrt(Math.pow(projected.x - rawCoords.x, 2) + Math.pow(projected.y - rawCoords.y, 2));
                        if (dist < snapThreshold && dist < minDistance) {
                            minDistance = dist;
                            closestPoint = projected;
                            snapType = 'edge';
                            snapTarget = pipe;
                        }
                    });
                }

                if (closestPoint) return { coords: closestPoint, isSnapped: true, snapType, snapTarget };
                return { coords: rawCoords, isSnapped: false, snapType: null, snapTarget: null };
            };

            const splitPipeAtPoint = (pipes, targetPipe, splitPoint) => {
                const remainingPipes = pipes.filter(p => p.id !== targetPipe.id);
                const dist1 = Math.sqrt(Math.pow(splitPoint.x - targetPipe.start.x, 2) + Math.pow(splitPoint.y - targetPipe.start.y, 2));
                const dist2 = Math.sqrt(Math.pow(targetPipe.end.x - splitPoint.x, 2) + Math.pow(targetPipe.end.y - splitPoint.y, 2));

                const newSegments = [];
                if (dist1 > 0.1) {
                    newSegments.push({ ...targetPipe, id: Date.now() + Math.random(), end: splitPoint, pixelLength: dist1 });
                }
                if (dist2 > 0.1) {
                    newSegments.push({ ...targetPipe, id: Date.now() + Math.random() + 1, start: splitPoint, pixelLength: dist2 });
                }
                return [...remainingPipes, ...newSegments];
            };

            const distanceToSegment = (P, A, B) => {
                const distAB2 = Math.pow(B.x - A.x, 2) + Math.pow(B.y - A.y, 2);
                if (distAB2 === 0) return Math.sqrt(Math.pow(P.x - A.x, 2) + Math.pow(P.y - A.y, 2));
                let t = ((P.x - A.x) * (B.x - A.x) + (P.y - A.y) * (B.y - A.y)) / distAB2;
                t = Math.max(0, Math.min(1, t));
                return Math.sqrt(Math.pow(P.x - (A.x + t * (B.x - A.x)), 2) + Math.pow(P.y - (A.y + t * (B.y - A.y)), 2));
            };

            const handleMouseDown = (e) => {
                if (showScaleDialog || editingPipeId) return;

                // Middle Mouse (Button 1) -> Pan Override
                if (e.button === 1) {
                    e.preventDefault();
                    setIsDragging(true);
                    setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
                    return;
                }

                // Allow only Left Mouse Button (0) for Drawing
                if (mode === 'draw' && e.button !== 0) return;

                const rawCoords = getCanvasCoords(e);
                const { coords, isSnapped, snapType, snapTarget } = getSnappedCoords(rawCoords);

                if (mode === 'pan') {
                    setIsDragging(true);
                    setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
                } else if (mode === 'scale') {
                    setIsDragging(true);
                    setScalePoints([coords, coords]);
                } else if (mode === 'draw') {
                    setIsDragging(true);
                    setStartSnapInfo(isSnapped ? { type: snapType, target: snapTarget, coords: coords } : null);
                    setTempPipe({ start: coords, end: coords, size: selectedPipeSize });
                } else if (mode === 'auto_sprinkler') {
                    // Only Box Mode Supported
                    setTempRect(null); // Ensure no stale rect
                    setIsDragging(true);
                    setDragStart({ x: e.clientX, y: e.clientY });
                }
            };


            const handleMouseMove = (e) => {
                if (showScaleDialog || editingPipeId) return;
                const rawCoords = getCanvasCoords(e);

                let effectiveCoords = rawCoords;

                if (isDragging && mode === 'draw' && tempPipe) {
                    const dx = rawCoords.x - tempPipe.start.x;
                    const dy = rawCoords.y - tempPipe.start.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 5 / transform.scale) {
                        const angle = Math.atan2(dy, dx);
                        const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);

                        effectiveCoords = {
                            x: tempPipe.start.x + Math.cos(snappedAngle) * dist,
                            y: tempPipe.start.y + Math.sin(snappedAngle) * dist
                        };
                    } else {
                        effectiveCoords = tempPipe.start;
                    }
                }

                // Check Alignment
                const { coords: pointSnappedCoords, isSnapped, snapType, snapTarget } = getSnappedCoords(effectiveCoords);
                let finalCoords = isSnapped ? pointSnappedCoords : effectiveCoords;
                const newAlignmentLines = [];

                setPipeAlignmentGuide(null);

                if (isSnapped && snapType === 'edge' && (mode === 'sprinkler')) {
                    const pipe = snapTarget;
                    const headsOnPipe = placedSprinklers.filter(s => distanceToSegment(s, pipe.start, pipe.end) < 1);

                    headsOnPipe.sort((a, b) => {
                        const da = Math.pow(a.x - pipe.start.x, 2) + Math.pow(a.y - pipe.start.y, 2);
                        const db = Math.pow(b.x - pipe.start.x, 2) + Math.pow(b.y - pipe.start.y, 2);
                        return da - db;
                    });

                    let isMidpoint = false;
                    const snapThreshold = 10 / transform.scale;

                    for (let i = 0; i < headsOnPipe.length - 1; i++) {
                        const h1 = headsOnPipe[i];
                        const h2 = headsOnPipe[i + 1];
                        const mx = (h1.x + h2.x) / 2;
                        const my = (h1.y + h2.y) / 2;

                        const distToMid = Math.sqrt(Math.pow(finalCoords.x - mx, 2) + Math.pow(finalCoords.y - my, 2));

                        if (distToMid < snapThreshold) {
                            finalCoords = { x: mx, y: my };
                            isMidpoint = true;
                            break;
                        }
                    }

                    setPipeAlignmentGuide({
                        p1: pipe.start,
                        p2: pipe.end,
                        heads: headsOnPipe,
                        cursor: finalCoords,
                        isMidpoint: isMidpoint
                    });
                }
                else if (!isSnapped && mode === 'draw' && tempPipe) {
                    const p1 = tempPipe.start;
                    const dx = effectiveCoords.x - p1.x;
                    const dy = effectiveCoords.y - p1.y;
                    const len2 = dx * dx + dy * dy;

                    if (len2 > 0.001) {
                        const alignThreshold = 10 / transform.scale;
                        let bestProj = null;
                        let minDist = alignThreshold;
                        let bestHead = null;

                        placedSprinklers.forEach(s => {
                            const v1x = s.x - p1.x;
                            const v1y = s.y - p1.y;
                            const t = (v1x * dx + v1y * dy) / len2;
                            const projX = p1.x + t * dx;
                            const projY = p1.y + t * dy;
                            const dist = Math.sqrt(Math.pow(finalCoords.x - projX, 2) + Math.pow(finalCoords.y - projY, 2));

                            if (dist < minDist) {
                                minDist = dist;
                                bestProj = { x: projX, y: projY };
                                bestHead = s;
                            }
                        });

                        if (bestProj) {
                            finalCoords = bestProj;
                            newAlignmentLines.push({
                                x1: bestHead.x, y1: bestHead.y,
                                x2: bestProj.x, y2: bestProj.y
                            });
                        }
                    }
                }
                else if (!isSnapped && mode === 'sprinkler') {
                    const alignThreshold = 10 / transform.scale;
                    placedSprinklers.forEach(s => {
                        if (Math.abs(effectiveCoords.x - s.x) < alignThreshold) {
                            finalCoords = { ...finalCoords, x: s.x };
                            newAlignmentLines.push({ x1: s.x, y1: s.y, x2: s.x, y2: finalCoords.y });
                        }
                        if (Math.abs(effectiveCoords.y - s.y) < alignThreshold) {
                            finalCoords = { ...finalCoords, y: s.y };
                            newAlignmentLines.push({ x1: s.x, y1: s.y, x2: finalCoords.x, y2: s.y });
                        }
                    });
                }

                setAlignmentLines(newAlignmentLines);

                if (mode === 'sprinkler' && placedSprinklers.length > 0) {
                    let minD = Infinity;
                    let closest = null;
                    const candidates = (pipeAlignmentGuide && pipeAlignmentGuide.heads.length > 0)
                        ? pipeAlignmentGuide.heads
                        : placedSprinklers;

                    candidates.forEach(s => {
                        const d = Math.sqrt(Math.pow(s.x - finalCoords.x, 2) + Math.pow(s.y - finalCoords.y, 2));
                        if (d > 0.1 && d < minD) {
                            minD = d;
                            closest = s;
                        }
                    });

                    if (closest) {
                        const lenPx = minD;
                        const lenText = pixelsPerMeter
                            ? `${(lenPx / pixelsPerMeter).toFixed(1)} m.`
                            : `${Math.round(lenPx)} px`;

                        setSprinklerDistanceGuide({
                            start: closest,
                            end: finalCoords,
                            text: lenText
                        });
                    } else {
                        setSprinklerDistanceGuide(null);
                    }
                } else {
                    setSprinklerDistanceGuide(null);
                }

                const snapPointToUse = isSnapped ? pointSnappedCoords : (newAlignmentLines.length > 0 ? finalCoords : null);
                setSnapPoint(pipeAlignmentGuide?.isMidpoint ? finalCoords : snapPointToUse);

                if (isDragging) {
                    if (mode === 'pan' || (e.buttons & 4)) {
                        setTransform(prev => ({ ...prev, x: e.clientX - dragStart.x, y: e.clientY - dragStart.y }));
                    } else if (mode === 'scale') {
                        // Modified Scale Drawing: Snap to Axis (Orthogonal)
                        // If dx > dy, assume Horizontal line, snap y to startY
                        // If dy > dx, assume Vertical line, snap x to startX
                        const start = scalePoints[0];
                        const current = rawCoords;
                        const dx = Math.abs(current.x - start.x);
                        const dy = Math.abs(current.y - start.y);

                        let nextPoint = current;
                        if (dx > dy) {
                            nextPoint = { x: current.x, y: start.y };
                        } else {
                            nextPoint = { x: start.x, y: current.y };
                        }

                        setScalePoints(prev => [prev[0], nextPoint]);
                    } else if (mode === 'draw') {
                        setTempPipe(prev => ({ ...prev, end: finalCoords }));
                    } else if (mode === 'auto_sprinkler') {
                        // Only Box Mode
                        if (tempRect) {
                            setTempRect(prev => ({ ...prev, end: rawCoords }));
                        } else {
                            const dx = e.clientX - dragStart.x;
                            const dy = e.clientY - dragStart.y;
                            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                                const rect = containerRef.current.getBoundingClientRect();
                                const startCanvX = (dragStart.x - rect.left - transform.x) / transform.scale;
                                const startCanvY = (dragStart.y - rect.top - transform.y) / transform.scale;
                                setTempRect({ start: { x: startCanvX, y: startCanvY }, end: rawCoords });
                            }
                        }
                    }
                }
            };

            const handleMouseUp = (e) => {
                if (showScaleDialog || editingPipeId) return;

                if (mode === 'scale' && isDragging) {
                    const dx = scalePoints[1].x - scalePoints[0].x;
                    const dy = scalePoints[1].y - scalePoints[0].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 5) {
                        setShowScaleDialog(true);
                        setRealWorldDist('');
                        setIsDragging(false);
                        return;
                    } else {
                        setScalePoints([]);
                    }
                } else if (mode === 'draw' && isDragging && tempPipe) {
                    const finalEnd = tempPipe.end;
                    const { isSnapped, snapType, snapTarget, coords: snappedCoords } = getSnappedCoords(finalEnd);
                    const actualEnd = isSnapped ? snappedCoords : finalEnd;
                    const dx = actualEnd.x - tempPipe.start.x;
                    const dy = actualEnd.y - tempPipe.start.y;
                    const pixelLen = Math.sqrt(dx * dx + dy * dy);

                    if (pixelLen > 2) {
                        let nextPipes = [...drawnPipes];
                        let startPoint = tempPipe.start;
                        let endPoint = actualEnd;

                        if (startSnapInfo && startSnapInfo.type === 'edge' && startSnapInfo.target) {
                            const targetPipe = nextPipes.find(p => p.id === startSnapInfo.target.id);
                            if (targetPipe) {
                                nextPipes = splitPipeAtPoint(nextPipes, targetPipe, startSnapInfo.coords);
                                startPoint = startSnapInfo.coords;
                            }
                        }

                        if (isSnapped && snapType === 'edge' && snapTarget) {
                            const targetPipe = nextPipes.find(p => p.id === snapTarget.id);
                            if (targetPipe) {
                                nextPipes = splitPipeAtPoint(nextPipes, targetPipe, actualEnd);
                                endPoint = actualEnd;
                            }
                        }

                        const newPipe = {
                            id: Date.now() + Math.random(),
                            start: startPoint,
                            end: endPoint,
                            size: tempPipe.size,
                            pixelLength: pixelLen
                        };
                        nextPipes.push(newPipe);
                        setDrawnPipes(nextPipes);
                        commitToHistory(nextPipes, placedSprinklers);
                    }
                    setTempPipe(null);
                    setStartSnapInfo(null);
                } else if (mode === 'auto_sprinkler') {
                    if (tempRect) {
                        // Box Completed
                        const { start, end } = tempRect;
                        const width = Math.abs(end.x - start.x);
                        const height = Math.abs(end.y - start.y);

                        // Prevent accidental clicks or tiny drags from triggering
                        if (width > 10 / transform.scale && height > 10 / transform.scale) {
                            const p1 = { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) };
                            const p2 = { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) };
                            const p3 = { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };
                            const p4 = { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };
                            generateGridInPolygon([p1, p2, p3, p4]);
                        }
                        setTempRect(null);
                    }
                }


                setIsDragging(false);
                setAlignmentLines([]);
                setSprinklerDistanceGuide(null);
                setPipeAlignmentGuide(null);
            };

            const handleCanvasClick = (e) => {
                if (showScaleDialog || editingPipeId) return;
                const rawCoords = getCanvasCoords(e);
                const { coords: pointSnappedCoords, isSnapped, snapType, snapTarget } = getSnappedCoords(rawCoords);
                let finalCoords = isSnapped ? pointSnappedCoords : rawCoords;

                if (!isSnapped && mode === 'sprinkler') {
                    const alignThreshold = 10 / transform.scale;
                    let alignedX = rawCoords.x;
                    let alignedY = rawCoords.y;
                    placedSprinklers.forEach(s => {
                        if (Math.abs(rawCoords.x - s.x) < alignThreshold) alignedX = s.x;
                        if (Math.abs(rawCoords.y - s.y) < alignThreshold) alignedY = s.y;
                    });
                    finalCoords = { x: alignedX, y: alignedY };
                }

                if (mode === 'sprinkler') {
                    const newSprinklers = [...placedSprinklers, { ...finalCoords, id: Date.now() }];
                    setPlacedSprinklers(newSprinklers);
                    let nextPipes = drawnPipes;
                    if (isSnapped && snapType === 'edge' && snapTarget) {
                        nextPipes = splitPipeAtPoint(drawnPipes, snapTarget, finalCoords);
                        setDrawnPipes(nextPipes);
                    }
                    commitToHistory(nextPipes, newSprinklers);
                } else if (mode === 'delete') {
                    const clickThreshold = 10 / transform.scale;
                    const pipeToDelete = drawnPipes.find(pipe => {
                        const dist = distanceToSegment(rawCoords, pipe.start, pipe.end);
                        return dist < clickThreshold;
                    });

                    if (pipeToDelete) {
                        const nextPipes = drawnPipes.filter(p => p.id !== pipeToDelete.id);
                        setDrawnPipes(nextPipes);
                        commitToHistory(nextPipes, placedSprinklers);
                    } else {
                        const sprinklerToDelete = placedSprinklers.find(s => {
                            const dist = Math.sqrt(Math.pow(s.x - rawCoords.x, 2) + Math.pow(s.y - rawCoords.y, 2));
                            return dist < clickThreshold;
                        });
                        if (sprinklerToDelete) {
                            const nextSprinklers = placedSprinklers.filter(s => s.id !== sprinklerToDelete.id);
                            setPlacedSprinklers(nextSprinklers);
                            commitToHistory(drawnPipes, nextSprinklers);
                        }
                    }
                }
            };

            const handleCanvasDoubleClick = (e) => {
                if (showScaleDialog) return;
                const rawCoords = getCanvasCoords(e);
                const clickThreshold = 10 / transform.scale;
                const clickedPipe = drawnPipes.find(pipe => {
                    const dist = distanceToSegment(rawCoords, pipe.start, pipe.end);
                    return dist < clickThreshold;
                });
                if (clickedPipe) {
                    setEditingPipeId(clickedPipe.id);
                }
            };

            const updatePipeSize = (newSize) => {
                const nextPipes = drawnPipes.map(p =>
                    p.id === editingPipeId ? { ...p, size: newSize } : p
                );
                setDrawnPipes(nextPipes);
                setResults([]);
                setTotalDemand({ flow: 0, pressure: 0 });
                commitToHistory(nextPipes, placedSprinklers);
                setEditingPipeId(null);
            };

            const applyScale = () => {
                if (scalePoints.length < 2) return;
                const dx = scalePoints[1].x - scalePoints[0].x;
                const dy = scalePoints[1].y - scalePoints[0].y;
                const pixelDist = Math.sqrt(dx * dx + dy * dy);
                const rDist = parseFloat(realWorldDist);

                if (pixelDist > 0 && rDist > 0) {
                    setPixelsPerMeter(pixelDist / rDist);
                    setMode('pan');
                    setShowScaleDialog(false);
                    setScalePoints([]);
                } else {
                    alert("กรุณาระบุระยะทางที่ถูกต้อง");
                }
            };

            const adjustZoom = (delta) => {
                if (!containerRef.current) return;
                const zoomStep = 0.15;
                const oldScale = transform.scale;
                const newScale = Math.min(Math.max(oldScale + (delta > 0 ? zoomStep : -zoomStep), 0.1), 10);
                const rect = containerRef.current.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                const worldX = (centerX - transform.x) / oldScale;
                const worldY = (centerY - transform.y) / oldScale;
                const newX = centerX - worldX * newScale;
                const newY = centerY - worldY * newScale;
                setTransform({ x: newX, y: newY, scale: newScale });
            };

            const calculateLoss = (Q, L_ft, d_in, C) => {
                if (Q <= 0 || L_ft <= 0) return 0;
                // Hazen-Williams Formula for Friction Loss
                return (4.52 * Math.pow(Q, 1.85) * L_ft) / (Math.pow(C, 1.85) * Math.pow(d_in, 4.87));
            };

            const handleCalculate = () => {
                try {
                    if (!pixelsPerMeter) {
                        alert("กรุณากำหนดสเกล (Set Scale) ก่อนคำนวณ");
                        return;
                    }
                    if (drawnPipes.length === 0) {
                        alert("กรุณาวาดท่ออย่างน้อย 1 เส้น");
                        return;
                    }

                    const M_TO_FT = 3.28084;
                    const K = Number(kFactor) || 5.6;
                    const C = Number(cFactor) || 120;
                    const RISER_NIPPLE_FT = 0.1 * M_TO_FT;
                    const NIPPLE_ID = 1.049;
                    const density = Number(designDensity) || 0.10;
                    const areaFt2 = Number(areaPerHead) || 130;

                    // Initial Requirements (Most Remote Head)
                    const qMinHead = density * areaFt2;
                    const minP_Req = Math.pow(qMinHead / K, 2);
                    const startPressureReq = Math.max(7, minP_Req);

                    const nodes = {};
                    const coordToDisplayId = {};
                    const getKey = (pt) => `${pt.x.toFixed(1)},${pt.y.toFixed(1)}`;

                    visualNodes.forEach(node => {
                        coordToDisplayId[node.id] = node.displayId;
                    });

                    const getOrCreateNode = (pt) => {
                        const key = getKey(pt);
                        if (!nodes[key]) nodes[key] = { id: key, x: pt.x, y: pt.y, connections: [], heads: [] };
                        return nodes[key];
                    };

                    drawnPipes.forEach(p => {
                        const n1 = getOrCreateNode(p.start);
                        const n2 = getOrCreateNode(p.end);
                        const spec = pipeSpecs.find(s => s.nominal === p.size) || pipeSpecs[0];
                        const uDisp = coordToDisplayId[getKey(p.start)];
                        const vDisp = coordToDisplayId[getKey(p.end)];

                        const edge = {
                            id: p.id,
                            u: n1.id,
                            v: n2.id,
                            u_disp: uDisp,
                            v_disp: vDisp,
                            pipe: p,
                            size: p.size,
                            heads: [],
                            d_in: spec.internal,
                            len_ft: (p.pixelLength / pixelsPerMeter) * M_TO_FT,
                            flow: 0,
                            loss: 0,
                            velocity: 0,
                            flowDir: null,
                            fittingLen: 0,
                            fittings: []
                        };
                        n1.connections.push({ target: n2.id, edge });
                        n2.connections.push({ target: n1.id, edge });
                    });

                    // INCREASED TOLERANCE: Make it easier to snap sprinklers
                    const tolerance = 25 / transform.scale;
                    const qPerHead = density * areaFt2;

                    placedSprinklers.forEach(s => {
                        for (const key in nodes) {
                            const node = nodes[key];
                            const dist = Math.sqrt(Math.pow(s.x - node.x, 2) + Math.pow(s.y - node.y, 2));
                            if (dist < tolerance) {
                                node.heads.push(s);
                                // node.demandQ += qPerHead; // Fixed Flow not used in 2-Pass Pressure logic
                                break;
                            }
                        }
                    });

                    // Logic to find Source Node (same as useEffect)
                    let sourceId = sourceNodeId;
                    const allNodes = Object.values(nodes);

                    if (!sourceId || !nodes[sourceId]) {
                        if (allNodes.length > 0) {
                            const candidates = [...allNodes];
                            candidates.sort((a, b) => {
                                const maxA = a.connections.reduce((m, c) => Math.max(m, parseFloat(c.edge.size)), 0);
                                const maxB = b.connections.reduce((m, c) => Math.max(m, parseFloat(c.edge.size)), 0);
                                if (maxB !== maxA) return maxB - maxA;
                                const degA = a.connections.length === 1 ? 1 : 0;
                                const degB = b.connections.length === 1 ? 1 : 0;
                                if (degA !== degB) return degB - degA;
                                if (Math.abs(a.x - b.x) > 1) return a.x - b.x;
                                return a.y - b.y;
                            });
                            sourceId = candidates[0].id;
                            // Update the state so the red dot matches
                            setSourceNodeId(sourceId);
                        }
                    }

                    if (!sourceId) {
                        alert("ไม่สามารถหาจุดต้นทาง (Source Node) ได้ กรุณาลองวาดท่อใหม่");
                        return;
                    }

                    // --- Auto-Detect Fittings (Elbows/Tees) ---
                    allNodes.forEach(node => {
                        if (node.connections.length === 2) {
                            const conn1 = node.connections[0];
                            const conn2 = node.connections[1];
                            const p1 = conn1.edge.pipe;
                            const p2 = conn2.edge.pipe;

                            const getVec = (pipe, centerNode) => {
                                // Simplified ID check to avoid float issues
                                const kStart = getKey(pipe.start);
                                const kEnd = getKey(pipe.end);
                                if (kStart === centerNode.id) {
                                    return { x: pipe.end.x - pipe.start.x, y: pipe.end.y - pipe.start.y };
                                } else {
                                    return { x: pipe.start.x - pipe.end.x, y: pipe.start.y - pipe.end.y };
                                }
                            };
                            const v1 = getVec(p1, node);
                            const v2 = getVec(p2, node);

                            const dot = v1.x * v2.x + v1.y * v2.y;
                            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);

                            if (mag1 > 0 && mag2 > 0) {
                                const angleRad = Math.acos(dot / (mag1 * mag2));
                                const angleDeg = angleRad * (180 / Math.PI);

                                if (Math.abs(angleDeg - 90) < 15) {
                                    let targetEdge = null;
                                    if (conn1.edge.size === conn2.edge.size) {
                                        targetEdge = (conn1.edge.id < conn2.edge.id) ? conn1.edge : conn2.edge;
                                    } else {
                                        targetEdge = (parseFloat(conn1.edge.size) > parseFloat(conn2.edge.size)) ? conn1.edge : conn2.edge;
                                    }
                                    const standElbow = nfpaData.fittings.find(f => f.code === "SE");
                                    const eqValue = standElbow ? (standElbow.values[targetEdge.size] || 0) : 0;
                                    if (eqValue > 0) {
                                        targetEdge.fittingLen += eqValue;
                                        targetEdge.fittings.push(`1 Elbow (${eqValue} ft)`);
                                    }
                                }
                            }
                        } else if (node.connections.length === 3) {
                            let maxConn = node.connections[0];
                            node.connections.forEach(c => {
                                if (parseFloat(c.edge.size) > parseFloat(maxConn.edge.size)) maxConn = c;
                            });
                            const teeFit = nfpaData.fittings.find(f => f.code === "TT");
                            const eqValue = teeFit ? (teeFit.values[maxConn.edge.size] || 0) : 0;
                            if (eqValue > 0) {
                                maxConn.edge.fittingLen += eqValue;
                                maxConn.edge.fittings.push(`1 Tee (${eqValue} ft)`);
                            }
                        }
                    });

                    const parentMap = {};
                    const processingOrder = [];
                    const visited = new Set([sourceId]);
                    const queue = [sourceId];

                    while (queue.length > 0) {
                        const uId = queue.shift();
                        processingOrder.push(uId);
                        const uNode = nodes[uId];
                        if (uNode && uNode.connections) {
                            uNode.connections.forEach(conn => {
                                if (!visited.has(conn.target)) {
                                    visited.add(conn.target);
                                    parentMap[conn.target] = { parentId: uId, edge: conn.edge };
                                    queue.push(conn.target);
                                }
                            });
                        }
                    }

                    const nodeReqP = {};
                    const nodeTotalQ = {};
                    const nodeActualP = {};
                    const nodeHeadFlow = {};

                    Object.keys(nodes).forEach(k => {
                        nodeReqP[k] = 0;
                        nodeTotalQ[k] = 0;
                        nodeActualP[k] = 0;
                    });

                    const tempReport = {};

                    // Pass 1
                    for (let i = processingOrder.length - 1; i >= 0; i--) {
                        const uId = processingOrder[i];
                        let maxP_RequiredAtU = 0;
                        let totalQ_AtU = 0;

                        const uNode = nodes[uId];
                        if (!uNode) continue;

                        const childConnections = uNode.connections.filter(conn => parentMap[conn.target]?.parentId === uId);

                        childConnections.forEach(child => {
                            const vId = child.target;
                            const edge = child.edge;
                            const qChild = nodeTotalQ[vId] || 0;
                            const pChild = nodeReqP[vId] || 0;

                            if (qChild > 0 || pChild > 0) {
                                const totalLen = edge.len_ft + edge.fittingLen;
                                const loss = calculateLoss(qChild, totalLen, edge.d_in, C);
                                const pReqUpstream = pChild + loss;
                                maxP_RequiredAtU = Math.max(maxP_RequiredAtU, pReqUpstream);
                            }
                        });

                        if (uNode.heads.length > 0) {
                            let pMinHead = startPressureReq;
                            // Recalculate Q based on actual min head pressure 
                            let qHead = K * Math.sqrt(pMinHead);
                            let lossNip = calculateLoss(qHead, RISER_NIPPLE_FT, NIPPLE_ID, C);
                            let pReqAtNodeForHead = pMinHead + lossNip;
                            maxP_RequiredAtU = Math.max(maxP_RequiredAtU, pReqAtNodeForHead);

                            let headFlowSum = 0;
                            uNode.heads.forEach(() => {
                                let pHeadEst = maxP_RequiredAtU;
                                for (let k = 0; k < 2; k++) {
                                    let q = K * Math.sqrt(pHeadEst > 0 ? pHeadEst : 0);
                                    let loss = calculateLoss(q, RISER_NIPPLE_FT, NIPPLE_ID, C);
                                    pHeadEst = maxP_RequiredAtU - loss;
                                }
                                if (pHeadEst < 0) pHeadEst = 0;
                                const q = K * Math.sqrt(pHeadEst);
                                totalQ_AtU += q;
                                headFlowSum += q;
                            });
                            nodeHeadFlow[uId] = headFlowSum;
                        }

                        childConnections.forEach(child => {
                            const vId = child.target;
                            const edge = child.edge;
                            let qBranch = nodeTotalQ[vId] || 0;
                            const pChildReq = nodeReqP[vId] || 0;

                            const totalLen = edge.len_ft + edge.fittingLen;
                            const lossBase = calculateLoss(qBranch, totalLen, edge.d_in, C);
                            const pBranchTotalReq = pChildReq + lossBase;

                            if (maxP_RequiredAtU > pBranchTotalReq && pBranchTotalReq > 0.01 && qBranch > 0) {
                                qBranch = qBranch * Math.pow(maxP_RequiredAtU / pBranchTotalReq, 0.54);
                            }

                            edge.flow = qBranch;
                            edge.loss = calculateLoss(qBranch, totalLen, edge.d_in, C);
                            const velocityFps = (0.4085 * qBranch) / Math.pow(edge.d_in, 2);
                            edge.velocity = velocityFps * 0.3048;
                            edge.flowDir = (edge.u === uId) ? 'u->v' : 'v->u';
                            totalQ_AtU += qBranch;

                            tempReport[edge.id] = {
                                pipeId: edge.id,
                                id: `Pipe ${edge.size}"`,
                                size: edge.size,
                                lengthM: edge.len_ft / M_TO_FT,
                                flow: qBranch,
                                loss: edge.loss,
                                pressure: 0,
                                velocity: edge.velocity,
                                flowDir: edge.flowDir || 'N/A',
                                nodes: edge.flowDir === 'u->v'
                                    ? `#${edge.u_disp}-#${edge.v_disp}`
                                    : `#${edge.v_disp}-#${edge.u_disp}`,
                                isSourcePipe: (edge.u === sourceId || edge.v === sourceId),
                                headFlow: nodeHeadFlow[vId] || 0,
                                fittings: edge.fittings.join(", "),
                                eqLen: edge.fittingLen / M_TO_FT
                            };
                        });

                        nodeReqP[uId] = maxP_RequiredAtU;
                        nodeTotalQ[uId] = totalQ_AtU;
                    }

                    // Pass 2
                    nodeActualP[sourceId] = nodeReqP[sourceId];
                    const forwardQueue = [sourceId];
                    const forwardVisited = new Set([sourceId]);

                    while (forwardQueue.length > 0) {
                        const uId = forwardQueue.shift();
                        const currentP = nodeActualP[uId];
                        const uNode = nodes[uId];
                        const childConnections = uNode.connections.filter(conn => parentMap[conn.target]?.parentId === uId);

                        childConnections.forEach(child => {
                            const vId = child.target;
                            const edge = child.edge;
                            if (tempReport[edge.id]) {
                                tempReport[edge.id].pressure = currentP;
                            }
                            const nextP = currentP - edge.loss;
                            nodeActualP[vId] = nextP;
                            if (!forwardVisited.has(vId)) {
                                forwardVisited.add(vId);
                                forwardQueue.push(vId);
                            }
                        });
                    }

                    const finalResults = Object.values(tempReport).reverse();
                    setResults(finalResults);

                    const finalTotalFlow = nodeTotalQ[sourceId] || 0;
                    const finalPressure = nodeReqP[sourceId] || 0;

                    setTotalDemand({ flow: finalTotalFlow, pressure: finalPressure });

                } catch (err) {
                    console.error("Calculation Error:", err);
                    alert("เกิดข้อผิดพลาดในการคำนวณ กรุณาตรวจสอบการวาดท่ออีกครั้ง");
                }
            };

            const lineIntersectsRect = (x1, y1, x2, y2, rx, ry, rw, rh) => {
                const left = rx, right = rx + rw, top = ry, bottom = ry + rh;
                const minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
                if (maxX < left || minX > right || maxY < top || minY > bottom) return false;

                const intersect = (p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) => {
                    const det = (p2x - p1x) * (p4y - p3y) - (p4x - p3x) * (p2y - p1y);
                    if (det === 0) return false;
                    const lambda = ((p4y - p3y) * (p4x - p1x) + (p3x - p4x) * (p4y - p1y)) / det;
                    const gamma = ((p1y - p2y) * (p4x - p1x) + (p2x - p1x) * (p4y - p1y)) / det;
                    return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
                };

                if (intersect(x1, y1, x2, y2, left, top, right, top)) return true;
                if (intersect(x1, y1, x2, y2, right, top, right, bottom)) return true;
                if (intersect(x1, y1, x2, y2, right, bottom, left, bottom)) return true;
                if (intersect(x1, y1, x2, y2, left, bottom, left, top)) return true;

                if (x1 > left && x1 < right && y1 > top && y1 < bottom) return true;
                return false;
            };

            const getTagLayout = () => {
                if (!results || results.length === 0) return [];
                const layout = [];
                const occupiedRects = [];
                const tagW = 70 / transform.scale;
                const tagH = 52 / transform.scale;
                const padding = 15 / transform.scale;
                const pipeBuffer = 15 / transform.scale;

                const obstacles = [];

                visualNodes.forEach(n => {
                    obstacles.push({
                        x: n.x - 15 / transform.scale,
                        y: n.y - 15 / transform.scale,
                        w: 30 / transform.scale,
                        h: 30 / transform.scale
                    });
                    obstacles.push({
                        x: n.x,
                        y: n.y - 25 / transform.scale,
                        w: 60 / transform.scale,
                        h: 25 / transform.scale
                    });
                });

                placedSprinklers.forEach(s => {
                    obstacles.push({
                        x: s.x - 20 / transform.scale,
                        y: s.y - 20 / transform.scale,
                        w: 40 / transform.scale,
                        h: 40 / transform.scale
                    });
                });

                const checkLineCrossesPipes = (p1, p2, excludePipeId) => {
                    for (const pipe of drawnPipes) {
                        if (pipe.id === excludePipeId) continue;

                        const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
                        const x3 = pipe.start.x, y3 = pipe.start.y, x4 = pipe.end.x, y4 = pipe.end.y;

                        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
                        if (denom === 0) continue;

                        const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
                        const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

                        if (ua > 0.05 && ua < 0.95 && ub > 0.05 && ub < 0.95) {
                            return true;
                        }
                    }
                    return false;
                };

                const checkCollision = (rect, ignorePipes = false) => {
                    for (const r of occupiedRects) {
                        if (rect.x < r.x + r.w + padding && rect.x + rect.w + padding > r.x &&
                            rect.y < r.y + r.h + padding && rect.y + r.h + padding > r.y) {
                            return true;
                        }
                    }
                    for (const r of obstacles) {
                        if (rect.x < r.x + r.w && rect.x + rect.w > r.x &&
                            rect.y < r.y + r.h && rect.y + r.h > r.y) {
                            return true;
                        }
                    }

                    if (!ignorePipes) {
                        const checkRect = {
                            x: rect.x - pipeBuffer,
                            y: rect.y - pipeBuffer,
                            w: rect.w + pipeBuffer * 2,
                            h: rect.h + pipeBuffer * 2
                        };
                        for (const p of drawnPipes) {
                            if (lineIntersectsRect(p.start.x, p.start.y, p.end.x, p.end.y, checkRect.x, checkRect.y, checkRect.w, checkRect.h)) {
                                return true;
                            }
                        }
                    }
                    return false;
                };

                drawnPipes.forEach(pipe => {
                    const res = results.find(r => r.pipeId === pipe.id);
                    if (!res) return;

                    let startX = pipe.start.x, startY = pipe.start.y;
                    let endX = pipe.end.x, endY = pipe.end.y;
                    let midX = (startX + endX) / 2;
                    let midY = (startY + endY) / 2;

                    let arrowAngle = 0;
                    if (res.flowDir === 'v->u') {
                        arrowAngle = Math.atan2(pipe.start.y - pipe.end.y, pipe.start.x - pipe.end.x);
                    } else {
                        arrowAngle = Math.atan2(pipe.end.y - pipe.start.y, pipe.end.x - pipe.start.x);
                    }

                    const dx = endX - startX;
                    const dy = endY - startY;

                    const len = Math.sqrt(dx * dx + dy * dy);
                    const ux = dx / len;
                    const uy = dy / len;
                    const nx = -uy;
                    const ny = ux;

                    const baseDist = 55 / transform.scale;
                    const posSteps = [0.5, 0.4, 0.6, 0.3, 0.7, 0.25, 0.75, 0.2, 0.8, 0.1, 0.9];
                    const distSteps = [1.0, 1.5, 2.0, 2.6, 3.4, 4.5, 6.0];

                    const isHorzPipe = Math.abs(Math.cos(arrowAngle)) > 0.707;

                    let bestCandidate = null;

                    outerLoop1:
                    for (let distMult of distSteps) {
                        const dist = baseDist * distMult;
                        for (let t of posSteps) {
                            const ax = startX + dx * t;
                            const ay = startY + dy * t;

                            for (let side of [1, -1]) {
                                const cx = ax + (nx * dist * side);
                                const cy = ay + (ny * dist * side);

                                const rect = {
                                    x: cx - tagW / 2,
                                    y: cy - tagH / 2,
                                    w: tagW,
                                    h: tagH
                                };

                                if (!checkCollision(rect)) {
                                    let elbowX, elbowY;
                                    if (isHorzPipe) { elbowX = ax; elbowY = cy; }
                                    else { elbowX = cx; elbowY = ay; }

                                    const seg1OK = !checkLineCrossesPipes({ x: ax, y: ay }, { x: elbowX, y: elbowY }, pipe.id);
                                    const seg2OK = !checkLineCrossesPipes({ x: elbowX, y: elbowY }, { x: cx, y: cy }, pipe.id);

                                    if (seg1OK && seg2OK) {
                                        bestCandidate = {
                                            id: pipe.id,
                                            tagX: cx, tagY: cy,
                                            anchorX: ax, anchorY: ay,
                                            midX: midX, midY: midY,
                                            res, angle: arrowAngle, rect
                                        };
                                        break outerLoop1;
                                    }
                                }
                            }
                        }
                    }

                    if (!bestCandidate) {
                        outerLoop2:
                        for (let distMult of distSteps) {
                            const dist = baseDist * distMult;
                            for (let t of posSteps) {
                                const ax = startX + dx * t;
                                const ay = startY + dy * t;
                                for (let side of [1, -1]) {
                                    const cx = ax + (nx * dist * side);
                                    const cy = ay + (ny * dist * side);
                                    const rect = { x: cx - tagW / 2, y: cy - tagH / 2, w: tagW, h: tagH };

                                    if (!checkCollision(rect)) {
                                        bestCandidate = {
                                            id: pipe.id,
                                            tagX: cx, tagY: cy,
                                            anchorX: ax, anchorY: ay,
                                            midX: midX, midY: midY,
                                            res, angle: arrowAngle, rect
                                        };
                                        break outerLoop2;
                                    }
                                }
                            }
                        }
                    }

                    if (!bestCandidate) {
                        let r = baseDist * 4.0;
                        const maxR = baseDist * 15.0;
                        const da = Math.PI / 8;

                        spiralLoop:
                        while (r < maxR) {
                            for (let a = 0; a < Math.PI * 2; a += da) {
                                const cx = midX + Math.cos(a) * r;
                                const cy = midY + Math.sin(a) * r;
                                const rect = { x: cx - tagW / 2, y: cy - tagH / 2, w: tagW, h: tagH };

                                if (!checkCollision(rect, true)) {
                                    const proj = projectPointToSegment({ x: cx, y: cy }, pipe.start, pipe.end);
                                    bestCandidate = {
                                        id: pipe.id,
                                        tagX: cx, tagY: cy,
                                        anchorX: proj.x, anchorY: proj.y,
                                        midX: midX, midY: midY,
                                        res, angle: arrowAngle, rect
                                    };
                                    break spiralLoop;
                                }
                            }
                            r += (tagH * 0.8);
                        }
                    }

                    if (!bestCandidate) {
                        const dist = baseDist * 8.0;
                        const ax = startX + dx * 0.5;
                        const ay = startY + dy * 0.5;
                        const cx = ax + (nx * dist);
                        const cy = ay + (ny * dist);
                        bestCandidate = {
                            id: pipe.id,
                            tagX: cx, tagY: cy,
                            anchorX: ax, anchorY: ay,
                            midX: midX, midY: midY,
                            res, angle: arrowAngle,
                            rect: { x: cx - tagW / 2, y: cy - tagH / 2, w: tagW, h: tagH }
                        };
                    }

                    layout.push(bestCandidate);
                    occupiedRects.push(bestCandidate.rect);
                });

                return layout;
            };

            const tagLayout = getTagLayout();

            // Login Overlay
            if (!accessLevel) {
                return (
                    <div style={{
                        position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh',
                        backgroundColor: 'white', zIndex: 2147483647,
                        display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
                        color: '#64748b', fontFamily: 'monospace', gap: '20px'
                    }}>
                        <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#1e293b' }}>HYDRAULIC CALCULATOR</div>
                        <div style={{ fontSize: '12px', color: '#64748b' }}>V.1.3 By วัยรุ่นเซินเจิ้น</div>

                        <div style={{ display: 'flex', flexDirection: 'column', gap: '15px', alignItems: 'center', marginTop: '20px', padding: '20px', border: '1px solid #e2e8f0', borderRadius: '8px' }}>
                            <div style={{ display: 'flex', gap: '10px' }}>
                                <input
                                    type="password"
                                    placeholder="Access Code"
                                    value={unlockCode}
                                    onChange={(e) => setUnlockCode(e.target.value)}
                                    style={{ border: '1px solid #cbd5e1', padding: '5px 10px', borderRadius: '4px', fontSize: '14px' }}
                                />
                                <button
                                    onClick={handleUnlock}
                                    style={{ backgroundColor: '#4f46e5', color: 'white', border: 'none', padding: '5px 15px', borderRadius: '4px', cursor: 'pointer', fontSize: '14px' }}
                                >
                                    Login
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex h-screen w-full bg-slate-50 overflow-hidden font-sans select-none print:bg-white print:overflow-visible">
                    <div className="w-80 bg-white border-r border-slate-200 flex flex-col shadow-xl z-20 shrink-0 print:hidden">
                        <div className="px-4 py-3 bg-indigo-900 text-white flex justify-between items-center shrink-0">
                            <div className="flex flex-col">
                                <h1 className="font-bold text-sm flex items-center gap-2">
                                    <Flame size={18} className="text-orange-400" />
                                    Hydraulic Calc
                                </h1>
                                <span className="text-[10px] text-indigo-200 ml-6">V.1.3 By วัยรุ่นเซินเจิ้น</span>
                            </div>

                            {/* Header Buttons Group */}
                            <div className="flex items-center gap-1">
                                <button onClick={() => loadProject()} className="p-1.5 bg-indigo-800 hover:bg-indigo-700 text-white rounded transition-colors" title="Open Project">
                                    <FolderOpen size={14} />
                                </button>

                                {accessLevel === 'full' && (
                                    <>
                                        <button onClick={() => saveProject(false)} className="p-1.5 bg-indigo-800 hover:bg-indigo-700 text-white rounded transition-colors" title="Save">
                                            <Save size={14} />
                                        </button>
                                        <button onClick={() => saveProject(true)} className="p-1.5 bg-indigo-800 hover:bg-indigo-700 text-white rounded transition-colors" title="Save As">
                                            <FilePlus size={14} />
                                        </button>
                                    </>
                                )}

                                {/* Hidden Inputs */}
                                <input type="file" ref={projectInputRef} className="hidden" onChange={handleProjectFileUpload} accept=".json,application/json" />
                            </div>
                        </div>

                        <div className="flex-1 flex flex-col p-2 overflow-y-auto gap-2 custom-scrollbar">
                            <div className="border-b border-slate-200 pb-2">
                                <h3 className="font-bold text-slate-800 text-[9px] flex items-center gap-1 mb-1 uppercase tracking-wider">
                                    <Target size={11} className="text-indigo-600" /> Parameters
                                </h3>
                                <div className="grid grid-cols-2 gap-x-2 gap-y-1 text-[9px]">
                                    <div className="col-span-2">
                                        <select value={selectedHazard} onChange={handleHazardChange} className="w-full p-1 border border-slate-200 rounded bg-slate-50 text-slate-700 text-[9px] outline-none">
                                            {hazardClasses.map(h => <option key={h.id} value={h.id}>{h.label}</option>)}
                                        </select>
                                    </div>
                                    <div className="flex flex-col gap-0">
                                        <label className="text-slate-500 font-bold uppercase text-[7px] tracking-tight">Density (gpm/ft²)</label>
                                        <input type="number" value={designDensity} onChange={e => setDesignDensity(e.target.value)} className="w-full p-1 border border-slate-200 rounded bg-white text-[9px] outline-none" step="0.05" />
                                    </div>
                                    <div className="flex flex-col gap-0">
                                        <label className="text-slate-500 font-bold uppercase text-[7px] tracking-tight">Max Area (ft²)</label>
                                        <input type="number" value={areaPerHead} onChange={e => setAreaPerHead(e.target.value)} className="w-full p-1 border border-slate-200 rounded bg-white text-[9px] outline-none" />
                                    </div>
                                    <div className="flex flex-col gap-0 border-r border-slate-100 pr-2">
                                        <label className="text-slate-500 font-bold uppercase text-[7px] tracking-tight">K-Factor</label>
                                        <select
                                            value={kFactor}
                                            onChange={e => setKFactor(Number(e.target.value))}
                                            className="w-full p-1 border border-slate-200 rounded bg-white text-[9px] outline-none"
                                        >
                                            {kFactors.map(k => (
                                                <option key={k} value={k}>{k.toFixed(1)}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div className="flex flex-col gap-0">
                                        <label className="text-slate-500 font-bold uppercase text-[7px] tracking-tight">C-Value</label>
                                        <select
                                            value={cFactor}
                                            onChange={e => setCFactor(Number(e.target.value))}
                                            className="w-full p-1 border border-slate-200 rounded bg-white text-[9px] outline-none"
                                        >
                                            {cFactors.map((c, i) => (
                                                <option key={i} value={c.value}>
                                                    {c.label}
                                                </option>
                                            ))}
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <div className="border-b border-slate-200 pb-2">
                                <h3 className="font-bold text-slate-800 text-[9px] flex items-center gap-1 mb-1 uppercase tracking-wider">
                                    <Ruler size={11} className="text-indigo-600" /> Pipe Size
                                </h3>
                                <div className="grid grid-cols-3 gap-1">
                                    {pipeSpecs.map(spec => (
                                        <button
                                            key={spec.nominal}
                                            onClick={() => setSelectedPipeSize(spec.nominal)}
                                            className={`text-[9px] py-1 border rounded transition-all font-bold flex items-center justify-center gap-1 bg-white ${selectedPipeSize === spec.nominal ? 'border-indigo-600 bg-indigo-50/50' : 'border-slate-100'}`}
                                            style={{ color: spec.color }}
                                        >
                                            <span
                                                className="w-2 h-2 rounded-full"
                                                style={{ backgroundColor: spec.color }}
                                            />
                                            {spec.nominal}"
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <div className="flex flex-col gap-2">
                                {/* View Section */}
                                <div className="border-b border-slate-200 pb-2">
                                    <h3 className="font-bold text-slate-800 text-[9px] flex items-center gap-1 mb-1 uppercase tracking-wider">
                                        <Eye size={11} className="text-indigo-600" /> View
                                    </h3>
                                    <div className="grid grid-cols-2 gap-1.5">
                                        <label className="flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border border-slate-200 bg-white hover:bg-slate-50 cursor-pointer shadow-sm active:scale-95 transition-all text-[9px]">
                                            <input type="file" className="hidden" onChange={handleFileChange} accept="image/*" />
                                            <ImageIcon size={11} className="text-slate-500" /> Floor Plan
                                        </label>
                                        <button onClick={() => setMode('scale')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'scale' ? 'bg-indigo-600 border-indigo-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <Ruler size={11} className={mode === 'scale' ? 'text-white' : 'text-slate-500'} /> Scale
                                        </button>
                                        <button onClick={() => setMode('pan')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'pan' ? 'bg-slate-800 border-slate-800 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <Maximize size={11} className={mode === 'pan' ? 'text-white' : 'text-slate-500'} /> Pan
                                        </button>
                                        <button onClick={() => setShowTags(!showTags)} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${!showTags ? 'bg-slate-200 border-slate-200 text-slate-500' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            {showTags ? <Eye size={11} className="text-slate-500" /> : <EyeOff size={11} className="text-slate-400" />} Tags
                                        </button>
                                    </div>
                                </div>



                                {/* Draw Section */}
                                <div className="border-b border-slate-200 pb-2">
                                    <h3 className="font-bold text-slate-800 text-[9px] flex items-center gap-1 mb-1 uppercase tracking-wider">
                                        <Edit3 size={11} className="text-indigo-600" /> Draw
                                    </h3>
                                    <div className="grid grid-cols-2 gap-1.5">
                                        <button onClick={() => setMode('sprinkler')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'sprinkler' ? 'bg-emerald-600 border-emerald-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <Droplets size={11} className={mode === 'sprinkler' ? 'text-white' : 'text-emerald-600'} /> Head
                                        </button>
                                        <button onClick={() => setMode('draw')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'draw' ? 'bg-blue-600 border-blue-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <Plus size={11} className={mode === 'draw' ? 'text-white' : 'text-blue-600'} /> Pipe
                                        </button>
                                        <button onClick={() => setMode('auto_sprinkler')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'auto_sprinkler' ? 'bg-violet-600 border-violet-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <LayoutGrid size={11} className={mode === 'auto_sprinkler' ? 'text-white' : 'text-violet-600'} /> Auto Grid
                                        </button>
                                        <button onClick={() => setMode('delete')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'delete' ? 'bg-red-600 border-red-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <Trash2 size={11} className={mode === 'delete' ? 'text-white' : 'text-red-500'} /> Delete
                                        </button>
                                    </div>
                                    {mode === 'auto_sprinkler' && (
                                        <div className="flex bg-indigo-50 px-1 py-1 rounded border border-indigo-100 gap-1.5 mt-1 text-[8px] text-indigo-700 justify-center items-center">
                                            <Info size={10} />
                                            <span className="font-medium tracking-tight">Drag area on drawing</span>
                                        </div>
                                    )}
                                </div>



                                {/* Actions Section */}
                                <div className="pb-1 border-t border-slate-100 pt-2">
                                    <div className="grid grid-cols-2 gap-1.5 mb-2">
                                        <button onClick={handleUndo} disabled={historyIndex <= 0} className="flex items-center justify-center gap-1 px-1 py-1 rounded border border-slate-200 bg-white text-slate-600 shadow-sm disabled:opacity-40 text-[9px] hover:bg-slate-50 transition-all active:scale-95" title="Undo">
                                            <RotateCcw size={10} /> Undo
                                        </button>
                                        <button onClick={handleRedo} disabled={historyIndex >= history.length - 1} className="flex items-center justify-center gap-1 px-1 py-1 rounded border border-slate-200 bg-white text-slate-600 shadow-sm disabled:opacity-40 text-[9px] hover:bg-slate-50 transition-all active:scale-95" title="Redo">
                                            <RotateCw size={10} /> Redo
                                        </button>
                                    </div>

                                    {/* Hydraulic Results - Moved Below Undo */}
                                    {totalDemand.flow > 0 && (
                                        <div className="bg-gradient-to-br from-indigo-50 to-slate-50 p-1.5 mb-2 rounded border border-indigo-100 shadow-sm space-y-1">
                                            <div className="flex justify-between items-center px-1">
                                                <span className="text-[8px] font-bold text-slate-400 uppercase tracking-widest">Total Flow</span>
                                                <div className="text-right flex items-baseline gap-1">
                                                    <span className="text-sm font-black text-indigo-700">{safeFixed(totalDemand.flow)}</span>
                                                    <span className="text-[7px] text-indigo-400 font-bold uppercase">GPM</span>
                                                </div>
                                            </div>
                                            <div className="h-px bg-slate-200/60 mx-1"></div>
                                            <div className="flex justify-between items-center px-1">
                                                <span className="text-[8px] font-bold text-slate-400 uppercase tracking-widest">Max Pressure</span>
                                                <div className="text-right flex items-baseline gap-1">
                                                    <span className="text-sm font-black text-rose-600">{safeFixed(totalDemand.pressure)}</span>
                                                    <span className="text-[7px] text-rose-400 font-bold uppercase">PSI</span>
                                                </div>
                                            </div>
                                        </div>
                                    )}


                                </div>
                            </div>
                        </div>




                    </div>






                    {/* Main Canvas Area */}
                    <div
                        className={`flex-1 relative bg-white overflow-hidden canvas-grid print:hidden ${mode === 'pan'
                            ? 'cursor-move'
                            : 'cursor-crosshair'
                            }`}
                        ref={containerRef}
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onClick={handleCanvasClick}
                        onDoubleClick={handleCanvasDoubleClick}
                        onWheel={(e) => adjustZoom(e.deltaY > 0 ? -1 : 1)}
                    >
                        <div
                            className="absolute top-4 left-4 z-10 flex items-center gap-2"
                            onMouseDown={e => e.stopPropagation()}
                            onMouseUp={e => e.stopPropagation()}
                            onClick={e => e.stopPropagation()}
                            onDoubleClick={e => e.stopPropagation()}
                        >
                            <div className="bg-white/95 backdrop-blur-sm px-3 py-1.5 rounded-full border border-slate-200 shadow-sm text-[10px] text-slate-600 flex items-center gap-2">
                                <span className="flex items-center gap-1"><Info size={12} /> Mode: <span className="font-bold uppercase text-slate-900">{mode}</span></span>
                                <span className="w-px h-3 bg-slate-200"></span>
                                <span className="font-medium">Scale: {pixelsPerMeter ? `${pixelsPerMeter.toFixed(2)} px/m` : 'Not Set'}</span>
                            </div>

                            <button
                                onClick={handleCalculate}
                                className="h-7 px-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-full text-[10px] flex items-center gap-2 font-bold transition-all active:scale-95 uppercase tracking-wider"
                            >
                                <Calculator size={13} /> CALCULATE
                            </button>

                            <button
                                onClick={() => setShowReport(true)}
                                className="h-7 w-8 bg-emerald-600 hover:bg-emerald-700 text-white rounded-full flex items-center justify-center transition-all active:scale-95"
                                title="View Report"
                            >
                                <FileText size={14} />
                            </button>
                        </div>

                        {/* Zoom Controls */}
                        <div className="absolute bottom-6 right-6 z-10 flex flex-col gap-2">
                            <button onClick={() => adjustZoom(1)} className="p-2 bg-white rounded-full shadow-lg hover:bg-slate-50 text-slate-700 transition-transform active:scale-90"><ZoomIn size={16} /></button>
                            <button onClick={() => adjustZoom(-1)} className="p-2 bg-white rounded-full shadow-lg hover:bg-slate-50 text-slate-700 transition-transform active:scale-90"><ZoomOut size={16} /></button>
                        </div>

                        {/* Transform Container */}
                        <div
                            style={{
                                transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`,
                                transformOrigin: '0 0',
                                width: '100%', height: '100%',
                                pointerEvents: 'none'
                            }}
                        >
                            {/* Background Image */}
                            {pdfUrl && <img src={pdfUrl} className="absolute top-0 left-0 opacity-80" style={{ maxWidth: 'none', pointerEvents: 'none' }} />}

                            <svg className="absolute top-0 left-0 overflow-visible" style={{ width: '1px', height: '1px' }}>
                                {/* Pipe Alignment Guide (Orange Dashed Line on Pipe) */}
                                {pipeAlignmentGuide && (
                                    <g>
                                        <line
                                            x1={pipeAlignmentGuide.p1.x} y1={pipeAlignmentGuide.p1.y}
                                            x2={pipeAlignmentGuide.p2.x} y2={pipeAlignmentGuide.p2.y}
                                            stroke="#f97316" // Orange 500
                                            strokeWidth={1.5 / transform.scale}
                                            strokeDasharray={`${6 / transform.scale},${3 / transform.scale}`}
                                            opacity={0.8}
                                        />
                                        {/* Midpoint Triangle Indicator REMOVED as requested */}
                                    </g>
                                )}

                                {/* Alignment Guides (Red Crosshair) - Changed from Pink to Red */}
                                {alignmentLines.map((line, i) => (
                                    <line
                                        key={i}
                                        x1={line.x1} y1={line.y1}
                                        x2={line.x2} y2={line.y2}
                                        stroke="#ef4444"
                                        strokeWidth={1 / transform.scale}
                                        strokeDasharray={`${4 / transform.scale},${4 / transform.scale}`}
                                        opacity={0.8}
                                    />
                                ))}

                                {/* Sprinkler Distance Guide (Green Dashed) */}
                                {sprinklerDistanceGuide && (
                                    <g>
                                        <line
                                            x1={sprinklerDistanceGuide.start.x} y1={sprinklerDistanceGuide.start.y}
                                            x2={sprinklerDistanceGuide.end.x} y2={sprinklerDistanceGuide.end.y}
                                            stroke="#10b981"
                                            strokeWidth={1 / transform.scale}
                                            strokeDasharray={`${4 / transform.scale},${2 / transform.scale}`}
                                            opacity={0.8}
                                        />
                                        <text
                                            x={(sprinklerDistanceGuide.start.x + sprinklerDistanceGuide.end.x) / 2}
                                            y={(sprinklerDistanceGuide.start.y + sprinklerDistanceGuide.end.y) / 2 - 10 / transform.scale}
                                            textAnchor="middle"
                                            fontSize={10 / transform.scale}
                                            fill="#10b981"
                                            fontWeight="bold"
                                            style={{
                                                textShadow: '0px 0px 4px rgba(255,255,255,0.8)',
                                                pointerEvents: 'none'
                                            }}
                                        >
                                            {sprinklerDistanceGuide.text}
                                        </text>
                                    </g>
                                )}

                                {tempRect && (() => {
                                    const x = Math.min(tempRect.start.x, tempRect.end.x);
                                    const y = Math.min(tempRect.start.y, tempRect.end.y);
                                    const w = Math.abs(tempRect.end.x - tempRect.start.x);
                                    const h = Math.abs(tempRect.end.y - tempRect.start.y);

                                    // Calculate Area
                                    const areaText = pixelsPerMeter
                                        ? `${((w / pixelsPerMeter) * (h / pixelsPerMeter)).toFixed(2)} m²`
                                        : `${Math.round(w * h)} px²`;

                                    return (
                                        <g>
                                            <rect
                                                x={x}
                                                y={y}
                                                width={w}
                                                height={h}
                                                fill="rgba(139, 92, 246, 0.1)"
                                                stroke="#8b5cf6"
                                                strokeWidth={2 / transform.scale}
                                                strokeDasharray="5,5"
                                            />
                                            <text
                                                x={x + w / 2}
                                                y={y + h / 2}
                                                textAnchor="middle"
                                                dominantBaseline="central"
                                                fontSize={14 / transform.scale}
                                                fill="#6d28d9"
                                                fontWeight="bold"
                                                style={{
                                                    textShadow: '0px 0px 4px rgba(255,255,255,1), 0px 0px 2px rgba(255,255,255,1)',
                                                    pointerEvents: 'none',
                                                    userSelect: 'none'
                                                }}
                                            >
                                                {areaText}
                                            </text>
                                        </g>
                                    );
                                })()}

                                {/* Lasso Removed */}

                                {/* Drawn Pipes - Reverted to Single Line */}
                                {drawnPipes.map(pipe => {
                                    const spec = pipeSpecs.find(s => s.nominal === pipe.size) || pipeSpecs[0];
                                    return (
                                        <g key={pipe.id}>
                                            <line
                                                x1={pipe.start.x} y1={pipe.start.y}
                                                x2={pipe.end.x} y2={pipe.end.y}
                                                stroke={spec.color}
                                                strokeWidth={3 / transform.scale}
                                                strokeLinecap="round"
                                            />
                                        </g>
                                    );
                                })}

                                {/* Nodes (Joints) with IDs - Modified style */}
                                {/* Removed 'showTags &&' condition here so nodes remain visible */}
                                {visualNodes.map(node => {
                                    const isSource = node.id === sourceNodeId;
                                    return (
                                        <g key={node.id} transform={`translate(${node.x}, ${node.y})`}>
                                            {/* Connection Dot - Highlight Source with Red/Larger dot */}
                                            {/* Adjusted radius to match single line pipe width (approx 3px) */}
                                            <circle
                                                r={(isSource ? 3.5 : 1.8) / transform.scale}
                                                fill="#ffffff" // White fill
                                                stroke={isSource ? "#ef4444" : "#94a3b8"} // Colored stroke
                                                strokeWidth={1.2 / transform.scale}
                                            />
                                            {/* Label Offset from center - Show #S if it matches sourceNodeId */}
                                            <text
                                                x={(isSource ? 5 : 3) / transform.scale}
                                                y={(isSource ? -5 : -3) / transform.scale}
                                                fontSize={(isSource ? 11 : 9) / transform.scale}
                                                fill={isSource ? "#ef4444" : "#64748b"}
                                                fontWeight="bold"
                                                style={{
                                                    textShadow: '1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff',
                                                    pointerEvents: 'none'
                                                }}
                                            >
                                                {isSource ? `#${node.displayId} (S)` : `#${node.displayId}`}
                                            </text>
                                        </g>
                                    );
                                })}

                                {/* Sprinklers */}
                                {placedSprinklers.map(s => (
                                    <g key={s.id} transform={`translate(${s.x}, ${s.y})`}>
                                        <circle r={6 / transform.scale} fill="#10b981" fillOpacity="0.2" stroke="#059669" strokeWidth={1 / transform.scale} />
                                        <circle r={2 / transform.scale} fill="#059669" />
                                    </g>
                                ))}

                                {/* Results Tags and Arrows - Decoupled in JSX */}
                                {tagLayout.map(tag => {
                                    // Prepare classes outside JSX to avoid parser issues
                                    const containerClass = `border shadow-sm flex flex-col items-center text-center leading-none overflow-hidden rounded-[2px] ${tag.res.isSourcePipe ? 'bg-red-50 border-red-600 border-[1.5px]' : 'bg-white border-slate-900'
                                        }`;
                                    const headerClass = `w-full border-b ${tag.res.isSourcePipe ? 'bg-red-100 border-red-300' : 'bg-slate-100 border-slate-300'
                                        }`;
                                    const headerTextClass = `text-[0.85em] font-bold uppercase py-[1px] ${tag.res.isSourcePipe ? 'text-red-900' : 'text-slate-900'
                                        }`;

                                    return (
                                        <React.Fragment key={tag.id}>
                                            {/* Tag Group - Show ONLY if showTags is true */}
                                            {showTags && (
                                                <g transform={`translate(${tag.tagX}, ${tag.tagY})`}>
                                                    {/* Orthogonal Leader Line */}
                                                    {(() => {
                                                        const ax = tag.anchorX - tag.tagX;
                                                        const ay = tag.anchorY - tag.tagY;
                                                        const isHorzPipe = Math.abs(Math.cos(tag.angle)) > 0.707;
                                                        let d = "";
                                                        if (isHorzPipe) {
                                                            d = `M ${ax} ${ay} L ${ax} 0 L 0 0`;
                                                        } else {
                                                            d = `M ${ax} ${ay} L 0 ${ay} L 0 0`;
                                                        }
                                                        return (
                                                            <path
                                                                d={d}
                                                                stroke="#334155"
                                                                strokeWidth={1 / transform.scale}
                                                                strokeDasharray="3,3"
                                                                fill="none"
                                                            />
                                                        );
                                                    })()}

                                                    <foreignObject
                                                        x={-35 / transform.scale}
                                                        y={-26 / transform.scale}
                                                        width={70 / transform.scale}
                                                        height={52 / transform.scale}
                                                    >
                                                        <div xmlns="http://www.w3.org/1999/xhtml"
                                                            className={containerClass}
                                                            style={{ fontSize: `${9 / transform.scale}px`, height: '100%', width: '100%' }}>

                                                            {/* Node Info Line (Header) */}
                                                            <div className={headerClass}>
                                                                <div className={headerTextClass}>
                                                                    Node {tag.res.nodes}
                                                                </div>
                                                            </div>

                                                            {/* Data Lines */}
                                                            <div className="flex flex-col justify-center flex-1 w-full px-0.5 space-y-[1px]">
                                                                {/* Pipe Info */}
                                                                <div className="text-[0.75em] text-slate-500 font-semibold border-b border-slate-100 pb-[1px]">
                                                                    {tag.res.size}" - {safeFixed(tag.res.lengthM, 1)}m
                                                                </div>

                                                                {/* Flow (Blue) */}
                                                                <div className="flex justify-between items-baseline px-1">
                                                                    <span className="text-[0.7em] text-slate-400 font-normal">Q:</span>
                                                                    <span className="text-[0.9em] text-blue-800 font-bold">{safeFixed(tag.res.flow, 2)}</span>
                                                                </div>

                                                                {/* Pressure (Red) */}
                                                                <div className="flex justify-between items-baseline px-1">
                                                                    <span className="text-[0.7em] text-slate-400 font-normal">P:</span>
                                                                    <span className="text-[0.9em] text-red-700 font-bold">{safeFixed(tag.res.pressure, 2)}</span>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </foreignObject>
                                                </g>
                                            )}

                                            {/* Flow Arrow - Always visible regardless of showTags */}
                                            <g transform={`translate(${tag.midX}, ${tag.midY}) rotate(${tag.angle * 180 / Math.PI})`}>
                                                {/* Flow Arrow fixed to Black color with white shadow for visibility */}
                                                <path
                                                    /* Modified arrow path to be wider */
                                                    d={`M ${-4 / transform.scale} ${-6 / transform.scale} L ${4 / transform.scale} 0 L ${-4 / transform.scale} ${6 / transform.scale}`}
                                                    stroke="#000000"
                                                    strokeWidth={1 / transform.scale}
                                                    fill="none"
                                                    strokeLinecap="round"
                                                    strokeLinejoin="round"
                                                    // Removed strokeDasharray to make it solid
                                                    style={{ filter: 'drop-shadow(0px 0px 1px rgba(255,255,255,1))' }}
                                                />
                                            </g>
                                        </React.Fragment>
                                    );
                                })}

                                {/* Temp Pipe (Ghost) */}
                                {tempPipe && (() => {
                                    const dx = tempPipe.end.x - tempPipe.start.x;
                                    const dy = tempPipe.end.y - tempPipe.start.y;
                                    const lenPx = Math.sqrt(dx * dx + dy * dy);
                                    // Modified here: changed toFixed(2) to toFixed(1)
                                    const lenText = pixelsPerMeter
                                        ? `${(lenPx / pixelsPerMeter).toFixed(1)} m.`
                                        : `${Math.round(lenPx)} px`;

                                    // Standard single line width
                                    const w = 3 / transform.scale;

                                    return (
                                        <g>
                                            <line
                                                x1={tempPipe.start.x} y1={tempPipe.start.y}
                                                x2={tempPipe.end.x} y2={tempPipe.end.y}
                                                stroke={pipeSpecs.find(s => s.nominal === tempPipe.size)?.color || 'black'}
                                                strokeWidth={w}
                                                strokeOpacity="0.5"
                                                strokeDasharray="5,5"
                                            />
                                            {/* Distance Label */}
                                            <text
                                                x={(tempPipe.start.x + tempPipe.end.x) / 2}
                                                y={(tempPipe.start.y + tempPipe.end.y) / 2 - 10 / transform.scale}
                                                textAnchor="middle"
                                                fontSize={12 / transform.scale}
                                                fill="#0f172a"
                                                fontWeight="bold"
                                                style={{
                                                    textShadow: '0px 0px 4px rgba(255,255,255,0.8)',
                                                    pointerEvents: 'none'
                                                }}
                                            >
                                                {lenText}
                                            </text>
                                        </g>
                                    );
                                })()}

                                {/* Snap Marker */}
                                {snapPoint && (
                                    <circle
                                        cx={snapPoint.x} cy={snapPoint.y}
                                        r={5 / transform.scale}
                                        fill="none" stroke="#ef4444" strokeWidth={2 / transform.scale}
                                    />
                                )}

                                {/* Scale Line */}
                                {scalePoints.length === 2 && (
                                    <line
                                        x1={scalePoints[0].x} y1={scalePoints[0].y}
                                        x2={scalePoints[1].x} y2={scalePoints[1].y}
                                        stroke="#f00" strokeWidth={2 / transform.scale}
                                    />
                                )}
                            </svg>
                        </div>
                    </div>

                    {/* Scale Dialog Modal */}
                    {
                        showScaleDialog && (
                            <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center print:hidden">
                                <div className="bg-white p-6 rounded-lg shadow-2xl w-80 animate-in zoom-in-95">
                                    <h3 className="font-bold text-lg mb-4 flex items-center gap-2">
                                        <Ruler className="text-indigo-600" /> Calibrate Scale
                                    </h3>
                                    <div className="mb-4 bg-slate-50 p-2 rounded text-sm text-slate-600">
                                        <div className="flex justify-between">
                                            <span>Measured Length:</span>
                                            <span className="font-mono font-bold">
                                                {(() => {
                                                    const dx = scalePoints[1].x - scalePoints[0].x;
                                                    const dy = scalePoints[1].y - scalePoints[0].y;
                                                    return Math.sqrt(dx * dx + dy * dy).toFixed(2);
                                                })()} px
                                            </span>
                                        </div>
                                    </div>
                                    <p className="text-sm text-slate-500 mb-2">
                                        Enter Real Distance:
                                    </p>
                                    <div className="flex items-center gap-2 mb-4">
                                        <input
                                            type="number"
                                            autoFocus
                                            placeholder="0.00"
                                            className="w-full p-2 border rounded text-lg"
                                            value={realWorldDist}
                                            onChange={e => setRealWorldDist(e.target.value)}
                                            onKeyDown={e => e.key === 'Enter' && applyScale()}
                                            step="0.01"
                                        />
                                        <span className="text-slate-500 font-medium">m</span>
                                    </div>

                                    {realWorldDist && !isNaN(parseFloat(realWorldDist)) && parseFloat(realWorldDist) > 0 && (
                                        <div className="mb-4 text-xs text-center text-emerald-600 font-medium">
                                            Result: {((Math.sqrt(Math.pow(scalePoints[1].x - scalePoints[0].x, 2) + Math.pow(scalePoints[1].y - scalePoints[0].y, 2))) / parseFloat(realWorldDist)).toFixed(4)} px/m
                                        </div>
                                    )}

                                    <div className="flex justify-end gap-2">
                                        <button onClick={() => { setShowScaleDialog(false); setScalePoints([]); }} className="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded">Cancel</button>
                                        <button onClick={applyScale} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded font-medium">Apply</button>
                                    </div>
                                </div>
                            </div>
                        )
                    }

                    {/* Pipe Size Edit Modal */}
                    {
                        editingPipeId && (
                            <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center print:hidden" onClick={() => setEditingPipeId(null)}>
                                <div className="bg-white p-4 rounded-lg shadow-xl w-64 animate-in zoom-in-95" onClick={e => e.stopPropagation()}>
                                    <h3 className="font-bold text-sm mb-3 text-slate-700 flex items-center gap-2">
                                        <Edit3 size={16} /> Select New Pipe Size
                                    </h3>
                                    <div className="grid grid-cols-3 gap-2">
                                        {pipeSpecs.map(spec => (
                                            <button
                                                key={spec.nominal}
                                                onClick={() => updatePipeSize(spec.nominal)}
                                                className="text-xs py-2 rounded border hover:bg-slate-50 transition-colors font-medium"
                                                style={{ borderColor: spec.color, color: spec.color }}
                                            >
                                                {spec.nominal}"
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )
                    }

                    {/* Report Modal */}
                    {
                        showReport && (
                            // Changed: Added print:items-start to align content to top during print, removing vertical centering
                            <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 print:absolute print:inset-0 print:bg-white print:z-[9999] print:block">
                                <div className="bg-white rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col animate-in zoom-in-95 print:shadow-none print:w-full print:max-w-none print:h-auto print:max-h-none print:rounded-none">
                                    <div className="p-4 border-b flex justify-between items-center bg-gray-50 rounded-t-lg print:hidden">
                                        <h3 className="font-bold text-lg text-gray-800 flex items-center gap-2">
                                            <FileText className="text-blue-600" /> Hydraulic Calculations Sheet
                                        </h3>
                                        <button onClick={() => setShowReport(false)} className="p-1 hover:bg-gray-200 rounded-full transition-colors text-gray-500">
                                            <X size={20} />
                                        </button>
                                    </div>
                                    <div className="p-6 overflow-auto print:p-0 print:overflow-visible">
                                        <div className="mb-4 text-center hidden print:block">
                                            <h2 className="text-xl font-bold uppercase">Hydraulic Calculations Sheet</h2>
                                            <p className="text-sm text-gray-500">NFPA 13 Standard</p>
                                            {/* Added Parameter Display */}
                                            <div className="flex justify-center flex-wrap gap-x-6 gap-y-2 text-xs mt-2 font-mono border-t border-b border-gray-200 py-2">
                                                <span><strong>Density:</strong> {designDensity} gpm/ft²</span>
                                                <span><strong>Area/head:</strong> {areaPerHead} ft²</span>
                                                <span><strong>K-Factor:</strong> {kFactor}</span>
                                                <span><strong>Hazard:</strong> {hazardClasses.find(h => h.id === selectedHazard)?.label}</span>
                                            </div>
                                        </div>
                                        <table className="w-full text-sm text-left border-collapse">
                                            <thead className="bg-gray-100 font-bold text-gray-700 border-b-2 border-gray-300">
                                                <tr>
                                                    <th className="p-3 border-r border-gray-200">Node</th>
                                                    <th className="p-3 border-r border-gray-200">Flow (gpm)</th>
                                                    {/* Moved Sprinkler Flow to 3rd Column */}
                                                    <th className="p-3 border-r border-gray-200">Sprinkler Flow (gpm)</th>
                                                    <th className="p-3 border-r border-gray-200">Pipe Size (in)</th>
                                                    <th className="p-3 border-r border-gray-200">Length (m)</th>
                                                    <th className="p-3 border-r border-gray-200">Fittings / Eq. Len</th>
                                                    <th className="p-3 border-r border-gray-200">Friction Loss (psi)</th>
                                                    <th className="p-3 border-r border-gray-200">Required Pressure (psi)</th>
                                                    <th className="p-3">
                                                        Velocity (m/s)
                                                        <span className="block text-[10px] font-normal text-gray-500 text-nowrap">&lt; 9.0 m/s</span>
                                                    </th>
                                                </tr>
                                            </thead>
                                            <tbody className="divide-y divide-gray-100">
                                                {results.length > 0 ? (
                                                    results.map((row, i) => (
                                                        <tr key={i} className="hover:bg-gray-50 transition-colors">
                                                            {/* Node Color Logic: Green if has headFlow, else Blue */}
                                                            <td className={`p-3 font-medium border-r border-gray-200 ${row.headFlow > 0 ? 'text-green-600' : 'text-blue-700'}`}>
                                                                {row.nodes}
                                                            </td>
                                                            <td className="p-3 font-bold text-gray-800 border-r border-gray-200">{safeFixed(row.flow)}</td>
                                                            {/* Sprinkler Flow Moved Here */}
                                                            <td className={`p-3 border-r border-gray-200 ${row.headFlow > 0 ? 'text-green-600 font-bold' : 'text-gray-400'}`}>
                                                                {row.headFlow > 0 ? safeFixed(row.headFlow) : '-'}
                                                            </td>
                                                            <td className="p-3 text-gray-600 border-r border-gray-200">{row.size}"</td>
                                                            <td className="p-3 text-gray-600 border-r border-gray-200">{safeFixed(row.lengthM)}</td>
                                                            <td className="p-3 text-xs text-gray-500 border-r border-gray-200">
                                                                {row.fittings ? (
                                                                    <>
                                                                        <div>{row.fittings}</div>
                                                                        <div className="font-bold">+{safeFixed(row.eqLen, 1)} m</div>
                                                                    </>
                                                                ) : '-'}
                                                            </td>
                                                            <td className="p-3 text-gray-600 border-r border-gray-200">{safeFixed(row.loss)}</td>
                                                            <td className="p-3 font-medium text-red-700 border-r border-gray-200">{safeFixed(row.pressure)}</td>
                                                            <td className={`p-3 ${row.velocity > 9.0 ? "text-red-600 font-bold" : "text-gray-500"}`}>{safeFixed(row.velocity)}</td>
                                                        </tr>
                                                    ))
                                                ) : (
                                                    <tr>
                                                        <td colSpan="9" className="p-8 text-center text-gray-400 italic">
                                                            No calculation data available. Please draw pipes and calculate first.
                                                        </td>
                                                    </tr>
                                                )}
                                            </tbody>
                                            {results.length > 0 && (
                                                <tfoot className="bg-gray-50 font-bold border-t-2 border-gray-300">
                                                    <tr>
                                                        <td className="p-3 border-r border-gray-200">System Total</td>
                                                        <td className="p-3 text-blue-700 border-r border-gray-200">{safeFixed(totalDemand.flow)}</td>
                                                        {/* Spanning the middle columns (SprinklerFlow, Size, Length, Loss) */}
                                                        <td colSpan="5" className="border-r border-gray-200"></td>
                                                        <td className="p-3 text-red-700 border-r border-gray-200">{safeFixed(totalDemand.pressure)} (Max)</td>
                                                        <td></td>
                                                    </tr>
                                                </tfoot>
                                            )}
                                        </table>

                                        <div className="hidden print:block print-page-break"></div>

                                        {/* Equivalent Lengths Table Section - USING CENTRALIZED DATA */}
                                        <div className="mt-8 mb-4 break-inside-avoid print:mt-8">
                                            <h3 className="font-bold text-lg text-gray-800 mb-2 border-b pb-2 print:text-base">
                                                Equivalent Schedule 40 Steel Pipe Length Chart
                                            </h3>
                                            <p className="text-xs text-gray-500 mb-2 italic print:text-[10px]">
                                                *Due to the variations in design of swing check valves, the pipe equivalents indicated in the above chart are considered average.
                                            </p>
                                            <div className="overflow-x-auto print:overflow-visible">
                                                <table className="w-full text-xs text-center border-collapse border border-gray-300 print:text-[9px] print:w-full">
                                                    <thead className="bg-gray-100 font-bold text-gray-700">
                                                        <tr>
                                                            <th className="p-2 border border-gray-300 text-left min-w-[150px] print:p-1 print:min-w-0">Fittings</th>
                                                            <th className="p-2 border border-gray-300 print:p-1">Code</th>
                                                            {nfpaData.displaySizes.map(h => (
                                                                <th key={h} className="p-2 border border-gray-300 print:p-1">{h}"</th>
                                                            ))}
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        {nfpaData.fittings.map((row, i) => (
                                                            <tr key={i} className="hover:bg-gray-50">
                                                                <td className="p-2 border border-gray-300 text-left font-medium print:p-1">{row.name}</td>
                                                                <td className="p-2 border border-gray-300 text-gray-500 print:p-1">{row.code}</td>
                                                                {nfpaData.displaySizes.map((size) => (
                                                                    <td key={size} className="p-2 border border-gray-300 print:p-1">
                                                                        {row.values[size] !== undefined ? row.values[size] : "-"}
                                                                    </td>
                                                                ))}
                                                            </tr>
                                                        ))}
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>
                                    </div>
                                    <div className="p-4 border-t flex justify-end gap-2 bg-gray-50 rounded-b-lg print:hidden">
                                        <button
                                            onClick={() => window.print()}
                                            className="px-4 py-2 bg-white border border-gray-300 text-gray-700 rounded hover:bg-gray-50 font-medium flex items-center gap-2"
                                        >
                                            Print
                                        </button>
                                        <button
                                            onClick={() => setShowReport(false)}
                                            className="px-4 py-2 bg-gray-900 text-white rounded hover:bg-gray-800 font-medium"
                                        >
                                            Close
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )
                    }
                </div >
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>

</body>

</html>
