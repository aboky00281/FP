<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hydraulic Calculation Tools (NFPA 13) V.1.5 By วัยรุ่นเซินเจิ้น</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM & Babel -->
    <!-- FIX: Pinned Babel version to 7.23.6 to prevent "targets.esmodules" error -->
    <script src="https://unpkg.com/@babel/standalone@7.23.6/babel.min.js"></script>

    <!-- Import Map for Modules -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.263.1"
        }
    }
    </script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        ::-webkit-scrollbar {
            width: 4px;
            height: 4px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 2px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Engineering Graph Paper Grid Style */
        .canvas-grid {
            background-color: #ffffff;
        }

        @media print {
            @page {
                margin: 1cm;
                size: auto;
            }

            body {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                background-color: white;
            }

            #root {
                height: auto;
                overflow: visible;
            }

            .no-print {
                display: none !important;
            }

            table {
                width: 100%;
            }

            .print-page-break {
                page-break-before: always;
                break-before: page;
                display: block;
                height: 0;
            }
        }
    </style>
</head>

<body class="bg-gray-100 text-gray-900 overflow-hidden print:bg-white print:overflow-visible">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import {
            Plus, Trash2, Calculator, FileText, Droplets, Upload, Ruler,
            Maximize, Target, ZoomIn, ZoomOut, Edit3, Info, Flame, X,
            RotateCcw, RotateCw, Eye, EyeOff, Save, FolderOpen, Image as ImageIcon, FilePlus, LayoutGrid, ArrowUpDown, Box, Coffee
        } from 'lucide-react';

        // Adjusted Pipe Colors
        const pipeSpecs = [
            { nominal: "1", internal: 1.049, color: "#eab308" },    // Yellow 500
            { nominal: "1.25", internal: 1.380, color: "#fb923c" }, // Orange 400
            { nominal: "1.5", internal: 1.610, color: "#b91c1c" },  // Red 700
            { nominal: "2", internal: 2.067, color: "#ec4899" },    // Pink 500
            { nominal: "2.5", internal: 2.469, color: "#a855f7" },  // Purple 500
            { nominal: "3", internal: 3.068, color: "#3b82f6" },    // Blue 500
            { nominal: "4", internal: 4.026, color: "#06b6d4" },    // Cyan 500
            { nominal: "6", internal: 6.065, color: "#10b981" },    // Emerald 500
            { nominal: "8", internal: 7.981, color: "#475569" },    // Slate 600
        ];

        // Centralized NFPA Data Source
        const nfpaData = {
            displaySizes: ["0.75", "1", "1.25", "1.5", "2", "2.5", "3", "3.5", "4", "5", "6", "8", "10", "12"],
            calcSizes: ["0.5", "0.75", "1", "1.25", "1.5", "2", "2.5", "3", "3.5", "4", "5", "6", "8", "10", "12"],
            fittings: [
                { name: "45° Elbow", code: "HE", type: "45elbow", values: { "0.75": 1, "1": 1, "1.25": 1, "1.5": 2, "2": 2, "2.5": 3, "3": 3, "3.5": 3, "4": 4, "5": 5, "6": 7, "8": 9, "10": 11, "12": 13 } },
                { name: "90° Standard Elbow", code: "SE", type: "elbow", values: { "0.75": 2, "1": 2, "1.25": 3, "1.5": 4, "2": 5, "2.5": 6, "3": 7, "3.5": 8, "4": 10, "5": 12, "6": 14, "8": 18, "10": 22, "12": 27 } },
                { name: "90° Long Turn Elbow", code: "LE", type: "lrelbow", values: { "0.75": 1, "1": 2, "1.25": 2, "1.5": 2, "2": 3, "2.5": 4, "3": 5, "3.5": 5, "4": 6, "5": 8, "6": 9, "8": 13, "10": 16, "12": 18 } },
                { name: "Tee or Cross (Flow Turned 90°)", code: "TT", type: "tee", values: { "0.75": 3, "1": 5, "1.25": 6, "1.5": 8, "2": 10, "2.5": 12, "3": 15, "3.5": 17, "4": 20, "5": 25, "6": 30, "8": 35, "10": 50, "12": 60 } },
                { name: "Butterfly Valve", code: "BV", type: "valve", values: { "0.75": "-", "1": "-", "1.25": "-", "1.5": "-", "2": 6, "2.5": 7, "3": 10, "3.5": "-", "4": 12, "5": 9, "6": 10, "8": 12, "10": 19, "12": 21 } },
                { name: "Gate Valve", code: "GV", type: "valve", values: { "0.75": "-", "1": "-", "1.25": "-", "1.5": "-", "2": 1, "2.5": 1, "3": 1, "3.5": 1, "4": 2, "5": 2, "6": 3, "8": 4, "10": 5, "12": 6 } },
                { name: "Vane type flow switch", code: "FS", type: "valve", values: { "0.75": "-", "1": 6, "1.25": 9, "1.5": 10, "2": 14, "2.5": 17, "3": 22, "3.5": "-", "4": 30, "5": "-", "6": 16, "8": 22, "10": 29, "12": 36 } },
                { name: "Swing Check*", code: "CV", type: "check", values: { "0.75": "-", "1": 5, "1.25": 7, "1.5": 9, "2": 11, "2.5": 14, "3": 16, "3.5": 19, "4": 22, "5": "-", "6": 32, "8": 45, "10": 55, "12": 65 } }
            ]
        };

        const hazardClasses = [
            { id: "LH", label: "Light Hazard", density: 0.10, defaultArea: 170, defaultOpArea: 1500, maxSpacing: 13.12 },
            { id: "OH1", label: "Ordinary Hazard Group 1", density: 0.15, defaultArea: 130, defaultOpArea: 1500, maxSpacing: 13.12 },
            { id: "OH2", label: "Ordinary Hazard Group 2", density: 0.20, defaultArea: 130, defaultOpArea: 1500, maxSpacing: 13.12 },
            { id: "EH1", label: "Extra Hazard Group 1", density: 0.30, defaultArea: 100, defaultOpArea: 2500, maxSpacing: 9.84 },
            { id: "EH2", label: "Extra Hazard Group 2", density: 0.40, defaultArea: 100, defaultOpArea: 2500, maxSpacing: 9.84 },
        ];

        const cFactors = [
            { value: 150, label: "150 - Plastic (listed) - Underground" },
            { value: 150, label: "150 - Plastic (listed) - Aboveground" },
            { value: 150, label: "150 - Copper Tube or Stainless Steel" },
            { value: 140, label: "140 - Cement-Lined Cast or Ductile Iron" },
            { value: 140, label: "140 - Asbestos Cement" },
            { value: 120, label: "120 - Steel (Wet System or Deluge System)" },
            { value: 100, label: "100 - Steel (Dry System or Preaction System)" },
            { value: 100, label: "100 - Cast or Ductile Iron, Unlined" },
        ];

        const kFactors = [5.6, 8.0, 11.2, 14.0, 16.8, 19.6, 22.4, 25.2, 28.0, 33.6];

        const App = () => {
            const [projectName, setProjectName] = useState("");
            const [samplingArea, setSamplingArea] = useState("");
            const [kFactor, setKFactor] = useState(5.6);
            const [cFactor, setCFactor] = useState(120);
            const [selectedHazard, setSelectedHazard] = useState("LH");
            const [designDensity, setDesignDensity] = useState(0.10);
            const [areaPerHead, setAreaPerHead] = useState(170);
            const [areaOfOperation, setAreaOfOperation] = useState(1500);
            const [pdfUrl, setPdfUrl] = useState(null);
            const [mode, setMode] = useState('pan');
            const [selectedPipeSize, setSelectedPipeSize] = useState("1");
            const [scalePoints, setScalePoints] = useState([]);
            const [pixelsPerMeter, setPixelsPerMeter] = useState(null);
            const [realWorldDist, setRealWorldDist] = useState('');
            const [showScaleDialog, setShowScaleDialog] = useState(false);
            const [drawnPipes, setDrawnPipes] = useState([]);
            const [tempPipe, setTempPipe] = useState(null);
            const [placedSprinklers, setPlacedSprinklers] = useState([]);
            const [placedEquipments, setPlacedEquipments] = useState([]);
            const [snapPoint, setSnapPoint] = useState(null);
            const [startSnapInfo, setStartSnapInfo] = useState(null);
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const containerRef = useRef(null);
            const [results, setResults] = useState([]);
            const [totalDemand, setTotalDemand] = useState({ flow: 0, pressure: 0 });
            const [visualNodes, setVisualNodes] = useState([]);


            const [sourceNodeId, setSourceNodeId] = useState(null);
            const [tempRect, setTempRect] = useState(null);

            const [showTags, setShowTags] = useState(true);
            const [tagPrefs, setTagPrefs] = useState({
                showSize: true,
                showLength: true,
                showFlow: true,
                showPressure: true
            });


            const [history, setHistory] = useState([{ pipes: [], sprinklers: [], equipments: [] }]);
            const [historyIndex, setHistoryIndex] = useState(0);
            const [showReport, setShowReport] = useState(false);
            const [viewMode, setViewMode] = useState('2d');
            const [isoAngle, setIsoAngle] = useState(45);
            const [reportImages, setReportImages] = useState([]);

            const [editingPipeId, setEditingPipeId] = useState(null);
            const [alignmentLines, setAlignmentLines] = useState([]);
            const [sprinklerDistanceGuide, setSprinklerDistanceGuide] = useState(null);
            const [pipeAlignmentGuide, setPipeAlignmentGuide] = useState(null);

            // New State for Project Management
            const projectHandle = useRef(null);
            const projectInputRef = useRef(null);
            const pendingIsoZoomFit = useRef(false);

            // Access Control State
            const [accessLevel, setAccessLevel] = useState(() => sessionStorage.getItem('hydraulic_auth_level')); // null = locked
            const [unlockCode, setUnlockCode] = useState('');
            const [showHint, setShowHint] = useState(false);

            const handleUnlock = () => {
                if (unlockCode === '1234') {
                    setAccessLevel('restricted');
                    sessionStorage.setItem('hydraulic_auth_level', 'restricted');
                    alert("Logged in as Restricted User (No Save/Save As)");
                } else if (btoa(unlockCode) === 'MjAxNw==') { // Full Version Check
                    setAccessLevel('full');
                    sessionStorage.setItem('hydraulic_auth_level', 'full');
                    alert("Full Version Unlocked!");
                } else {
                    alert("Invalid Code");
                }
            };


            const safeNum = (val, fallback = 0) => {
                const n = parseFloat(val);
                return isNaN(n) ? fallback : n;
            };
            const safeFixed = (val, dec = 2) => safeNum(val).toFixed(dec);

            // --- File Helpers ---
            const blobToBase64 = (blob) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            };

            // --- Project Management Functions ---

            const saveProject = async (saveAs = false) => {
                try {
                    // Prepare Data
                    let bgImageData = null;
                    if (pdfUrl) {
                        if (pdfUrl.startsWith('blob:')) {
                            // Fetch and convert to base64
                            const response = await fetch(pdfUrl);
                            const blob = await response.blob();
                            bgImageData = await blobToBase64(blob);
                        } else {
                            // Already base64
                            bgImageData = pdfUrl;
                        }
                    }

                    const projectData = {
                        version: "1.5",
                        timestamp: Date.now(),
                        state: {
                            projectName, samplingArea,
                            kFactor, cFactor, selectedHazard, designDensity, areaPerHead, areaOfOperation,
                            pixelsPerMeter, scalePoints,
                            drawnPipes, placedSprinklers, placedEquipments,
                            results, totalDemand, sourceNodeId,
                            visualNodes,
                            bgImageData
                        }
                    };

                    const jsonString = JSON.stringify(projectData, null, 2);

                    // 1. Try Saving to existing Handle
                    if (!saveAs && projectHandle.current) {
                        try {
                            const writable = await projectHandle.current.createWritable();
                            await writable.write(jsonString);
                            await writable.close();
                            alert("Project Saved!");
                            return;
                        } catch (e) {
                            console.warn("Handle invalid or permission denied, falling back to Save As flow", e);
                            // If handle fails, fall through to try "Save As" logic below
                        }
                    }

                    // 2. Try "Save As" using File System Access API
                    if (window.showSaveFilePicker) {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: 'Hydraulic_Project.json',
                                types: [{
                                    description: 'Hydraulic Project File',
                                    accept: { 'application/json': ['.json'] },
                                }],
                            });
                            projectHandle.current = handle;
                            const writable = await handle.createWritable();
                            await writable.write(jsonString);
                            await writable.close();
                            alert("Project Saved As New File!");
                            return; // Success, exit
                        } catch (err) {
                            // If user cancelled, stop.
                            if (err.name === 'AbortError') return;
                            // If SecurityError or other error, catch and fall through to Blob download
                            console.warn("File System Access API failed, falling back to download:", err);
                        }
                    }

                    // 3. Fallback: Classic Download Method (Works in iFrames/Cross-origin)
                    const blob = new Blob([jsonString], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `project_${Date.now()}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);

                } catch (err) {
                    console.error("Save failed", err);
                    alert("Error saving project: " + err.message);
                }
            };

            const loadProject = async () => {
                try {
                    let usedPicker = false;
                    // 1. Try File System Access API
                    if (window.showOpenFilePicker) {
                        try {
                            const [handle] = await window.showOpenFilePicker({
                                types: [{
                                    description: 'Hydraulic Project File',
                                    accept: { 'application/json': ['.json'] },
                                }],
                                multiple: false
                            });
                            projectHandle.current = handle;
                            const file = await handle.getFile();
                            const text = await file.text();
                            const data = JSON.parse(text);
                            restoreState(data);
                            usedPicker = true;
                        } catch (err) {
                            if (err.name === 'AbortError') return;
                            console.warn("File System Access API failed, falling back to input:", err);
                        }
                    }

                    // 2. Fallback: Hidden Input Click
                    if (!usedPicker) {
                        if (projectInputRef.current) projectInputRef.current.click();
                    }
                } catch (err) {
                    console.error(err);
                }
            };

            const handleProjectFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        projectHandle.current = null; // Reset handle as we can't save back to input file directly
                        restoreState(data);
                    } catch (err) {
                        alert("Invalid project file");
                    }
                };
                reader.readAsText(file);
                // Reset value so same file can be selected again
                e.target.value = '';
            };

            const restoreState = (data) => {
                if (data.state) {
                    const s = data.state;
                    setProjectName(s.projectName || "");
                    setSamplingArea(s.samplingArea || "");
                    setKFactor(s.kFactor);
                    setCFactor(s.cFactor);
                    setSelectedHazard(s.selectedHazard);
                    setDesignDensity(s.designDensity);
                    setAreaPerHead(s.areaPerHead);
                    setAreaOfOperation(s.areaOfOperation || 1500);
                    setPixelsPerMeter(s.pixelsPerMeter);
                    setScalePoints(s.scalePoints || []);
                    setDrawnPipes(s.drawnPipes || []);
                    setPlacedSprinklers(s.placedSprinklers || []);
                    setPlacedEquipments(s.placedEquipments || []);
                    setResults(s.results || []);
                    setTotalDemand(s.totalDemand || { flow: 0, pressure: 0 });
                    setSourceNodeId(s.sourceNodeId);
                    setVisualNodes(s.visualNodes || []);

                    if (s.bgImageData) {
                        setPdfUrl(s.bgImageData);
                    } else {
                        setPdfUrl(null);
                    }
                    // Reset history
                    setHistory([{ pipes: s.drawnPipes || [], sprinklers: s.placedSprinklers || [], equipments: s.placedEquipments || [] }]);
                    setHistoryIndex(0);

                    alert("Project Loaded Successfully!");
                }
            };

            const getContrastColor = (hexcolor) => {
                if (!hexcolor) return '#000000';
                hexcolor = hexcolor.replace("#", "");
                const r = parseInt(hexcolor.substr(0, 2), 16);
                const g = parseInt(hexcolor.substr(2, 2), 16);
                const b = parseInt(hexcolor.substr(4, 2), 16);
                const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                return (yiq >= 128) ? '#000000' : '#ffffff';
            };

            const commitToHistory = (newPipes, newSprinklers, newEquips = placedEquipments) => {
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push({ pipes: newPipes, sprinklers: newSprinklers, equipments: newEquips });
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
            };

            const handleUndo = () => {
                if (historyIndex > 0) {
                    const prevIndex = historyIndex - 1;
                    const prevState = history[prevIndex];
                    setDrawnPipes(prevState.pipes);
                    setPlacedSprinklers(prevState.sprinklers);
                    setPlacedEquipments(prevState.equipments || []);
                    setHistoryIndex(prevIndex);
                    setResults([]);
                    setTotalDemand({ flow: 0, pressure: 0 });
                }
            };

            const handleRedo = () => {
                if (historyIndex < history.length - 1) {
                    const nextIndex = historyIndex + 1;
                    const nextState = history[nextIndex];
                    setDrawnPipes(nextState.pipes);
                    setPlacedSprinklers(nextState.sprinklers);
                    setPlacedEquipments(nextState.equipments || []);
                    setHistoryIndex(nextIndex);
                    setResults([]);
                    setTotalDemand({ flow: 0, pressure: 0 });
                }
            };

            // Improved re-node logic: DFS Post-Order
            useEffect(() => {
                const uniqueNodes = new Map();
                const adj = {};
                const getKey = (pt) => `${pt.x.toFixed(4)},${pt.y.toFixed(4)}`;

                drawnPipes.forEach(p => {
                    const k1 = getKey(p.start);
                    const k2 = getKey(p.end);

                    if (!uniqueNodes.has(k1)) uniqueNodes.set(k1, { id: k1, x: p.start.x, y: p.start.y, degree: 0, maxPipeSize: 0, isVPipeBottom: false });
                    if (!uniqueNodes.has(k2)) uniqueNodes.set(k2, { id: k2, x: p.end.x, y: p.end.y, degree: 0, maxPipeSize: 0, isVPipeBottom: false });

                    if (p.isVertical) {
                        uniqueNodes.get(k2).isVPipeBottom = true;
                    }

                    uniqueNodes.get(k1).degree++;
                    uniqueNodes.get(k2).degree++;

                    const sizeVal = parseFloat(p.size);
                    uniqueNodes.get(k1).maxPipeSize = Math.max(uniqueNodes.get(k1).maxPipeSize, sizeVal);
                    uniqueNodes.get(k2).maxPipeSize = Math.max(uniqueNodes.get(k2).maxPipeSize, sizeVal);

                    if (!adj[k1]) adj[k1] = [];
                    if (!adj[k2]) adj[k2] = [];
                    adj[k1].push(k2);
                    adj[k2].push(k1);
                });

                let allNodes = Array.from(uniqueNodes.values());
                if (allNodes.length === 0) {
                    setVisualNodes([]);
                    return;
                }

                // Identify Source
                allNodes.sort((a, b) => {
                    if (b.maxPipeSize !== a.maxPipeSize) return b.maxPipeSize - a.maxPipeSize;
                    const degA = a.degree === 1 ? 1 : 0;
                    const degB = b.degree === 1 ? 1 : 0;
                    if (degA !== degB) return degB - degA;
                    if (Math.abs(a.x - b.x) > 1) return a.x - b.x;
                    return a.y - b.y;
                });
                let sourceNode = allNodes[0];

                const maxDepthMap = {};

                const calcMaxDepth = (u, p) => {
                    let maxD = 0;
                    if (adj[u]) {
                        adj[u].forEach(v => {
                            if (v !== p) {
                                maxD = Math.max(maxD, calcMaxDepth(v, u) + 1);
                            }
                        });
                    }
                    maxDepthMap[u] = maxD;
                    return maxD;
                };

                try {
                    const childrenMap = {};
                    const visitedBFS = new Set([sourceNode.id]);
                    const queue = [sourceNode.id];
                    allNodes.forEach(n => childrenMap[n.id] = []);

                    while (queue.length > 0) {
                        const u = queue.shift();
                        if (adj[u]) {
                            adj[u].forEach(v => {
                                if (!visitedBFS.has(v)) {
                                    visitedBFS.add(v);
                                    childrenMap[u].push(v);
                                    queue.push(v);
                                }
                            });
                        }
                    }

                    const calcDepthSafe = (u) => {
                        let maxD = 0;
                        childrenMap[u].forEach(v => {
                            maxD = Math.max(maxD, calcDepthSafe(v) + 1);
                        });
                        maxDepthMap[u] = maxD;
                        return maxD;
                    };
                    calcDepthSafe(sourceNode.id);

                    const finalOrder = [];
                    const dfsNumbering = (u) => {
                        const children = childrenMap[u];
                        children.sort((a, b) => {
                            const depthA = maxDepthMap[a] || 0;
                            const depthB = maxDepthMap[b] || 0;
                            if (depthA !== depthB) return depthB - depthA;
                            const nodeA = uniqueNodes.get(a);
                            const nodeB = uniqueNodes.get(b);
                            if (Math.abs(nodeA.y - nodeB.y) > 5) return nodeA.y - nodeB.y;
                            return nodeA.x - nodeB.x;
                        });
                        children.forEach(v => dfsNumbering(v));
                        finalOrder.push(u);
                    };
                    dfsNumbering(sourceNode.id);

                    let counter = 1;
                    finalOrder.forEach((nodeId) => {
                        if (uniqueNodes.has(nodeId)) {
                            uniqueNodes.get(nodeId).displayId = counter++;
                        }
                    });
                    // Handle disconnected
                    allNodes.forEach(n => {
                        if (!visitedBFS.has(n.id)) {
                            n.displayId = counter++;
                        }
                    });

                } catch (e) { console.warn("Node sorting failed", e); }

                // --- Calculate ISO Offsets ---
                // Pure Z-accumulation for each node from the source outward (simple BFS)
                const edgeAdj = {};
                drawnPipes.forEach(p => {
                    const k1 = `${p.start.x.toFixed(4)},${p.start.y.toFixed(4)}`;
                    const k2 = `${p.end.x.toFixed(4)},${p.end.y.toFixed(4)}`;
                    if (!edgeAdj[k1]) edgeAdj[k1] = [];
                    if (!edgeAdj[k2]) edgeAdj[k2] = [];
                    edgeAdj[k1].push({ to: k2, pipe: p, forward: true });
                    edgeAdj[k2].push({ to: k1, pipe: p, forward: false });
                });

                uniqueNodes.forEach((n) => {
                    n.isoOffset = { x: 0, y: 0 };
                });

                if (sourceNode && uniqueNodes.has(sourceNode.id)) {
                    const computedIso = new Set([sourceNode.id]);
                    const isoQueue = [sourceNode.id];

                    while (isoQueue.length > 0) {
                        const u = isoQueue.shift();
                        const uNode = uniqueNodes.get(u);

                        if (edgeAdj[u]) {
                            edgeAdj[u].forEach(edge => {
                                const v = edge.to;
                                if (!computedIso.has(v)) {
                                    const vNode = uniqueNodes.get(v);
                                    if (vNode) {
                                        let dvx = 0;
                                        let dvy = 0;

                                        if (edge.pipe.isVertical) {
                                            const rawH = parseFloat(edge.pipe.verticalHeight);
                                            const h_px = (isNaN(rawH) ? 0 : rawH) * (pixelsPerMeter || 20);

                                            // Flowing up means we add positive Z height relative to the screen. 
                                            // The delta visually maps to perfectly 'vertical' UP via CSS matrix transform when x is +delta, y is -delta.
                                            const directionMultiplier = edge.forward ? 1 : -1;
                                            const actual_h_px = directionMultiplier * h_px;

                                            const rad = (isoAngle * Math.PI) / 180;
                                            dvx = 2 * actual_h_px * Math.sin(rad);
                                            dvy = -2 * actual_h_px * Math.cos(rad);
                                        }

                                        vNode.isoOffset = {
                                            x: uNode.isoOffset.x + dvx,
                                            y: uNode.isoOffset.y + dvy
                                        };
                                        computedIso.add(v);
                                        isoQueue.push(v);
                                    }
                                }
                            });
                        }
                    }
                }
                // -----------------------------

                setVisualNodes(Array.from(uniqueNodes.values()));
                setSourceNodeId(sourceNode.id);

            }, [drawnPipes, pixelsPerMeter, isoAngle]);

            // After visualNodes updates with new isoAngle, zoom-fit if pending
            useEffect(() => {
                if (pendingIsoZoomFit.current && viewMode === 'iso') {
                    pendingIsoZoomFit.current = false;
                    // Use setTimeout(0) to ensure isoMap in render is up-to-date
                    setTimeout(() => handleZoomAllCenter(), 0);
                }
            }, [visualNodes]);

            // Reset results when parameters change
            useEffect(() => {
                setResults([]);
                setTotalDemand({ flow: 0, pressure: 0 });
            }, [kFactor, cFactor, selectedHazard, designDensity, areaPerHead, areaOfOperation]);

            const handleHazardChange = (e) => {
                const hazardId = e.target.value;
                setSelectedHazard(hazardId);
                const hazard = hazardClasses.find(h => h.id === hazardId);
                if (hazard) {
                    setDesignDensity(hazard.density);
                    if (hazard.defaultArea) {
                        setAreaPerHead(hazard.defaultArea);
                    }
                    if (hazard.defaultOpArea) {
                        setAreaOfOperation(hazard.defaultOpArea);
                    }
                }
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                if (pdfUrl && pdfUrl.startsWith('blob:')) URL.revokeObjectURL(pdfUrl);
                setPdfUrl(URL.createObjectURL(file));
                // Only reset if loading new background manually, or ask user? 
                // Currently just setting BG, keeping pipes.
                // setScalePoints([]);
                // setDrawnPipes([]);
                // setPlacedSprinklers([]);
                // setResults([]);
                // setVisualNodes([]);
                // setTotalDemand({ flow: 0, pressure: 0 });
                // setTransform({ x: 0, y: 0, scale: 1 });
                // setMode('pan');
                // setSourceNodeId(null);
                // setHistory([{ pipes: [], sprinklers: [] }]);
                // setHistoryIndex(0);
                // Resetting project handle as the context changed
                projectHandle.current = null;
            };




            const isPointInPolygon = (point, vs) => {
                let x = point.x, y = point.y;
                let inside = false;
                for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                    let xi = vs[i].x, yi = vs[i].y;
                    let xj = vs[j].x, yj = vs[j].y;
                    let intersect = ((yi > y) !== (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            };

            const generateGridInPolygon = (points) => {
                if (!pixelsPerMeter) {
                    alert("Please Set Scale First");
                    return;
                }
                const M_TO_FT = 3.28084;

                // 1. Bounds
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                points.forEach(p => {
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                });

                const widthPx = maxX - minX;
                const heightPx = maxY - minY;

                // Restore missing definitions
                const widthM = widthPx / pixelsPerMeter;
                const heightM = heightPx / pixelsPerMeter;

                // Restore M_TO_FT for display usage if needed, though we work in M for grid now
                // widthFt, heightFt definitions removed as we use M now

                const currentHazard = hazardClasses.find(h => h.id === selectedHazard);

                let MAX_AREA_M2;
                let targetSx; // Spacing X
                let targetSy; // Spacing Y

                if (selectedHazard.startsWith('EH')) {
                    // Extra Hazard
                    MAX_AREA_M2 = 9.00;
                    targetSx = 3.0;
                    targetSy = 3.0;
                } else if (selectedHazard === 'LH') {
                    // Light Hazard
                    MAX_AREA_M2 = 16.00; // Updated to 16 m²
                    targetSx = 4.0;
                    targetSy = 4.0;      // Updated to 4x4 m
                } else {
                    // Ordinary Hazard (OH1, OH2)
                    MAX_AREA_M2 = 12.10;
                    targetSx = 4.0;
                    targetSy = 3.0;
                }

                // Calculate Grid Counts (Reduce distance if needed by ceiling the count)
                let numCols = Math.ceil(widthM / targetSx);
                let numRows = Math.ceil(heightM / targetSy);

                // Ensure strict area compliance (Iterative adjustment if area > limit)
                // Though 4x3 = 12 <= 12.10, floating point or edge cases might occur
                let isValid = false;
                while (!isValid) {
                    const spX = widthM / numCols;
                    const spY = heightM / numRows;
                    const area = spX * spY;

                    if (area <= MAX_AREA_M2) {
                        isValid = true;
                    } else {
                        // Area too big, add a row or col
                        // Prefer adding to the dimension with larger spacing to balance?
                        // Or just simple increment
                        if (spX > spY) numCols++;
                        else numRows++;
                    }
                    if (numCols > 200 || numRows > 200) break; // Safety break
                }

                // Recalculate final spacing in Pixels for placement
                const finalSxM = widthM / numCols;
                const finalSyM = heightM / numRows;

                const SpacingX_Px = finalSxM * pixelsPerMeter;
                const SpacingY_Px = finalSyM * pixelsPerMeter;

                const newSprinklers = [];
                // Shift grid to center within the bounding box
                const startX = minX + (SpacingX_Px / 2);
                const startY = minY + (SpacingY_Px / 2);

                for (let r = 0; r < numRows; r++) {
                    for (let c = 0; c < numCols; c++) {
                        const p = {
                            x: startX + c * SpacingX_Px,
                            y: startY + r * SpacingY_Px
                        };
                        if (isPointInPolygon(p, points)) {
                            newSprinklers.push({ ...p, id: Date.now() + Math.random() });
                        }
                    }
                }

                if (newSprinklers.length > 0) {
                    const selectedAreaM2 = widthM * heightM;

                    if (window.confirm(`Detected Area based on ${currentHazard?.label || 'Hazard'}.\nSelected Area: ${selectedAreaM2.toFixed(2)} m²\nMaximum Distance: ${Math.max(targetSx, targetSy).toFixed(2)} m\nmaximum area / head = ${MAX_AREA_M2.toFixed(2)} m²\nValid Heads: ${newSprinklers.length}\n\nAdd these sprinklers?`)) {
                        setPlacedSprinklers(prev => [...prev, ...newSprinklers]);
                        commitToHistory(drawnPipes, [...placedSprinklers, ...newSprinklers]);
                    }
                }
            };

            const getCanvasCoords = (e) => {
                if (!containerRef.current) return { x: 0, y: 0 };
                const rect = containerRef.current.getBoundingClientRect();
                const rawX = (e.clientX - rect.left - transform.x) / transform.scale;
                const rawY = (e.clientY - rect.top - transform.y) / transform.scale;

                if (viewMode === 'iso') {
                    const y_unscaled = rawY / 0.5;
                    const rad = (isoAngle * Math.PI) / 180;
                    const cosA = Math.cos(rad);
                    const sinA = Math.sin(rad);
                    const xw = rawX * cosA - y_unscaled * sinA;
                    const yw = rawX * sinA + y_unscaled * cosA;
                    return { x: xw, y: yw };
                }

                return { x: rawX, y: rawY };
            };

            const projectPointToSegment = (P, A, B) => {
                const distAB2 = Math.pow(B.x - A.x, 2) + Math.pow(B.y - A.y, 2);
                if (distAB2 === 0) return A;
                let t = ((P.x - A.x) * (B.x - A.x) + (P.y - A.y) * (B.y - A.y)) / distAB2;
                t = Math.max(0, Math.min(1, t));
                return { x: A.x + t * (B.x - A.x), y: A.y + t * (B.y - A.y) };
            };

            const getSnappedCoords = (rawCoords) => {
                if (mode !== 'draw' && mode !== 'draw_vertical' && mode !== 'sprinkler') return { coords: rawCoords, isSnapped: false };

                const snapThreshold = 15 / transform.scale;
                let closestPoint = null;
                let minDistance = Infinity;
                let snapType = null;
                let snapTarget = null;

                placedSprinklers.forEach(s => {
                    const dist = Math.sqrt(Math.pow(s.x - rawCoords.x, 2) + Math.pow(s.y - rawCoords.y, 2));
                    if (dist < snapThreshold && dist < minDistance) {
                        minDistance = dist;
                        closestPoint = { x: s.x, y: s.y };
                        snapType = 'node';
                        snapTarget = s;
                    }
                });

                drawnPipes.forEach(pipe => {
                    [pipe.start, pipe.end].forEach((pt, idx) => {
                        let dist = Math.sqrt(Math.pow(pt.x - rawCoords.x, 2) + Math.pow(pt.y - rawCoords.y, 2));
                        let effectiveDist = dist;
                        if (pipe.isVertical && idx === 1) {
                            effectiveDist -= 0.001; // Prefer snapping to the bottom (end) of V-pipe
                        }
                        if (effectiveDist < snapThreshold && effectiveDist < minDistance) {
                            minDistance = effectiveDist;
                            closestPoint = pt;
                            snapType = 'node';
                            snapTarget = pipe;
                        }
                    });
                });

                if (!closestPoint) {
                    drawnPipes.forEach(pipe => {
                        const projected = projectPointToSegment(rawCoords, pipe.start, pipe.end);
                        const dist = Math.sqrt(Math.pow(projected.x - rawCoords.x, 2) + Math.pow(projected.y - rawCoords.y, 2));
                        if (dist < snapThreshold && dist < minDistance) {
                            minDistance = dist;
                            closestPoint = projected;
                            snapType = 'edge';
                            snapTarget = pipe;
                        }
                    });
                }

                if (closestPoint) return { coords: closestPoint, isSnapped: true, snapType, snapTarget };
                return { coords: rawCoords, isSnapped: false, snapType: null, snapTarget: null };
            };

            const splitPipeAtPoint = (pipes, targetPipe, splitPoint) => {
                const remainingPipes = pipes.filter(p => p.id !== targetPipe.id);
                const dist1 = Math.sqrt(Math.pow(splitPoint.x - targetPipe.start.x, 2) + Math.pow(splitPoint.y - targetPipe.start.y, 2));
                const dist2 = Math.sqrt(Math.pow(targetPipe.end.x - splitPoint.x, 2) + Math.pow(targetPipe.end.y - splitPoint.y, 2));

                const newSegments = [];
                if (dist1 > 0.1) {
                    newSegments.push({ ...targetPipe, id: Date.now() + Math.random(), end: splitPoint, pixelLength: dist1 });
                }
                if (dist2 > 0.1) {
                    newSegments.push({ ...targetPipe, id: Date.now() + Math.random() + 1, start: splitPoint, pixelLength: dist2 });
                }
                return [...remainingPipes, ...newSegments];
            };

            const distanceToSegment = (P, A, B) => {
                const distAB2 = Math.pow(B.x - A.x, 2) + Math.pow(B.y - A.y, 2);
                if (distAB2 === 0) return Math.sqrt(Math.pow(P.x - A.x, 2) + Math.pow(P.y - A.y, 2));
                let t = ((P.x - A.x) * (B.x - A.x) + (P.y - A.y) * (B.y - A.y)) / distAB2;
                t = Math.max(0, Math.min(1, t));
                return Math.sqrt(Math.pow(P.x - (A.x + t * (B.x - A.x)), 2) + Math.pow(P.y - (A.y + t * (B.y - A.y)), 2));
            };

            const handleMouseDown = (e) => {
                if (showScaleDialog || editingPipeId) return;

                // Middle Mouse (Button 1) -> Pan Override
                if (e.button === 1) {
                    e.preventDefault();
                    setIsDragging(true);
                    setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
                    return;
                }

                // Allow only Left Mouse Button (0) for Drawing
                if ((mode === 'draw' || mode === 'draw_vertical') && e.button !== 0) return;

                const rawCoords = getCanvasCoords(e);
                const { coords, isSnapped, snapType, snapTarget } = getSnappedCoords(rawCoords);

                if (mode === 'pan') {
                    setIsDragging(true);
                    setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
                } else if (mode === 'scale') {
                    setIsDragging(true);
                    setScalePoints([coords, coords]);
                } else if (mode === 'draw' || mode === 'draw_vertical') {
                    setIsDragging(true);
                    setStartSnapInfo(isSnapped ? { type: snapType, target: snapTarget, coords: coords } : null);
                    setTempPipe({ start: coords, end: coords, size: selectedPipeSize });
                } else if (mode === 'auto_sprinkler') {
                    // Only Box Mode Supported
                    setTempRect(null); // Ensure no stale rect
                    setIsDragging(true);
                    setDragStart({ x: e.clientX, y: e.clientY });
                }
            };


            const handleMouseMove = (e) => {
                if (showScaleDialog || editingPipeId) return;
                const rawCoords = getCanvasCoords(e);

                let effectiveCoords = rawCoords;

                if (isDragging && (mode === 'draw' || mode === 'draw_vertical') && tempPipe) {
                    const dx = rawCoords.x - tempPipe.start.x;
                    const dy = rawCoords.y - tempPipe.start.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 5 / transform.scale) {
                        const angle = Math.atan2(dy, dx);
                        const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);

                        effectiveCoords = {
                            x: tempPipe.start.x + Math.cos(snappedAngle) * dist,
                            y: tempPipe.start.y + Math.sin(snappedAngle) * dist
                        };
                    } else {
                        effectiveCoords = tempPipe.start;
                    }
                }

                // Check Alignment
                const { coords: pointSnappedCoords, isSnapped, snapType, snapTarget } = getSnappedCoords(effectiveCoords);
                let finalCoords = isSnapped ? pointSnappedCoords : effectiveCoords;
                const newAlignmentLines = [];

                setPipeAlignmentGuide(null);

                if (isSnapped && snapType === 'edge' && (mode === 'sprinkler')) {
                    const pipe = snapTarget;
                    const headsOnPipe = placedSprinklers.filter(s => distanceToSegment(s, pipe.start, pipe.end) < 1);

                    headsOnPipe.sort((a, b) => {
                        const da = Math.pow(a.x - pipe.start.x, 2) + Math.pow(a.y - pipe.start.y, 2);
                        const db = Math.pow(b.x - pipe.start.x, 2) + Math.pow(b.y - pipe.start.y, 2);
                        return da - db;
                    });

                    let isMidpoint = false;
                    const snapThreshold = 10 / transform.scale;

                    for (let i = 0; i < headsOnPipe.length - 1; i++) {
                        const h1 = headsOnPipe[i];
                        const h2 = headsOnPipe[i + 1];
                        const mx = (h1.x + h2.x) / 2;
                        const my = (h1.y + h2.y) / 2;

                        const distToMid = Math.sqrt(Math.pow(finalCoords.x - mx, 2) + Math.pow(finalCoords.y - my, 2));

                        if (distToMid < snapThreshold) {
                            finalCoords = { x: mx, y: my };
                            isMidpoint = true;
                            break;
                        }
                    }

                    setPipeAlignmentGuide({
                        p1: pipe.start,
                        p2: pipe.end,
                        heads: headsOnPipe,
                        cursor: finalCoords,
                        isMidpoint: isMidpoint
                    });
                }
                else if (!isSnapped && (mode === 'draw' || mode === 'draw_vertical') && tempPipe) {
                    const p1 = tempPipe.start;
                    const dx = effectiveCoords.x - p1.x;
                    const dy = effectiveCoords.y - p1.y;
                    const len2 = dx * dx + dy * dy;

                    if (len2 > 0.001) {
                        const alignThreshold = 10 / transform.scale;
                        let bestProj = null;
                        let minDist = alignThreshold;
                        let bestHead = null;

                        placedSprinklers.forEach(s => {
                            const v1x = s.x - p1.x;
                            const v1y = s.y - p1.y;
                            const t = (v1x * dx + v1y * dy) / len2;
                            const projX = p1.x + t * dx;
                            const projY = p1.y + t * dy;
                            const dist = Math.sqrt(Math.pow(finalCoords.x - projX, 2) + Math.pow(finalCoords.y - projY, 2));

                            if (dist < minDist) {
                                minDist = dist;
                                bestProj = { x: projX, y: projY };
                                bestHead = s;
                            }
                        });

                        if (bestProj) {
                            finalCoords = bestProj;
                            newAlignmentLines.push({
                                x1: bestHead.x, y1: bestHead.y,
                                x2: bestProj.x, y2: bestProj.y
                            });
                        }
                    }
                }
                else if (!isSnapped && mode === 'sprinkler') {
                    const alignThreshold = 10 / transform.scale;
                    placedSprinklers.forEach(s => {
                        if (Math.abs(effectiveCoords.x - s.x) < alignThreshold) {
                            finalCoords = { ...finalCoords, x: s.x };
                            newAlignmentLines.push({ x1: s.x, y1: s.y, x2: s.x, y2: finalCoords.y });
                        }
                        if (Math.abs(effectiveCoords.y - s.y) < alignThreshold) {
                            finalCoords = { ...finalCoords, y: s.y };
                            newAlignmentLines.push({ x1: s.x, y1: s.y, x2: finalCoords.x, y2: s.y });
                        }
                    });
                }

                setAlignmentLines(newAlignmentLines);

                if (mode === 'sprinkler' && placedSprinklers.length > 0) {
                    let minD = Infinity;
                    let closest = null;
                    const candidates = (pipeAlignmentGuide && pipeAlignmentGuide.heads.length > 0)
                        ? pipeAlignmentGuide.heads
                        : placedSprinklers;

                    candidates.forEach(s => {
                        const d = Math.sqrt(Math.pow(s.x - finalCoords.x, 2) + Math.pow(s.y - finalCoords.y, 2));
                        if (d > 0.1 && d < minD) {
                            minD = d;
                            closest = s;
                        }
                    });

                    if (closest) {
                        const lenPx = minD;
                        const lenText = pixelsPerMeter
                            ? `${(lenPx / pixelsPerMeter).toFixed(1)} m.`
                            : `${Math.round(lenPx)} px`;

                        setSprinklerDistanceGuide({
                            start: closest,
                            end: finalCoords,
                            text: lenText
                        });
                    } else {
                        setSprinklerDistanceGuide(null);
                    }
                } else {
                    setSprinklerDistanceGuide(null);
                }

                const snapPointToUse = isSnapped ? pointSnappedCoords : (newAlignmentLines.length > 0 ? finalCoords : null);
                setSnapPoint(pipeAlignmentGuide?.isMidpoint ? finalCoords : snapPointToUse);

                if (isDragging) {
                    if (mode === 'pan' || (e.buttons & 4)) {
                        setTransform(prev => ({ ...prev, x: e.clientX - dragStart.x, y: e.clientY - dragStart.y }));
                    } else if (mode === 'scale') {
                        const start = scalePoints[0];
                        const current = rawCoords;
                        let nextPoint = current;

                        // Lock to straight line automatically (horizontal or vertical)
                        const dx = Math.abs(current.x - start.x);
                        const dy = Math.abs(current.y - start.y);
                        if (dx > dy) {
                            nextPoint = { x: current.x, y: start.y };
                        } else {
                            nextPoint = { x: start.x, y: current.y };
                        }

                        setScalePoints(prev => [prev[0], nextPoint]);
                    } else if (mode === 'draw' || mode === 'draw_vertical') {
                        setTempPipe(prev => ({ ...prev, end: finalCoords }));
                    } else if (mode === 'auto_sprinkler') {
                        // Only Box Mode
                        if (tempRect) {
                            setTempRect(prev => ({ ...prev, end: rawCoords }));
                        } else {
                            const dx = e.clientX - dragStart.x;
                            const dy = e.clientY - dragStart.y;
                            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                                const rect = containerRef.current.getBoundingClientRect();
                                const startCanvX = (dragStart.x - rect.left - transform.x) / transform.scale;
                                const startCanvY = (dragStart.y - rect.top - transform.y) / transform.scale;
                                setTempRect({ start: { x: startCanvX, y: startCanvY }, end: rawCoords });
                            }
                        }
                    }
                }
            };

            const handleMouseUp = (e) => {
                if (showScaleDialog || editingPipeId) return;

                if (mode === 'scale' && isDragging) {
                    const dx = scalePoints[1].x - scalePoints[0].x;
                    const dy = scalePoints[1].y - scalePoints[0].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 5) {
                        setShowScaleDialog(true);
                        setRealWorldDist('');
                        setIsDragging(false);
                        return;
                    } else {
                        setScalePoints([]);
                    }
                } else if ((mode === 'draw' || mode === 'draw_vertical') && isDragging && tempPipe) {
                    const finalEnd = tempPipe.end;
                    const { isSnapped, snapType, snapTarget, coords: snappedCoords } = getSnappedCoords(finalEnd);
                    const actualEnd = isSnapped ? snappedCoords : finalEnd;
                    const dx = actualEnd.x - tempPipe.start.x;
                    const dy = actualEnd.y - tempPipe.start.y;
                    const pixelLen = Math.sqrt(dx * dx + dy * dy);

                    if (pixelLen > 2) {
                        let nextPipes = [...drawnPipes];
                        let startPoint = tempPipe.start;
                        let endPoint = actualEnd;

                        if (startSnapInfo && startSnapInfo.type === 'edge' && startSnapInfo.target) {
                            const targetPipe = nextPipes.find(p => p.id === startSnapInfo.target.id);
                            if (targetPipe) {
                                nextPipes = splitPipeAtPoint(nextPipes, targetPipe, startSnapInfo.coords);
                                startPoint = startSnapInfo.coords;
                            }
                        }

                        if (isSnapped && snapType === 'edge' && snapTarget) {
                            const targetPipe = nextPipes.find(p => p.id === snapTarget.id);
                            if (targetPipe) {
                                nextPipes = splitPipeAtPoint(nextPipes, targetPipe, actualEnd);
                                endPoint = actualEnd;
                            }
                        }

                        let verticalHeight = 0;
                        let isVertical = false;

                        if (mode === 'draw_vertical') {
                            const heightStr = prompt('ระบุความสูงของท่อแนวดิ่ง (เมตร):\n(+ ใส่ค่าบวกเพื่อท่อชี้ขึ้น, - ใส่ค่าลบเพื่อท่อชี้ลง)', '3.0');
                            if (heightStr === null) {
                                setTempPipe(null);
                                setStartSnapInfo(null);
                                setIsDragging(false);
                                return;
                            }
                            const h = parseFloat(heightStr);
                            if (isNaN(h) || h === 0) {
                                alert('ความสูงไม่ถูกต้อง');
                                setTempPipe(null);
                                setStartSnapInfo(null);
                                setIsDragging(false);
                                return;
                            }
                            verticalHeight = h;
                            isVertical = true;
                        }

                        const newPipe = {
                            id: Date.now() + Math.random(),
                            start: startPoint,
                            end: endPoint,
                            size: tempPipe.size,
                            pixelLength: pixelLen,
                            isVertical: isVertical,
                            verticalHeight: verticalHeight
                        };
                        nextPipes.push(newPipe);
                        setDrawnPipes(nextPipes);
                        commitToHistory(nextPipes, placedSprinklers);
                    } else if (mode === 'draw_vertical') {
                        let nextPipes = [...drawnPipes];
                        let startPoint = tempPipe.start;

                        if (startSnapInfo && startSnapInfo.type === 'edge' && startSnapInfo.target) {
                            const targetPipe = nextPipes.find(p => p.id === startSnapInfo.target.id);
                            if (targetPipe) {
                                nextPipes = splitPipeAtPoint(nextPipes, targetPipe, startSnapInfo.coords);
                                startPoint = startSnapInfo.coords;
                            }
                        }

                        const heightStr = prompt('ระบุความสูงของท่อแนวดิ่ง (เมตร):\n(+ ใส่ค่าบวกเพื่อท่อชี้ขึ้น, - ใส่ค่าลบเพื่อท่อชี้ลง)', '3.0');
                        if (heightStr === null) {
                            setTempPipe(null);
                            setStartSnapInfo(null);
                            setIsDragging(false);
                            return;
                        }
                        const h = parseFloat(heightStr);
                        if (isNaN(h) || h === 0) {
                            alert('ความสูงไม่ถูกต้อง');
                            setTempPipe(null);
                            setStartSnapInfo(null);
                            setIsDragging(false);
                            return;
                        }

                        // Create an invisible mathematical offset for the bottom of the V-pipe
                        const offset = 0.0001;
                        const endPoint = { x: startPoint.x, y: startPoint.y + offset };

                        const newPipe = {
                            id: Date.now() + Math.random(),
                            start: startPoint,
                            end: endPoint,
                            size: tempPipe.size,
                            pixelLength: offset,
                            isVertical: true,
                            verticalHeight: h
                        };
                        nextPipes.push(newPipe);
                        setDrawnPipes(nextPipes);
                        commitToHistory(nextPipes, placedSprinklers);
                    }
                    setTempPipe(null);
                    setStartSnapInfo(null);
                } else if (mode === 'auto_sprinkler') {
                    if (tempRect) {
                        // Box Completed
                        const { start, end } = tempRect;
                        const width = Math.abs(end.x - start.x);
                        const height = Math.abs(end.y - start.y);

                        // Prevent accidental clicks or tiny drags from triggering
                        if (width > 10 / transform.scale && height > 10 / transform.scale) {
                            const p1 = { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) };
                            const p2 = { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) };
                            const p3 = { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };
                            const p4 = { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };
                            generateGridInPolygon([p1, p2, p3, p4]);
                        }
                        setTempRect(null);
                    }
                }


                setIsDragging(false);
                setAlignmentLines([]);
                setSprinklerDistanceGuide(null);
                setPipeAlignmentGuide(null);
            };

            const findClickedPipe = (rawCoords, clickThreshold) => {
                let bestPipe = null;
                let minDist = clickThreshold;

                drawnPipes.forEach(pipe => {
                    if (viewMode === '2d' && pipe.isVertical) return;

                    let p1 = { ...pipe.start };
                    let p2 = { ...pipe.end };
                    let dist;

                    if (viewMode === 'iso') {
                        const kS = `${pipe.start.x.toFixed(4)},${pipe.start.y.toFixed(4)}`;
                        const kE = `${pipe.end.x.toFixed(4)},${pipe.end.y.toFixed(4)}`;
                        const oS = isoMap[kS] || { x: 0, y: 0 };
                        const oE = isoMap[kE] || { x: 0, y: 0 };

                        p1.x += oS.x;
                        p1.y += oS.y;
                        p2.x += oE.x;
                        p2.y += oE.y;

                        if (pipe.isVertical) {
                            let p1_up = { x: p1.x + (oE.x - oS.x), y: p1.y + (oE.y - oS.y) };
                            const dist1 = distanceToSegment(rawCoords, p1, p1_up);
                            const dist2 = distanceToSegment(rawCoords, p1_up, p2);
                            dist = Math.min(dist1, dist2);
                        } else {
                            dist = distanceToSegment(rawCoords, p1, p2);
                        }
                    } else {
                        dist = distanceToSegment(rawCoords, p1, p2);
                    }

                    if (dist < minDist) {
                        minDist = dist;
                        bestPipe = pipe;
                    }
                });

                return bestPipe;
            };

            const handleCanvasClick = (e) => {
                if (showScaleDialog || editingPipeId) return;
                const rawCoords = getCanvasCoords(e);
                const { coords: pointSnappedCoords, isSnapped, snapType, snapTarget } = getSnappedCoords(rawCoords);
                let finalCoords = isSnapped ? pointSnappedCoords : rawCoords;

                if (!isSnapped && mode === 'sprinkler') {
                    const alignThreshold = 10 / transform.scale;
                    let alignedX = rawCoords.x;
                    let alignedY = rawCoords.y;
                    placedSprinklers.forEach(s => {
                        if (Math.abs(rawCoords.x - s.x) < alignThreshold) alignedX = s.x;
                        if (Math.abs(rawCoords.y - s.y) < alignThreshold) alignedY = s.y;
                    });
                    finalCoords = { x: alignedX, y: alignedY };
                }

                if (mode === 'sprinkler') {
                    const newSprinklers = [...placedSprinklers, { ...finalCoords, id: Date.now() }];
                    setPlacedSprinklers(newSprinklers);
                    let nextPipes = drawnPipes;
                    if (isSnapped && snapType === 'edge' && snapTarget) {
                        nextPipes = splitPipeAtPoint(drawnPipes, snapTarget, finalCoords);
                        setDrawnPipes(nextPipes);
                    }
                    setResults([]); // Clear results
                    setTotalDemand({ flow: 0, pressure: 0 });
                    commitToHistory(nextPipes, newSprinklers);
                } else if (mode.startsWith('eq_')) {
                    const eqType = mode.split('_')[1];
                    const clickThreshold = 15 / transform.scale;
                    let closestPipe = null;
                    let minDist = clickThreshold;
                    drawnPipes.forEach(pipe => {
                        const dist = distanceToSegment(rawCoords, pipe.start, pipe.end);
                        if (dist < minDist) { minDist = dist; closestPipe = pipe; }
                    });

                    if (closestPipe) {
                        const proj = projectPointToSegment(rawCoords, closestPipe.start, closestPipe.end);
                        const newEq = { id: Date.now(), x: proj.x, y: proj.y, type: eqType, pipeId: closestPipe.id };
                        const newEquipments = [...placedEquipments, newEq];
                        setPlacedEquipments(newEquipments);
                        setResults([]); // Clear results on modification
                        setTotalDemand({ flow: 0, pressure: 0 });
                        commitToHistory(drawnPipes, placedSprinklers, newEquipments);
                    }
                } else if (mode === 'delete') {
                    const clickThreshold = 10 / transform.scale;

                    const equipToDelete = placedEquipments.find(e => {
                        return Math.sqrt(Math.pow(e.x - rawCoords.x, 2) + Math.pow(e.y - rawCoords.y, 2)) < clickThreshold;
                    });

                    if (equipToDelete) {
                        const nextEqs = placedEquipments.filter(e => e.id !== equipToDelete.id);
                        setPlacedEquipments(nextEqs);
                        setResults([]);
                        setTotalDemand({ flow: 0, pressure: 0 });
                        commitToHistory(drawnPipes, placedSprinklers, nextEqs);
                        return;
                    }

                    const sprinklerToDelete = placedSprinklers.find(s => {
                        const dist = Math.sqrt(Math.pow(s.x - rawCoords.x, 2) + Math.pow(s.y - rawCoords.y, 2));
                        return dist < clickThreshold;
                    });

                    if (sprinklerToDelete) {
                        const nextSprinklers = placedSprinklers.filter(s => s.id !== sprinklerToDelete.id);
                        setPlacedSprinklers(nextSprinklers);
                        setResults([]);
                        setTotalDemand({ flow: 0, pressure: 0 });
                        commitToHistory(drawnPipes, nextSprinklers);
                        return;
                    }

                    const pipeToDelete = findClickedPipe(rawCoords, clickThreshold);

                    if (pipeToDelete) {
                        const nextPipes = drawnPipes.filter(p => p.id !== pipeToDelete.id);
                        setDrawnPipes(nextPipes);
                        setResults([]);
                        setTotalDemand({ flow: 0, pressure: 0 });
                        commitToHistory(nextPipes, placedSprinklers);
                    }
                }
            };

            const handleCanvasDoubleClick = (e) => {
                if (showScaleDialog) return;
                const rawCoords = getCanvasCoords(e);
                const clickThreshold = 10 / transform.scale;
                const clickedPipe = findClickedPipe(rawCoords, clickThreshold);
                if (clickedPipe) {
                    setEditingPipeId(clickedPipe.id);
                }
            };

            const updatePipeSize = (newSize) => {
                const nextPipes = drawnPipes.map(p =>
                    p.id === editingPipeId ? { ...p, size: newSize } : p
                );
                setDrawnPipes(nextPipes);
                setResults([]);
                setTotalDemand({ flow: 0, pressure: 0 });
                commitToHistory(nextPipes, placedSprinklers);
                setEditingPipeId(null);
            };

            const applyScale = () => {
                if (scalePoints.length < 2) return;
                const dx = scalePoints[1].x - scalePoints[0].x;
                const dy = scalePoints[1].y - scalePoints[0].y;
                const pixelDist = Math.sqrt(dx * dx + dy * dy);
                const rDist = parseFloat(realWorldDist);

                if (pixelDist > 0 && rDist > 0) {
                    setPixelsPerMeter(pixelDist / rDist);
                    setMode('pan');
                    setShowScaleDialog(false);
                    setScalePoints([]);
                } else {
                    alert("กรุณาระบุระยะทางที่ถูกต้อง");
                }
            };

            const adjustZoom = (delta) => {
                if (!containerRef.current) return;
                const zoomStep = 0.15;
                const oldScale = transform.scale;
                const newScale = Math.min(Math.max(oldScale + (delta > 0 ? zoomStep : -zoomStep), 0.1), 10);
                const rect = containerRef.current.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                const worldX = (centerX - transform.x) / oldScale;
                const worldY = (centerY - transform.y) / oldScale;
                const newX = centerX - worldX * newScale;
                const newY = centerY - worldY * newScale;
                setTransform({ x: newX, y: newY, scale: newScale });
            };

            const handleZoomAllCenter = () => {
                if (!containerRef.current) return;

                const points = [];
                drawnPipes.forEach(p => { points.push(p.start); points.push(p.end); });
                placedSprinklers.forEach(s => points.push({ x: s.x, y: s.y }));
                placedEquipments.forEach(e => points.push({ x: e.x, y: e.y }));

                if (points.length === 0) {
                    setTransform({ x: 0, y: 0, scale: 1 });
                    return;
                }

                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                points.forEach(p => {
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                });

                const width = Math.max(maxX - minX, 10);
                const height = Math.max(maxY - minY, 10);

                const rect = containerRef.current.getBoundingClientRect();
                const padding = 100;

                let renderWidth = width;
                let renderHeight = height;
                let centerX = minX + width / 2;
                let centerY = minY + height / 2;

                let isoMinX = Infinity, isoMaxX = -Infinity, isoMinY = Infinity, isoMaxY = -Infinity;

                if (viewMode === 'iso') {
                    const rad = (isoAngle * Math.PI) / 180;
                    const cosA = Math.cos(rad);
                    const sinA = Math.sin(rad);

                    points.forEach(p => {
                        let nx = p.x;
                        let ny = p.y;
                        const k = `${nx.toFixed(4)},${ny.toFixed(4)}`;
                        const off = isoMap[k];
                        if (off) {
                            nx += off.x;
                            ny += off.y;
                        }
                        const isoX = nx * cosA + ny * sinA;
                        const isoY = (-nx * sinA + ny * cosA) * 0.5;
                        isoMinX = Math.min(isoMinX, isoX);
                        isoMaxX = Math.max(isoMaxX, isoX);
                        isoMinY = Math.min(isoMinY, isoY);
                        isoMaxY = Math.max(isoMaxY, isoY);
                    });

                    drawnPipes.forEach(pipe => {
                        if (pipe.isVertical) {
                            const kS = `${pipe.start.x.toFixed(4)},${pipe.start.y.toFixed(4)}`;
                            const kE = `${pipe.end.x.toFixed(4)},${pipe.end.y.toFixed(4)}`;
                            const oS = isoMap[kS] || { x: 0, y: 0 };
                            const oE = isoMap[kE] || { x: 0, y: 0 };
                            let px1 = pipe.start.x + oS.x;
                            let py1 = pipe.start.y + oS.y;
                            let p1_up_x = px1 + (oE.x - oS.x);
                            let p1_up_y = py1 + (oE.y - oS.y);

                            const isoX = p1_up_x * cosA + p1_up_y * sinA;
                            const isoY = (-p1_up_x * sinA + p1_up_y * cosA) * 0.5;
                            isoMinX = Math.min(isoMinX, isoX);
                            isoMaxX = Math.max(isoMaxX, isoX);
                            isoMinY = Math.min(isoMinY, isoY);
                            isoMaxY = Math.max(isoMaxY, isoY);
                        }
                    });

                    renderWidth = Math.max(isoMaxX - isoMinX, 10);
                    renderHeight = Math.max(isoMaxY - isoMinY, 10);
                }

                let newScale = Math.min((rect.width - padding) / renderWidth, (rect.height - padding) / renderHeight);
                newScale = newScale * 0.85;
                newScale = Math.min(Math.max(newScale, 0.1), 5);

                let newX, newY;
                if (viewMode === 'iso') {
                    const isoCenterX = (isoMinX + isoMaxX) / 2;
                    const isoCenterY = (isoMinY + isoMaxY) / 2;
                    newX = (rect.width / 2) - (isoCenterX * newScale);
                    newY = (rect.height / 2) - (isoCenterY * newScale);
                } else {
                    newX = (rect.width / 2) - (centerX * newScale);
                    newY = (rect.height / 2) - (centerY * newScale);
                }

                setTransform({ x: newX, y: newY, scale: newScale });
            };

            const handleCaptureImage = () => {
                try {
                    const container = containerRef.current;
                    if (!container) return;

                    const RES = 2; // Output resolution multiplier
                    const containerW = container.clientWidth;
                    const containerH = container.clientHeight;
                    const TITLE_H = 60 * RES; // Title bar height

                    const canvasW = containerW * RES;
                    const canvasH = containerH * RES + TITLE_H;

                    const canvas = document.createElement('canvas');
                    canvas.width = canvasW;
                    canvas.height = canvasH;
                    const ctx = canvas.getContext('2d');

                    // --- White background ---
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvasW, canvasH);

                    // --- Offset all drawing below title ---
                    ctx.save();
                    ctx.translate(0, TITLE_H);

                    // --- Helper: Convert world coords to iso-screen coords ---
                    const toScreen = (x, y) => {
                        if (viewMode !== 'iso') return { x, y };
                        const rad = (isoAngle * Math.PI) / 180;
                        const cosA = Math.cos(rad);
                        const sinA = Math.sin(rad);
                        return {
                            x: x * cosA + y * sinA,
                            y: (-x * sinA + y * cosA) * 0.5
                        };
                    };

                    // --- Convert world coord -> canvas pixel (matches viewport exactly) ---
                    const w2c = (wx, wy) => {
                        const s = toScreen(wx, wy);
                        return {
                            x: (s.x * transform.scale + transform.x) * RES,
                            y: (s.y * transform.scale + transform.y) * RES
                        };
                    };

                    // --- Convert screen-projected coord -> canvas pixel (for tagLayout) ---
                    const s2c = (sx, sy) => ({
                        x: (sx * transform.scale + transform.x) * RES,
                        y: (sy * transform.scale + transform.y) * RES
                    });

                    // Scale a "screen pixel" value to canvas pixels
                    const sp = (v) => v * RES;

                    // --- Build isoMap from visualNodes ---
                    const isoMap = {};
                    visualNodes.forEach(n => {
                        if (n.isoOffset) {
                            isoMap[n.id] = n.isoOffset;
                        }
                    });

                    // --- Draw content function ---
                    const drawContent = () => {
                        const LINE_W = sp(3); // 3 screen pixels

                        // --- Draw Pipes ---
                        drawnPipes.forEach(pipe => {
                            const spec = pipeSpecs.find(s => s.nominal === pipe.size) || pipeSpecs[0];
                            let px1 = pipe.start.x, py1 = pipe.start.y;
                            let px2 = pipe.end.x, py2 = pipe.end.y;

                            if (viewMode === 'iso') {
                                const kS = `${pipe.start.x.toFixed(4)},${pipe.start.y.toFixed(4)}`;
                                const kE = `${pipe.end.x.toFixed(4)},${pipe.end.y.toFixed(4)}`;
                                const oS = isoMap[kS] || { x: 0, y: 0 };
                                const oE = isoMap[kE] || { x: 0, y: 0 };
                                px1 += oS.x; py1 += oS.y;
                                px2 += oE.x; py2 += oE.y;

                                if (pipe.isVertical) {
                                    const p1_up_x = pipe.start.x + oS.x + (oE.x - oS.x);
                                    const p1_up_y = pipe.start.y + oS.y + (oE.y - oS.y);
                                    const c1 = w2c(px1, py1);
                                    const c2 = w2c(p1_up_x, p1_up_y);
                                    const c3 = w2c(px2, py2);

                                    ctx.beginPath();
                                    ctx.moveTo(c1.x, c1.y);
                                    ctx.lineTo(c2.x, c2.y);
                                    ctx.lineTo(c3.x, c3.y);
                                    ctx.strokeStyle = spec.color;
                                    ctx.lineWidth = LINE_W;
                                    ctx.lineCap = 'round';
                                    ctx.lineJoin = 'round';
                                    ctx.setLineDash([]);
                                    ctx.stroke();

                                    // V-pipe label
                                    const midC = { x: (c1.x + c2.x) / 2, y: (c1.y + c2.y) / 2 };
                                    ctx.font = `bold ${sp(11)}px 'Segoe UI', sans-serif`;
                                    ctx.fillStyle = '#ea580c';
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'bottom';
                                    ctx.strokeStyle = '#ffffff';
                                    ctx.lineWidth = sp(3);
                                    ctx.strokeText(`(V) ${pipe.verticalHeight} m.`, midC.x, midC.y - sp(4));
                                    ctx.fillText(`(V) ${pipe.verticalHeight} m.`, midC.x, midC.y - sp(4));
                                    return;
                                }
                            } else {
                                if (pipe.isVertical) return; // Hidden in 2D
                            }

                            const c1 = w2c(px1, py1);
                            const c2 = w2c(px2, py2);

                            ctx.beginPath();
                            ctx.moveTo(c1.x, c1.y);
                            ctx.lineTo(c2.x, c2.y);
                            ctx.strokeStyle = spec.color;
                            ctx.lineWidth = LINE_W;
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            ctx.setLineDash([]);
                            ctx.stroke();

                            // --- Draw Equipment on this pipe ---
                            placedEquipments.filter(e => e.pipeId === pipe.id || (!e.pipeId && distanceToSegment(e, pipe.start, pipe.end) < 5)).forEach(eq => {
                                const dx = pipe.end.x - pipe.start.x;
                                const dy = pipe.end.y - pipe.start.y;
                                const len2 = dx * dx + dy * dy;
                                const t = len2 === 0 ? 0 : ((eq.x - pipe.start.x) * dx + (eq.y - pipe.start.y) * dy) / len2;
                                const ex = px1 + t * (px2 - px1);
                                const ey = py1 + t * (py2 - py1);
                                const ce = w2c(ex, ey);

                                const rw = sp(24);
                                const rh = sp(16);
                                const rx = sp(3);
                                ctx.fillStyle = spec.color;
                                ctx.strokeStyle = '#ffffff';
                                ctx.lineWidth = sp(1);
                                const rectX = ce.x - rw / 2;
                                const rectY = ce.y - rh / 2;
                                ctx.beginPath();
                                ctx.roundRect(rectX, rectY, rw, rh, rx);
                                ctx.fill();
                                ctx.stroke();

                                ctx.fillStyle = getContrastColor(spec.color);
                                ctx.font = `bold ${sp(9)}px 'Segoe UI', sans-serif`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(eq.type, ce.x, ce.y);
                            });
                        });

                        // --- Draw Nodes ---
                        visualNodes.forEach(node => {
                            if (viewMode !== 'iso' && node.isVPipeBottom) return;
                            const isSource = node.id === sourceNodeId;
                            let nx = viewMode === 'iso' && node.isoOffset ? node.x + node.isoOffset.x : node.x;
                            let ny = viewMode === 'iso' && node.isoOffset ? node.y + node.isoOffset.y : node.y;
                            const cn = w2c(nx, ny);

                            const r = sp(isSource ? 3.5 : 1.8);
                            ctx.beginPath();
                            ctx.arc(cn.x, cn.y, r, 0, Math.PI * 2);
                            ctx.fillStyle = '#ffffff';
                            ctx.fill();
                            ctx.strokeStyle = isSource ? '#ef4444' : '#94a3b8';
                            ctx.lineWidth = sp(1.2);
                            ctx.stroke();

                            // Node label
                            ctx.font = `bold ${sp(isSource ? 11 : 9)}px 'Segoe UI', sans-serif`;
                            ctx.fillStyle = isSource ? '#ef4444' : '#64748b';
                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'bottom';
                            const labelText = isSource ? `#${node.displayId} (S)` : `#${node.displayId}`;
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = sp(3);
                            ctx.strokeText(labelText, cn.x + sp(isSource ? 5 : 3), cn.y - sp(isSource ? 5 : 3));
                            ctx.fillText(labelText, cn.x + sp(isSource ? 5 : 3), cn.y - sp(isSource ? 5 : 3));
                        });

                        // --- Draw Sprinklers ---
                        placedSprinklers.forEach(s => {
                            let nx = s.x, ny = s.y;
                            if (viewMode === 'iso') {
                                const k = `${nx.toFixed(4)},${ny.toFixed(4)}`;
                                const off = isoMap[k] || { x: 0, y: 0 };
                                nx += off.x; ny += off.y;
                            }
                            const cs = w2c(nx, ny);

                            // Outer circle
                            ctx.beginPath();
                            ctx.arc(cs.x, cs.y, sp(6), 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(16, 185, 129, 0.2)';
                            ctx.fill();
                            ctx.strokeStyle = '#059669';
                            ctx.lineWidth = sp(1);
                            ctx.stroke();

                            // Inner dot
                            ctx.beginPath();
                            ctx.arc(cs.x, cs.y, sp(2), 0, Math.PI * 2);
                            ctx.fillStyle = '#059669';
                            ctx.fill();
                        });

                        // --- Draw Flow Arrows (tagLayout coords are already in screen-projected space) ---
                        tagLayout.forEach(tag => {
                            const cm = s2c(tag.midX, tag.midY);

                            ctx.save();
                            ctx.translate(cm.x, cm.y);
                            ctx.rotate(tag.angle);

                            const arrSize = sp(4);
                            ctx.beginPath();
                            ctx.moveTo(-arrSize, -arrSize * 1.5);
                            ctx.lineTo(arrSize, 0);
                            ctx.lineTo(-arrSize, arrSize * 1.5);
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = sp(1);
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            ctx.stroke();

                            ctx.restore();
                        });

                        // --- Draw Tags ---
                        if (showTags) {
                            tagLayout.forEach(tag => {
                                const ct = s2c(tag.tagX, tag.tagY);

                                const texts = [];
                                if (tagPrefs.showSize) {
                                    texts.push({ text: `${tag.res.size}"`, color: '#1e293b', fontSize: 11 });
                                }
                                if (tagPrefs.showLength) {
                                    texts.push({ text: `${safeFixed(tag.res.lengthM, 1)}m`, color: '#1e293b', fontSize: 11 });
                                }
                                if (tagPrefs.showFlow) {
                                    texts.push({ text: `${safeFixed(tag.res.flow, 1)}`, color: '#4338ca', fontSize: 11 });
                                }
                                if (tagPrefs.showPressure) {
                                    texts.push({ text: `${safeFixed(tag.res.pressure, 1)}`, color: '#dc2626', fontSize: 11 });
                                }

                                const lineH = sp(12);
                                const startYTag = ct.y - ((texts.length - 1) * lineH) / 2;

                                texts.forEach((t, idx) => {
                                    const textX = ct.x;
                                    const textY = startYTag + idx * lineH;

                                    ctx.font = `${sp(t.fontSize)}px 'Segoe UI', sans-serif`;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';

                                    // White outline for readability
                                    ctx.strokeStyle = '#ffffff';
                                    ctx.lineWidth = sp(3);
                                    ctx.strokeText(t.text, textX, textY);

                                    ctx.fillStyle = t.color;
                                    ctx.fillText(t.text, textX, textY);
                                });
                            });
                        }

                        // --- Download ---
                        ctx.restore(); // End title offset

                        // --- Draw Title Header (on top of everything) ---
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, canvasW, TITLE_H);

                        const viewLabel = viewMode === 'iso' ? 'ISOMETRIC' : '2D';
                        const titleMain = `HYDRAULIC CALCULATION ${viewLabel}`;

                        const activeLabels = [];
                        if (showTags && results && results.length > 0) {
                            if (tagPrefs.showSize) activeLabels.push('PIPE SIZE');
                            if (tagPrefs.showLength) activeLabels.push('LENGTH');
                            if (tagPrefs.showFlow) activeLabels.push('FLOW RATE');
                            if (tagPrefs.showPressure) activeLabels.push('PRESSURE');
                        }
                        const tagSuffix = activeLabels.length > 0 ? '  -  ' + activeLabels.join(' / ') : '';

                        // Top black line
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(RES * 20, RES * 10, canvasW - RES * 40, RES * 2);

                        // Title text
                        const titleFontSize = 18 * RES;
                        ctx.font = `bold ${titleFontSize}px 'Segoe UI', Arial, sans-serif`;

                        // Main title (black)
                        ctx.fillStyle = '#000000';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        const mainWidth = ctx.measureText(titleMain).width;
                        ctx.fillText(titleMain, RES * 20, RES * 18);

                        // Tag suffix (red)
                        if (tagSuffix) {
                            ctx.fillStyle = '#dc2626';
                            ctx.fillText(tagSuffix, RES * 20 + mainWidth, RES * 18);
                        }

                        // Bottom black line
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(RES * 20, TITLE_H - RES * 10, canvasW - RES * 40, RES * 2);

                        const link = document.createElement('a');
                        link.download = `hydraulic_capture_${Date.now()}.png`;
                        link.href = canvas.toDataURL('image/png', 1.0);
                        link.click();
                    };

                    // If 2D and background image exists, load it first
                    if (pdfUrl && viewMode !== 'iso') {
                        const img = new window.Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = () => {
                            const c0 = w2c(0, 0);
                            ctx.globalAlpha = 0.8;
                            ctx.drawImage(img, c0.x, c0.y, img.naturalWidth * transform.scale * RES, img.naturalHeight * transform.scale * RES);
                            ctx.globalAlpha = 1.0;
                            drawContent();
                        };
                        img.onerror = () => {
                            drawContent();
                        };
                        img.src = pdfUrl;
                    } else {
                        drawContent();
                    }
                } catch (err) {
                    console.error("Capture error", err);
                    alert("Error capturing image: " + err.message);
                }
            };

            const handleCaptureToReport = () => {
                try {
                    const container = containerRef.current;
                    if (!container) return;

                    const RES = 2;
                    const containerW = container.clientWidth;
                    const containerH = container.clientHeight;
                    const TITLE_H = 60 * RES;

                    const canvasW = containerW * RES;
                    const canvasH = containerH * RES + TITLE_H;

                    const canvas = document.createElement('canvas');
                    canvas.width = canvasW;
                    canvas.height = canvasH;
                    const ctx = canvas.getContext('2d');

                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvasW, canvasH);

                    ctx.save();
                    ctx.translate(0, TITLE_H);

                    const toScreen = (x, y) => {
                        if (viewMode !== 'iso') return { x, y };
                        const rad = (isoAngle * Math.PI) / 180;
                        const cosA = Math.cos(rad);
                        const sinA = Math.sin(rad);
                        return {
                            x: x * cosA + y * sinA,
                            y: (-x * sinA + y * cosA) * 0.5
                        };
                    };

                    const w2c = (wx, wy) => {
                        const s = toScreen(wx, wy);
                        return {
                            x: (s.x * transform.scale + transform.x) * RES,
                            y: (s.y * transform.scale + transform.y) * RES
                        };
                    };

                    const s2c = (sx, sy) => ({
                        x: (sx * transform.scale + transform.x) * RES,
                        y: (sy * transform.scale + transform.y) * RES
                    });

                    const sp = (v) => v * RES;

                    const isoMapLocal = {};
                    visualNodes.forEach(n => {
                        if (n.isoOffset) isoMapLocal[n.id] = n.isoOffset;
                    });

                    const finishCapture = () => {
                        // Draw pipes
                        const LINE_W = sp(3);
                        drawnPipes.forEach(pipe => {
                            const spec = pipeSpecs.find(s => s.nominal === pipe.size) || pipeSpecs[0];
                            let px1 = pipe.start.x, py1 = pipe.start.y;
                            let px2 = pipe.end.x, py2 = pipe.end.y;

                            if (viewMode === 'iso') {
                                const kS = `${pipe.start.x.toFixed(4)},${pipe.start.y.toFixed(4)}`;
                                const kE = `${pipe.end.x.toFixed(4)},${pipe.end.y.toFixed(4)}`;
                                const oS = isoMapLocal[kS] || { x: 0, y: 0 };
                                const oE = isoMapLocal[kE] || { x: 0, y: 0 };
                                px1 += oS.x; py1 += oS.y;
                                px2 += oE.x; py2 += oE.y;

                                if (pipe.isVertical) {
                                    const p1_up_x = pipe.start.x + oS.x + (oE.x - oS.x);
                                    const p1_up_y = pipe.start.y + oS.y + (oE.y - oS.y);
                                    const c1 = w2c(px1, py1);
                                    const c2 = w2c(p1_up_x, p1_up_y);
                                    const c3 = w2c(px2, py2);
                                    ctx.beginPath();
                                    ctx.moveTo(c1.x, c1.y); ctx.lineTo(c2.x, c2.y); ctx.lineTo(c3.x, c3.y);
                                    ctx.strokeStyle = spec.color; ctx.lineWidth = LINE_W;
                                    ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.setLineDash([]); ctx.stroke();
                                    const midC = { x: (c1.x + c2.x) / 2, y: (c1.y + c2.y) / 2 };
                                    ctx.font = `bold ${sp(11)}px 'Segoe UI', sans-serif`;
                                    ctx.fillStyle = '#ea580c'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = sp(3);
                                    ctx.strokeText(`(V) ${pipe.verticalHeight} m.`, midC.x, midC.y - sp(4));
                                    ctx.fillText(`(V) ${pipe.verticalHeight} m.`, midC.x, midC.y - sp(4));
                                    return;
                                }
                            } else {
                                if (pipe.isVertical) return;
                            }

                            const c1 = w2c(px1, py1);
                            const c2 = w2c(px2, py2);
                            ctx.beginPath(); ctx.moveTo(c1.x, c1.y); ctx.lineTo(c2.x, c2.y);
                            ctx.strokeStyle = spec.color; ctx.lineWidth = LINE_W;
                            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.setLineDash([]); ctx.stroke();

                            // Draw Equipment/Valve on this pipe
                            placedEquipments.filter(e => e.pipeId === pipe.id || (!e.pipeId && distanceToSegment(e, pipe.start, pipe.end) < 5)).forEach(eq => {
                                const dx = pipe.end.x - pipe.start.x;
                                const dy = pipe.end.y - pipe.start.y;
                                const len2 = dx * dx + dy * dy;
                                const t = len2 === 0 ? 0 : ((eq.x - pipe.start.x) * dx + (eq.y - pipe.start.y) * dy) / len2;
                                const ex = px1 + t * (px2 - px1);
                                const ey = py1 + t * (py2 - py1);
                                const ce = w2c(ex, ey);

                                const rw = sp(24);
                                const rh = sp(16);
                                const rx = sp(3);
                                ctx.fillStyle = spec.color;
                                ctx.strokeStyle = '#ffffff';
                                ctx.lineWidth = sp(1);
                                const rectX = ce.x - rw / 2;
                                const rectY = ce.y - rh / 2;
                                ctx.beginPath();
                                ctx.roundRect(rectX, rectY, rw, rh, rx);
                                ctx.fill();
                                ctx.stroke();

                                ctx.fillStyle = getContrastColor(spec.color);
                                ctx.font = `bold ${sp(9)}px 'Segoe UI', sans-serif`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(eq.type, ce.x, ce.y);
                            });
                        });

                        // Draw nodes
                        visualNodes.forEach(node => {
                            if (viewMode !== 'iso' && node.isVPipeBottom) return;
                            const isSource = node.id === sourceNodeId;
                            let nx = viewMode === 'iso' && node.isoOffset ? node.x + node.isoOffset.x : node.x;
                            let ny = viewMode === 'iso' && node.isoOffset ? node.y + node.isoOffset.y : node.y;
                            const cn = w2c(nx, ny);
                            const r = sp(isSource ? 3.5 : 1.8);
                            ctx.beginPath(); ctx.arc(cn.x, cn.y, r, 0, Math.PI * 2);
                            ctx.fillStyle = '#ffffff'; ctx.fill();
                            ctx.strokeStyle = isSource ? '#ef4444' : '#94a3b8'; ctx.lineWidth = sp(1.2); ctx.stroke();
                            ctx.font = `bold ${sp(isSource ? 11 : 9)}px 'Segoe UI', sans-serif`;
                            ctx.fillStyle = isSource ? '#ef4444' : '#64748b';
                            ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
                            const labelText = isSource ? `#${node.displayId} (S)` : `#${node.displayId}`;
                            ctx.strokeStyle = '#ffffff'; ctx.lineWidth = sp(3);
                            ctx.strokeText(labelText, cn.x + sp(isSource ? 5 : 3), cn.y - sp(isSource ? 5 : 3));
                            ctx.fillText(labelText, cn.x + sp(isSource ? 5 : 3), cn.y - sp(isSource ? 5 : 3));
                        });

                        // Draw sprinklers
                        placedSprinklers.forEach(s => {
                            let nx = s.x, ny = s.y;
                            if (viewMode === 'iso') {
                                const k = `${nx.toFixed(4)},${ny.toFixed(4)}`;
                                const off = isoMapLocal[k] || { x: 0, y: 0 };
                                nx += off.x; ny += off.y;
                            }
                            const cs = w2c(nx, ny);
                            ctx.beginPath(); ctx.arc(cs.x, cs.y, sp(6), 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(16, 185, 129, 0.2)'; ctx.fill();
                            ctx.strokeStyle = '#059669'; ctx.lineWidth = sp(1); ctx.stroke();
                            ctx.beginPath(); ctx.arc(cs.x, cs.y, sp(2), 0, Math.PI * 2);
                            ctx.fillStyle = '#059669'; ctx.fill();
                        });

                        // Draw flow arrows
                        tagLayout.forEach(tag => {
                            const cm = s2c(tag.midX, tag.midY);
                            ctx.save(); ctx.translate(cm.x, cm.y); ctx.rotate(tag.angle);
                            const arrSize = sp(4);
                            ctx.beginPath(); ctx.moveTo(-arrSize, -arrSize * 1.5); ctx.lineTo(arrSize, 0); ctx.lineTo(-arrSize, arrSize * 1.5);
                            ctx.strokeStyle = '#000000'; ctx.lineWidth = sp(1); ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.stroke();
                            ctx.restore();
                        });

                        // Draw tags
                        if (showTags) {
                            tagLayout.forEach(tag => {
                                const ct = s2c(tag.tagX, tag.tagY);
                                const texts = [];
                                if (tagPrefs.showSize) texts.push({ text: `${tag.res.size}"`, color: '#1e293b', fontSize: 11 });
                                if (tagPrefs.showLength) texts.push({ text: `${safeFixed(tag.res.lengthM, 1)}m`, color: '#1e293b', fontSize: 11 });
                                if (tagPrefs.showFlow) texts.push({ text: `${safeFixed(tag.res.flow, 1)}`, color: '#4338ca', fontSize: 11 });
                                if (tagPrefs.showPressure) texts.push({ text: `${safeFixed(tag.res.pressure, 1)}`, color: '#dc2626', fontSize: 11 });
                                const lineH = sp(12);
                                const startYTag = ct.y - ((texts.length - 1) * lineH) / 2;
                                texts.forEach((t, idx) => {
                                    const textX = ct.x;
                                    const textY = startYTag + idx * lineH;
                                    ctx.font = `${sp(t.fontSize)}px 'Segoe UI', sans-serif`;
                                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = sp(3);
                                    ctx.strokeText(t.text, textX, textY);
                                    ctx.fillStyle = t.color; ctx.fillText(t.text, textX, textY);
                                });
                            });
                        }

                        // Restore and draw title
                        ctx.restore();

                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, canvasW, TITLE_H);
                        const viewLabel = viewMode === 'iso' ? 'ISOMETRIC' : '2D';
                        const titleMain = `HYDRAULIC CALCULATION ${viewLabel}`;
                        const activeLabels = [];
                        if (showTags && results && results.length > 0) {
                            if (tagPrefs.showSize) activeLabels.push('PIPE SIZE');
                            if (tagPrefs.showLength) activeLabels.push('LENGTH');
                            if (tagPrefs.showFlow) activeLabels.push('FLOW RATE');
                            if (tagPrefs.showPressure) activeLabels.push('PRESSURE');
                        }
                        const tagSuffix = activeLabels.length > 0 ? '  -  ' + activeLabels.join(' / ') : '';
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(RES * 20, RES * 10, canvasW - RES * 40, RES * 2);
                        const titleFontSize = 18 * RES;
                        ctx.font = `bold ${titleFontSize}px 'Segoe UI', Arial, sans-serif`;
                        ctx.fillStyle = '#000000'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                        const mainWidth = ctx.measureText(titleMain).width;
                        ctx.fillText(titleMain, RES * 20, RES * 18);
                        if (tagSuffix) {
                            ctx.fillStyle = '#dc2626';
                            ctx.fillText(tagSuffix, RES * 20 + mainWidth, RES * 18);
                        }
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(RES * 20, TITLE_H - RES * 10, canvasW - RES * 40, RES * 2);

                        // Store in reportImages
                        const dataUrl = canvas.toDataURL('image/png', 1.0);
                        const label = `${titleMain}${tagSuffix}`;
                        setReportImages(prev => [...prev, { dataUrl, label, id: Date.now() }]);
                        alert('Captured to Report successfully!');
                    };

                    if (pdfUrl && viewMode !== 'iso') {
                        const img = new window.Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = () => {
                            const c0 = w2c(0, 0);
                            ctx.globalAlpha = 0.8;
                            ctx.drawImage(img, c0.x, c0.y, img.naturalWidth * transform.scale * RES, img.naturalHeight * transform.scale * RES);
                            ctx.globalAlpha = 1.0;
                            finishCapture();
                        };
                        img.onerror = () => finishCapture();
                        img.src = pdfUrl;
                    } else {
                        finishCapture();
                    }
                } catch (err) {
                    console.error('Capture to report error', err);
                    alert('Error: ' + err.message);
                }
            };

            const toggleIsoView = () => {
                if (!containerRef.current) return;
                const rect = containerRef.current.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                const rawX = (centerX - transform.x) / transform.scale;
                const rawY = (centerY - transform.y) / transform.scale;

                let canvasCx, canvasCy;
                if (viewMode === 'iso') {
                    const y_unscaled = rawY / 0.5;
                    const rad = (isoAngle * Math.PI) / 180;
                    const cosA = Math.cos(rad);
                    const sinA = Math.sin(rad);
                    canvasCx = rawX * cosA - y_unscaled * sinA;
                    canvasCy = rawX * sinA + y_unscaled * cosA;
                } else {
                    canvasCx = rawX;
                    canvasCy = rawY;
                }

                const nextMode = viewMode === 'iso' ? '2d' : 'iso';
                setViewMode(nextMode);

                let newRawX, newRawY;
                if (nextMode === 'iso') {
                    const rad = (isoAngle * Math.PI) / 180;
                    const cosA = Math.cos(rad);
                    const sinA = Math.sin(rad);
                    newRawX = canvasCx * cosA + canvasCy * sinA;
                    newRawY = (-canvasCx * sinA + canvasCy * cosA) * 0.5;
                } else {
                    newRawX = canvasCx;
                    newRawY = canvasCy;
                }

                setTransform(prev => ({
                    ...prev,
                    x: centerX - newRawX * prev.scale,
                    y: centerY - newRawY * prev.scale
                }));
            };

            const handleChangeIsoAngle = (newAngle) => {
                if (newAngle === isoAngle) return;
                pendingIsoZoomFit.current = true;
                setIsoAngle(newAngle);
            };

            const calculateLoss = (Q, L_ft, d_in, C) => {
                if (Q <= 0 || L_ft <= 0) return 0;
                // Hazen-Williams Formula for Friction Loss
                return (4.52 * Math.pow(Q, 1.85) * L_ft) / (Math.pow(C, 1.85) * Math.pow(d_in, 4.87));
            };

            const handleCalculate = () => {
                try {
                    if (!pixelsPerMeter) {
                        alert("กรุณากำหนดสเกล (Set Scale) ก่อนคำนวณ");
                        return;
                    }
                    if (drawnPipes.length === 0) {
                        alert("กรุณาวาดท่ออย่างน้อย 1 เส้น");
                        return;
                    }

                    const M_TO_FT = 3.28084;
                    const K = Number(kFactor) || 5.6;
                    const C = Number(cFactor) || 120;
                    const RISER_NIPPLE_FT = 0.1 * M_TO_FT;
                    const NIPPLE_ID = 1.049;
                    const density = Number(designDensity) || 0.10;
                    const areaFt2 = Number(areaPerHead) || 130;

                    // Initial Requirements (Most Remote Head)
                    const qMinHead = density * areaFt2;
                    const minP_Req = Math.pow(qMinHead / K, 2);
                    const startPressureReq = Math.max(7, minP_Req);

                    const nodes = {};
                    const coordToDisplayId = {};
                    const getKey = (pt) => `${pt.x.toFixed(4)},${pt.y.toFixed(4)}`;

                    visualNodes.forEach(node => {
                        coordToDisplayId[node.id] = node.displayId;
                    });

                    const getOrCreateNode = (pt) => {
                        const key = getKey(pt);
                        if (!nodes[key]) nodes[key] = { id: key, x: pt.x, y: pt.y, connections: [], heads: [] };
                        return nodes[key];
                    };

                    drawnPipes.forEach(p => {
                        const n1 = getOrCreateNode(p.start);
                        const n2 = getOrCreateNode(p.end);
                        if (p.isVertical) {
                            n2.isVPipeBottom = true;
                        }
                        const spec = pipeSpecs.find(s => s.nominal === p.size) || pipeSpecs[0];
                        const uDisp = coordToDisplayId[getKey(p.start)];
                        const vDisp = coordToDisplayId[getKey(p.end)];

                        const edge = {
                            id: p.id,
                            u: n1.id,
                            v: n2.id,
                            u_disp: uDisp,
                            v_disp: vDisp,
                            pipe: p,
                            size: p.size,
                            heads: [],
                            d_in: spec.internal,
                            len_ft: p.isVertical ? (Math.abs(parseFloat(p.verticalHeight)) * M_TO_FT) : ((p.pixelLength / pixelsPerMeter) * M_TO_FT),
                            flow: 0,
                            loss: 0,
                            velocity: 0,
                            flowDir: null,
                            isVertical: p.isVertical,
                            verticalHeight: p.verticalHeight,
                            fittingLen: 0,
                            fittings: []
                        };

                        placedEquipments.forEach(eq => {
                            const eqTolerance = Math.max(15, 0.5 * pixelsPerMeter);
                            if (distanceToSegment(eq, p.start, p.end) < eqTolerance) {
                                const fitData = nfpaData.fittings.find(f => f.code === eq.type);
                                if (fitData) {
                                    const eqValStr = fitData.values[p.size];
                                    const eqVal = eqValStr === "-" ? 0 : parseFloat(eqValStr || 0);
                                    if (eqVal > 0) {
                                        edge.fittingLen += eqVal;
                                        edge.fittings.push(`1 ${fitData.code} (${eqVal} ft)`);
                                    } else {
                                        edge.fittings.push(`1 ${fitData.code} (N/A)`);
                                    }
                                }
                            }
                        });

                        n1.connections.push({ target: n2.id, edge });
                        n2.connections.push({ target: n1.id, edge });
                    });

                    // INCREASED TOLERANCE: Fixed world-distance to ensure zoom level doesn't affect results
                    const tolerance = Math.max(25, 1.0 * pixelsPerMeter);
                    const qPerHead = density * areaFt2;

                    placedSprinklers.forEach(s => {
                        for (const key in nodes) {
                            const node = nodes[key];
                            const dist = Math.sqrt(Math.pow(s.x - node.x, 2) + Math.pow(s.y - node.y, 2));
                            if (dist < tolerance) {
                                node.heads.push(s);
                                // node.demandQ += qPerHead; // Fixed Flow not used in 2-Pass Pressure logic
                                break;
                            }
                        }
                    });

                    // Logic to find Source Node (same as useEffect)
                    let sourceId = sourceNodeId;
                    const allNodes = Object.values(nodes);

                    if (!sourceId || !nodes[sourceId]) {
                        if (allNodes.length > 0) {
                            const candidates = [...allNodes];
                            candidates.sort((a, b) => {
                                const maxA = a.connections.reduce((m, c) => Math.max(m, parseFloat(c.edge.size)), 0);
                                const maxB = b.connections.reduce((m, c) => Math.max(m, parseFloat(c.edge.size)), 0);
                                if (maxB !== maxA) return maxB - maxA;
                                const degA = a.connections.length === 1 ? 1 : 0;
                                const degB = b.connections.length === 1 ? 1 : 0;
                                if (degA !== degB) return degB - degA;
                                if (Math.abs(a.x - b.x) > 1) return a.x - b.x;
                                return a.y - b.y;
                            });
                            sourceId = candidates[0].id;
                            // Update the state so the red dot matches
                            setSourceNodeId(sourceId);
                        }
                    }

                    if (!sourceId) {
                        alert("ไม่สามารถหาจุดต้นทาง (Source Node) ได้ กรุณาลองวาดท่อใหม่");
                        return;
                    }

                    // --- Auto-Detect Fittings (Elbows/Tees) ---
                    allNodes.forEach(node => {
                        if (node.connections.length === 2) {
                            const conn1 = node.connections[0];
                            const conn2 = node.connections[1];
                            const p1 = conn1.edge.pipe;
                            const p2 = conn2.edge.pipe;

                            const getVec = (pipe, centerNode) => {
                                // Simplified ID check to avoid float issues
                                const kStart = getKey(pipe.start);
                                const kEnd = getKey(pipe.end);
                                if (kStart === centerNode.id) {
                                    return { x: pipe.end.x - pipe.start.x, y: pipe.end.y - pipe.start.y };
                                } else {
                                    return { x: pipe.start.x - pipe.end.x, y: pipe.start.y - pipe.end.y };
                                }
                            };
                            const v1 = getVec(p1, node);
                            const v2 = getVec(p2, node);

                            const dot = v1.x * v2.x + v1.y * v2.y;
                            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);

                            if (mag1 > 0 && mag2 > 0) {
                                const angleRad = Math.acos(dot / (mag1 * mag2));
                                const angleDeg = angleRad * (180 / Math.PI);

                                if (Math.abs(angleDeg - 90) < 15) {
                                    let targetEdge = null;
                                    if (conn1.edge.size === conn2.edge.size) {
                                        targetEdge = (conn1.edge.id < conn2.edge.id) ? conn1.edge : conn2.edge;
                                    } else {
                                        targetEdge = (parseFloat(conn1.edge.size) > parseFloat(conn2.edge.size)) ? conn1.edge : conn2.edge;
                                    }
                                    const standElbow = nfpaData.fittings.find(f => f.code === "SE");
                                    const eqValue = standElbow ? (standElbow.values[targetEdge.size] || 0) : 0;
                                    if (eqValue > 0) {
                                        targetEdge.fittingLen += eqValue;
                                        targetEdge.fittings.push(`1 Elbow (${eqValue} ft)`);
                                    }
                                }
                            }
                        } else if (node.connections.length === 3) {
                            let maxConn = node.connections[0];
                            node.connections.forEach(c => {
                                if (parseFloat(c.edge.size) > parseFloat(maxConn.edge.size)) maxConn = c;
                            });
                            const teeFit = nfpaData.fittings.find(f => f.code === "TT");
                            const eqValue = teeFit ? (teeFit.values[maxConn.edge.size] || 0) : 0;
                            if (eqValue > 0) {
                                maxConn.edge.fittingLen += eqValue;
                                maxConn.edge.fittings.push(`1 Tee (${eqValue} ft)`);
                            }
                        }
                    });

                    // To handle loops properly, we calculate a discrete harmonic potential (Laplace solver).
                    // This creates a smooth gradient where fluid naturally flows from V=1.0 (Source) to V=0.0 (Sinks/Dead Ends).
                    const potentialMap = {};
                    const isSink = {};
                    let hasSinks = false;

                    Object.keys(nodes).forEach(n => {
                        potentialMap[n] = 0.5; // Initial guess
                        const isSprinkler = nodes[n].heads && nodes[n].heads.length > 0;
                        const isDeadEnd = nodes[n].connections && nodes[n].connections.length === 1 && String(n) !== String(sourceId);

                        // We anchor the field at extremities to ensure water flows completely outwards!
                        if (isSprinkler || isDeadEnd) {
                            isSink[n] = true;
                            // DON'T lock it at 0.0, it will be handled as an implicit ground edge in the integrator
                            hasSinks = true;
                        } else {
                            isSink[n] = false;
                        }
                    });

                    // Source is highest potential
                    potentialMap[sourceId] = 1.0;

                    // If user literally drew a perfect circle with nothing attached, pick an arbitrary far node to pull water
                    if (!hasSinks) {
                        const allIds = Object.keys(nodes);
                        const arbDest = allIds[allIds.length - 1];
                        if (arbDest && String(arbDest) !== String(sourceId)) {
                            isSink[arbDest] = true;
                            hasSinks = true;
                        }
                    }

                    if (hasSinks) {
                        // Iteratively solve the discrete Laplace equation (Jacobi method)
                        for (let iter = 0; iter < 1000; iter++) {
                            const newPotentials = { ...potentialMap };
                            Object.keys(nodes).forEach(uId => {
                                // Source acts as a fixed boundary condition at 1.0
                                if (uId === String(sourceId)) return;

                                const uNode = nodes[uId];
                                if (uNode && uNode.connections && uNode.connections.length > 0) {
                                    let sum = 0;
                                    uNode.connections.forEach(conn => {
                                        sum += (potentialMap[conn.target] !== undefined ? potentialMap[conn.target] : 0.5);
                                    });

                                    let divisors = uNode.connections.length;

                                    // Sinks act as leakages to ground, naturally pulling the gradient outwards!
                                    // If we fixed them strictly at 0.0, multiple adjacent sprinklers would all be flat 0.0.
                                    if (isSink[uId]) {
                                        sum += 0.0;
                                        divisors += 0.5; // Grounding weight
                                    }

                                    newPotentials[uId] = sum / divisors;
                                }
                            });
                            // Apply updates
                            Object.keys(newPotentials).forEach(k => { potentialMap[k] = newPotentials[k]; });
                        }
                    }

                    // Initialize empty parents arrays
                    const parentMap = {};
                    const childConnectionsMap = {};
                    Object.keys(nodes).forEach(n => {
                        parentMap[n] = { parents: [] };
                        childConnectionsMap[n] = [];
                    });

                    const inDegree = {};
                    Object.keys(nodes).forEach(n => { inDegree[n] = 0; });

                    // 2. Direct edges from higher potential to lower potential
                    Object.keys(nodes).forEach(uId => {
                        const uNode = nodes[uId];
                        if (!uNode || !uNode.connections) return;

                        const vU = potentialMap[uId] !== undefined ? potentialMap[uId] : 0;

                        uNode.connections.forEach(conn => {
                            const targetId = conn.target;
                            const vTarget = potentialMap[targetId] !== undefined ? potentialMap[targetId] : 0;

                            let parent = null;
                            let child = null;

                            // Proper DAG logic based on pseudo-pressure
                            if (vU - vTarget > 1e-12) {
                                parent = uId; child = targetId;
                            } else if (vTarget - vU > 1e-12) {
                                parent = targetId; child = uId;
                            } else {
                                // Numerical tie breaker for exact identical symmetries
                                if (String(uId) < String(targetId)) {
                                    parent = uId; child = targetId;
                                } else {
                                    parent = targetId; child = uId;
                                }
                            }

                            // Avoid duplicate edge registration
                            const edgeExists = parentMap[child]?.parents?.some(p => p.edge.id === conn.edge.id);
                            if (!edgeExists && parentMap[child]) {
                                parentMap[child].parents.push({ parentId: parent, edge: conn.edge });
                                childConnectionsMap[parent].push({ targetId: child, edge: conn.edge });
                                inDegree[child] = (inDegree[child] || 0) + 1;
                            }
                        });
                    });

                    // 3. Topological Sort to get robust processing order
                    const processingOrder = [];
                    const topoQueue = [];
                    Object.keys(nodes).forEach(n => {
                        // Only process nodes that are actually connected/reachable
                        if (inDegree[n] === 0 && potentialMap[n] !== undefined) {
                            topoQueue.push(n);
                        }
                    });

                    while (topoQueue.length > 0) {
                        const curr = topoQueue.shift();
                        processingOrder.push(curr);

                        // Decrease in-degree of all children
                        const cNode = nodes[curr];
                        if (cNode && cNode.connections) {
                            cNode.connections.forEach(conn => {
                                const tId = conn.target;
                                // Is this a valid child according to parentMap?
                                if (parentMap[tId] && parentMap[tId].parents) {
                                    const isValidChild = parentMap[tId].parents.some(p => p.parentId === curr && p.edge.id === conn.edge.id);
                                    if (isValidChild) {
                                        inDegree[tId] -= 1;
                                        if (inDegree[tId] <= 0) {
                                            topoQueue.push(tId);
                                        }
                                    }
                                }
                            });
                        }
                    }

                    // Pre-calculate Global Upstream Equivalent Resistance to ensure perfectly balanced loop splits
                    const nodeReqR = {};
                    nodeReqR[sourceId] = 0;

                    processingOrder.forEach(uId => {
                        if (String(uId) === String(sourceId)) {
                            nodeReqR[uId] = 0;
                            return;
                        }

                        const myParents = parentMap[uId]?.parents || [];
                        if (myParents.length > 0) {
                            let totalAdmittance = 0;
                            myParents.forEach(p => {
                                const parentId = p.parentId;
                                const pEdge = p.edge;
                                const pReqR = nodeReqR[parentId] !== undefined ? nodeReqR[parentId] : 0;
                                const edgeR = (pEdge.len_ft + pEdge.fittingLen) / Math.pow(pEdge.d_in, 4.87);
                                const totalPathR = pReqR + edgeR;
                                if (totalPathR > 0) {
                                    totalAdmittance += Math.pow(1 / totalPathR, 0.54);
                                }
                            });
                            if (totalAdmittance > 0) {
                                nodeReqR[uId] = Math.pow(1 / totalAdmittance, 1 / 0.54);
                            } else {
                                nodeReqR[uId] = 99999;
                            }
                        }
                    });

                    const nodeReqP = {};
                    const nodeTotalQ = {};
                    const nodeActualP = {};
                    const nodeHeadFlow = {};

                    Object.keys(nodes).forEach(k => {
                        nodeReqP[k] = 0;
                        nodeTotalQ[k] = 0;
                        nodeActualP[k] = 0;
                    });

                    const tempReport = {};

                    // Pass 1
                    for (let i = processingOrder.length - 1; i >= 0; i--) {
                        const uId = processingOrder[i];
                        let maxP_RequiredAtU = 0;
                        let totalQ_AtU = 0;

                        const uNode = nodes[uId];
                        if (!uNode) continue;

                        // Identify all children of this node uId.
                        // Rather than using `filter` which might fail on complex topologies, 
                        // we use the precomputed `childConnectionsMap`
                        const childConnections = childConnectionsMap[uId] || [];

                        // Process downstream connections first to properly accumulate required pressure and flow before heads
                        childConnections.forEach(child => {
                            const vId = child.targetId;
                            const edge = child.edge;

                            const fullChildReqQ = nodeTotalQ[vId] || 0;
                            const incomingParentsToChild = parentMap[vId]?.parents || [];

                            let portionOfChildFlow = 0;

                            // Splitting logic: flow is split according to the GLOBAL admittance 
                            // (1 / R_PathTotal^0.54) of the ENTIRE network path from the source.
                            if (incomingParentsToChild.length > 0) {
                                let totalAdmittance = 0;
                                let myAdmittance = 0;

                                incomingParentsToChild.forEach(p => {
                                    const parentId = p.parentId;
                                    const pEdge = p.edge;
                                    const pReqR = nodeReqR[parentId] || 0;
                                    const hwR = (pEdge.len_ft + pEdge.fittingLen) / Math.pow(pEdge.d_in, 4.87);

                                    // Total True Equivalent Path Resistance (avoid division by zero)
                                    const fullPathR = Math.max(1e-6, pReqR + hwR);

                                    const adm = Math.pow(1 / fullPathR, 0.54);
                                    totalAdmittance += adm;

                                    if (pEdge.id === edge.id) {
                                        myAdmittance = adm;
                                    }
                                });

                                if (totalAdmittance > 0) {
                                    portionOfChildFlow = fullChildReqQ * (myAdmittance / totalAdmittance);
                                } else {
                                    portionOfChildFlow = fullChildReqQ / incomingParentsToChild.length;
                                }
                            } else {
                                portionOfChildFlow = fullChildReqQ;
                            }

                            let qBranch = portionOfChildFlow;

                            // The highest required upstream pressure determines nodeReqP
                            const pChildReq = nodeReqP[vId] || 0;

                            const totalLen = edge.len_ft + edge.fittingLen;
                            let lossBase = calculateLoss(qBranch, totalLen, edge.d_in, C);
                            if (edge.isVertical) {
                                const elevDiff = (vId === edge.v) ? parseFloat(edge.verticalHeight) : -parseFloat(edge.verticalHeight);
                                lossBase += elevDiff * M_TO_FT * 0.433; // Add Elevation Pressure
                            }

                            // *** CRITICAL FIX: Base internal pipe pressure properly accumulates downstream path reqs ***
                            const pBranchTotalReq = pChildReq + lossBase;
                            maxP_RequiredAtU = Math.max(maxP_RequiredAtU, pBranchTotalReq);

                            edge.flow = qBranch;
                            edge.loss = lossBase;
                            const velocityFps = (0.4085 * qBranch) / Math.pow(edge.d_in, 2);
                            edge.velocity = velocityFps * 0.3048;
                            edge.flowDir = (edge.u === uId) ? 'u->v' : 'v->u';

                            totalQ_AtU += qBranch;

                            tempReport[edge.id] = {
                                pipeId: edge.id,
                                id: `Pipe ${edge.size}"${incomingParentsToChild.length > 1 ? ` (Loop Branch)` : ''}${edge.isVertical ? ' (แนวดิ่ง)' : ''}`,
                                size: edge.size,
                                lengthM: edge.isVertical ? Math.abs(parseFloat(edge.verticalHeight)) : (edge.len_ft / M_TO_FT),
                                flow: qBranch,
                                loss: edge.loss,
                                pressure: 0,
                                velocity: edge.velocity,
                                flowDir: edge.flowDir || 'N/A',
                                nodes: edge.flowDir === 'u->v'
                                    ? `#${edge.u_disp}-#${edge.v_disp}`
                                    : `#${edge.v_disp}-#${edge.u_disp}`,
                                isSourcePipe: (edge.u === sourceId || edge.v === sourceId),
                                headFlow: nodeHeadFlow[vId] || 0,
                                fittings: edge.fittings.join(", "),
                                eqLen: edge.fittingLen / M_TO_FT
                            };
                        });

                        // Head logic requires we know the required upstream pressure (maxP_RequiredAtU) FIRST!
                        if (uNode.heads.length > 0) {
                            let pMinHead = startPressureReq;
                            let qHead = K * Math.sqrt(pMinHead);
                            let lossNip = calculateLoss(qHead, RISER_NIPPLE_FT, NIPPLE_ID, C);
                            let pReqAtNodeForHead = pMinHead + lossNip;
                            maxP_RequiredAtU = Math.max(maxP_RequiredAtU, pReqAtNodeForHead);

                            let headFlowSum = 0;
                            uNode.heads.forEach(() => {
                                let pHeadEst = maxP_RequiredAtU;
                                for (let k = 0; k < 2; k++) {
                                    let q = K * Math.sqrt(pHeadEst > lossNip ? pHeadEst - lossNip : 0);
                                    let loss = calculateLoss(q, RISER_NIPPLE_FT, NIPPLE_ID, C);
                                    pHeadEst = maxP_RequiredAtU - loss;
                                }
                                if (pHeadEst < 0) pHeadEst = 0;
                                const q = K * Math.sqrt(pHeadEst);
                                totalQ_AtU += q;
                                headFlowSum += q;
                            });
                            nodeHeadFlow[uId] = headFlowSum;
                        }

                        nodeReqP[uId] = maxP_RequiredAtU;
                        nodeTotalQ[uId] = totalQ_AtU;
                    }

                    // Pass 2
                    nodeActualP[sourceId] = nodeReqP[sourceId];
                    const forwardQueue = [sourceId];
                    const forwardVisited = new Set([sourceId]);

                    while (forwardQueue.length > 0) {
                        const uId = forwardQueue.shift();
                        const currentP = nodeActualP[uId];
                        const uNode = nodes[uId];

                        const childConnections = uNode.connections.filter(conn => {
                            const targetParents = parentMap[conn.target]?.parents || [];
                            return targetParents.some(p => p.parentId === uId && p.edge.id === conn.edge.id);
                        });

                        childConnections.forEach(child => {
                            const vId = child.target;
                            const edge = child.edge;
                            if (tempReport[edge.id]) {
                                // Provide equal pressure to both parts of the loop converging
                                tempReport[edge.id].pressure = Math.max(tempReport[edge.id].pressure || 0, currentP);
                            }
                            const nextP = currentP - edge.loss;
                            // Only update node actual pressure if it hasn't been set, or set to worst case scenarios
                            nodeActualP[vId] = nodeActualP[vId] ? Math.max(nodeActualP[vId], nextP) : nextP;

                            if (!forwardVisited.has(edge.id)) {
                                forwardVisited.add(edge.id);
                            }
                            // Only add the node to the queue if ALL its parents have been resolved.
                            // This ensures node pressures align perfectly after all loops converge.
                            let allParentsProcessed = true;
                            const myParents = parentMap[vId]?.parents || [];
                            myParents.forEach(p => {
                                if (!forwardVisited.has(p.edge.id)) allParentsProcessed = false;
                            });

                            if (allParentsProcessed && !forwardQueue.includes(vId)) {
                                forwardQueue.push(vId);
                            }
                        });
                    }

                    const finalResults = Object.values(tempReport).reverse();
                    setResults(finalResults);

                    const finalTotalFlow = nodeTotalQ[sourceId] || 0;
                    const finalPressure = nodeReqP[sourceId] || 0;

                    setTotalDemand({ flow: finalTotalFlow, pressure: finalPressure });

                } catch (err) {
                    console.error("Calculation Error:", err);
                    alert("เกิดข้อผิดพลาดในการคำนวณ (Calculation Error): " + err.message + "\n\n" + (err.stack ? err.stack.substring(0, 300) : ""));
                }
            };

            const lineIntersectsRect = (x1, y1, x2, y2, rx, ry, rw, rh) => {
                const left = rx, right = rx + rw, top = ry, bottom = ry + rh;
                const minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
                if (maxX < left || minX > right || maxY < top || minY > bottom) return false;

                const intersect = (p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) => {
                    const det = (p2x - p1x) * (p4y - p3y) - (p4x - p3x) * (p2y - p1y);
                    if (det === 0) return false;
                    const lambda = ((p4y - p3y) * (p4x - p1x) + (p3x - p4x) * (p4y - p1y)) / det;
                    const gamma = ((p1y - p2y) * (p4x - p1x) + (p2x - p1x) * (p4y - p1y)) / det;
                    return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
                };

                if (intersect(x1, y1, x2, y2, left, top, right, top)) return true;
                if (intersect(x1, y1, x2, y2, right, top, right, bottom)) return true;
                if (intersect(x1, y1, x2, y2, right, bottom, left, bottom)) return true;
                if (intersect(x1, y1, x2, y2, left, bottom, left, top)) return true;

                if (x1 > left && x1 < right && y1 > top && y1 < bottom) return true;
                return false;
            };

            const tagLayout = React.useMemo(() => {
                const getTagLayout = () => {
                    if (!results || results.length === 0) return [];

                    const toScreen = (x, y) => {
                        if (viewMode !== 'iso') return { x, y };
                        const rad = (isoAngle * Math.PI) / 180;
                        const cosA = Math.cos(rad);
                        const sinA = Math.sin(rad);
                        return {
                            x: x * cosA + y * sinA,
                            y: (-x * sinA + y * cosA) * 0.5
                        };
                    };

                    const layout = [];

                    drawnPipes.forEach(pipe => {
                        const res = results.find(r => r.pipeId === pipe.id);
                        if (!res) return;

                        let startX = pipe.start.x, startY = pipe.start.y;
                        let endX = pipe.end.x, endY = pipe.end.y;

                        if (viewMode === 'iso') {
                            const kStart = `${startX.toFixed(4)},${startY.toFixed(4)}`;
                            const kEnd = `${endX.toFixed(4)},${endY.toFixed(4)}`;
                            const offStart = visualNodes.find(n => n.id === kStart)?.isoOffset || { x: 0, y: 0 };
                            const offEnd = visualNodes.find(n => n.id === kEnd)?.isoOffset || { x: 0, y: 0 };
                            if (pipe.isVertical) {
                                endX = startX + offEnd.x;
                                endY = startY + offEnd.y;
                                startX += offStart.x;
                                startY += offStart.y;
                            } else {
                                startX += offStart.x;
                                startY += offStart.y;
                                endX += offEnd.x;
                                endY += offEnd.y;
                            }
                        }

                        const ptS = toScreen(startX, startY);
                        const ptE = toScreen(endX, endY);
                        startX = ptS.x; startY = ptS.y;
                        endX = ptE.x; endY = ptE.y;

                        let midX = (startX + endX) / 2;
                        let midY = (startY + endY) / 2;

                        let arrowAngle = 0;
                        if (res.flowDir === 'v->u') {
                            arrowAngle = Math.atan2(startY - endY, startX - endX);
                        } else {
                            arrowAngle = Math.atan2(endY - startY, endX - startX);
                        }

                        // Calculate offset vector strictly perpendicular to the pipe
                        const dx = endX - startX;
                        const dy = endY - startY;

                        let nx = 0;
                        let ny = 0;

                        if (viewMode === 'iso') {
                            let adx = dx;
                            let ady = dy;
                            // Normalize direction to always point upwards for angle consistency
                            if (ady > 0 || (ady === 0 && adx < 0)) {
                                adx = -adx;
                                ady = -ady;
                            }
                            const angleDeg = Math.atan2(ady, adx) * 180 / Math.PI;

                            if (angleDeg > -75 && angleDeg < -15) {
                                nx = -0.707; ny = -0.707; // Up-Right pipe -> Push Top-Left
                            } else if (angleDeg < -105 && angleDeg > -165) {
                                nx = 0.707; ny = -0.707; // Up-Left pipe -> Push Top-Right
                            } else if (angleDeg >= -105 && angleDeg <= -75) {
                                nx = 1; ny = 0; // Vertical pipe -> Push Right
                            } else {
                                nx = 0; ny = -1; // Horizontal -> Push Up
                            }
                        } else {
                            const len = Math.sqrt(dx * dx + dy * dy);
                            const ux = len > 0 ? dx / len : 0;
                            const uy = len > 0 ? dy / len : 0;

                            // Normal vector (perpendicular)
                            nx = -uy;
                            ny = ux;

                            // Push text to the left or top to be consistent conventionally
                            if (nx > 0.01 || (Math.abs(nx) <= 0.01 && ny > 0)) {
                                nx = -nx;
                                ny = -ny;
                            }
                        }

                        let activeRows = 0;
                        if (tagPrefs.showSize) activeRows++;
                        if (tagPrefs.showLength) activeRows++;
                        if (tagPrefs.showFlow) activeRows++;
                        if (tagPrefs.showPressure) activeRows++;

                        const rowHeight = 12;
                        const halfHeight = (activeRows * rowHeight) / 2;

                        let approxWidth = 40;
                        const halfWidth = approxWidth / 2;

                        const gap = viewMode === 'iso' ? 2 : 5; // Tighter gap in Iso mode
                        const requiredClearance = Math.abs(nx) * halfWidth + Math.abs(ny) * halfHeight;
                        const offsetDist = (requiredClearance + gap) / transform.scale;

                        layout.push({
                            id: pipe.id,
                            tagX: midX + nx * offsetDist,
                            tagY: midY + ny * offsetDist,
                            anchorX: midX,
                            anchorY: midY,
                            midX: midX,
                            midY: midY,
                            res, angle: arrowAngle
                        });
                    });

                    return layout;
                };

                return getTagLayout();
            }, [results, transform.scale, viewMode, visualNodes, placedSprinklers, drawnPipes, tagPrefs, isoAngle]);

            // Login Overlay
            if (!accessLevel) {
                return (
                    <div style={{
                        position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh',
                        backgroundColor: 'white', zIndex: 2147483647,
                        display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
                        color: '#64748b', fontFamily: 'monospace', gap: '20px'
                    }}>
                        <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#1e293b' }}>HYDRAULIC CALCULATOR</div>
                        <div style={{ fontSize: '12px', color: '#64748b' }}>V.1.5 By วัยรุ่นเซินเจิ้น</div>

                        <div style={{ display: 'flex', flexDirection: 'column', gap: '15px', alignItems: 'center', marginTop: '20px', padding: '20px', border: '1px solid #e2e8f0', borderRadius: '8px' }}>
                            <div style={{ display: 'flex', gap: '10px' }}>
                                <input
                                    type="password"
                                    placeholder="Access Code"
                                    value={unlockCode}
                                    onChange={(e) => setUnlockCode(e.target.value)}
                                    style={{ border: '1px solid #cbd5e1', padding: '5px 10px', borderRadius: '4px', fontSize: '14px' }}
                                />
                                <button
                                    onClick={handleUnlock}
                                    style={{ backgroundColor: '#4f46e5', color: 'white', border: 'none', padding: '5px 15px', borderRadius: '4px', cursor: 'pointer', fontSize: '14px' }}
                                >
                                    Login
                                </button>
                            </div>
                            <div style={{ marginTop: '10px', textAlign: 'center' }}>
                                <button type="button" onClick={() => setShowHint(!showHint)} style={{ fontSize: '12px', color: '#64748b', background: 'none', border: 'none', cursor: 'pointer' }}>
                                    {showHint ? "1234" : "Password Hint"}
                                </button>
                            </div>
                        </div>
                        <div style={{ position: 'fixed', bottom: '20px', right: '20px', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px', backgroundColor: 'white', padding: '12px', borderRadius: '12px', boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)', border: '1px solid #e2e8f0', zIndex: 2147483648 }}>
                            <span style={{ fontSize: '14px', fontWeight: 'bold', color: '#1e293b', fontFamily: 'sans-serif', display: 'flex', alignItems: 'center', gap: '6px' }}>
                                <Coffee size={16} />
                                สนับสนุนค่ากาแฟ
                            </span>
                            <span style={{ fontSize: '12px', color: '#475569', fontFamily: 'sans-serif', fontWeight: 'bold' }}>922-7-006096 (TTB)</span>
                            <img src="data:image/jpeg;base64,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" alt="QR Code" style={{ width: '120px', height: '120px', borderRadius: '8px' }} />
                        </div>
                    </div>
                );
            }

            // High Performance ISO Lookup Map for Render Loops
            const isoMap = {};
            if (viewMode === 'iso') {
                visualNodes.forEach(n => { isoMap[n.id] = n.isoOffset || { x: 0, y: 0 }; });
            }

            return (
                <div className="flex h-screen w-full bg-slate-50 overflow-hidden font-sans select-none print:bg-white print:overflow-visible">
                    <div className="w-80 bg-white border-r border-slate-200 flex flex-col shadow-xl z-20 shrink-0 print:hidden">
                        <div className="px-4 py-3 bg-indigo-900 text-white flex justify-between items-center shrink-0">
                            <div className="flex flex-col">
                                <h1 className="font-bold text-sm flex items-center gap-2">
                                    <Flame size={18} className="text-orange-400" />
                                    Hydraulic Calc
                                </h1>
                                <span className="text-[10px] text-indigo-200 ml-6">V.1.5 By วัยรุ่นเซินเจิ้น</span>
                            </div>

                            {/* Header Buttons Group */}
                            <div className="flex items-center gap-1">
                                <button onClick={() => loadProject()} className="p-1.5 bg-indigo-800 hover:bg-indigo-700 text-white rounded transition-colors" title="Open Project">
                                    <FolderOpen size={14} />
                                </button>

                                {accessLevel === 'full' && (
                                    <>
                                        <button onClick={() => saveProject(false)} className="p-1.5 bg-indigo-800 hover:bg-indigo-700 text-white rounded transition-colors" title="Save">
                                            <Save size={14} />
                                        </button>
                                        <button onClick={() => saveProject(true)} className="p-1.5 bg-indigo-800 hover:bg-indigo-700 text-white rounded transition-colors" title="Save As">
                                            <FilePlus size={14} />
                                        </button>
                                    </>
                                )}

                                {/* Hidden Inputs */}
                                <input type="file" ref={projectInputRef} className="hidden" onChange={handleProjectFileUpload} accept=".json,application/json" />
                            </div>
                        </div>

                        <div className="flex-1 flex flex-col p-2 overflow-y-auto gap-2 custom-scrollbar">
                            <div className="border-b border-slate-200 pb-2">
                                <h3 className="font-bold text-slate-800 text-[9px] flex items-center gap-1 mb-1 uppercase tracking-wider">
                                    <Target size={11} className="text-indigo-600" /> Parameters
                                </h3>
                                <div className="grid grid-cols-2 gap-x-2 gap-y-1 text-[9px]">
                                    <div className="col-span-2">
                                        <select value={selectedHazard} onChange={handleHazardChange} className="w-full p-1 border border-slate-200 rounded bg-slate-50 text-slate-700 text-[9px] outline-none">
                                            {hazardClasses.map(h => <option key={h.id} value={h.id}>{h.label}</option>)}
                                        </select>
                                    </div>
                                    <div className="flex flex-col gap-0">
                                        <label className="text-slate-500 font-bold uppercase text-[7px] tracking-tight">Density (gpm/ft²)</label>
                                        <input type="number" value={designDensity} onChange={e => setDesignDensity(e.target.value)} className="w-full p-1 border border-slate-200 rounded bg-white text-[9px] outline-none" step="0.05" />
                                    </div>
                                    <div className="flex flex-col gap-0">
                                        <label className="text-slate-500 font-bold uppercase text-[7px] tracking-tight">Max Area (ft²)</label>
                                        <input type="number" value={areaPerHead} onChange={e => setAreaPerHead(e.target.value)} className="w-full p-1 border border-slate-200 rounded bg-white text-[9px] outline-none" />
                                    </div>
                                    <div className="flex flex-col gap-0 border-r border-slate-100 pr-2 pb-1">
                                        <label className="text-slate-500 font-bold uppercase text-[7px] tracking-tight">K-Factor</label>
                                        <select
                                            value={kFactor}
                                            onChange={e => setKFactor(Number(e.target.value))}
                                            className="w-full p-1 border border-slate-200 rounded bg-white text-[9px] outline-none"
                                        >
                                            {kFactors.map(k => (
                                                <option key={k} value={k}>{k.toFixed(1)}</option>
                                            ))}
                                        </select>
                                    </div>

                                    <div className="flex flex-col gap-0 pb-1">
                                        <label className="text-slate-500 font-bold uppercase text-[7px] tracking-tight">C-Value</label>
                                        <select
                                            value={cFactor}
                                            onChange={e => setCFactor(Number(e.target.value))}
                                            className="w-full p-1 border border-slate-200 rounded bg-white text-[9px] outline-none"
                                        >
                                            {cFactors.map((c, i) => (
                                                <option key={i} value={c.value}>
                                                    {c.label}
                                                </option>
                                            ))}
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <div className="border-b border-slate-200 pb-2">
                                <h3 className="font-bold text-slate-800 text-[9px] flex items-center gap-1 mb-1 uppercase tracking-wider">
                                    <Ruler size={11} className="text-indigo-600" /> Pipe Size
                                </h3>
                                <div className="grid grid-cols-3 gap-1">
                                    {pipeSpecs.map(spec => (
                                        <button
                                            key={spec.nominal}
                                            onClick={() => setSelectedPipeSize(spec.nominal)}
                                            className={`text-[9px] py-1 border rounded transition-all font-bold flex items-center justify-center gap-1 bg-white ${selectedPipeSize === spec.nominal ? 'border-indigo-600 bg-indigo-50/50' : 'border-slate-100'}`}
                                            style={{ color: spec.color }}
                                        >
                                            <span
                                                className="w-2 h-2 rounded-full"
                                                style={{ backgroundColor: spec.color }}
                                            />
                                            {spec.nominal}"
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <div className="flex flex-col gap-2">
                                {/* View Section */}
                                <div className="border-b border-slate-200 pb-2">
                                    <h3 className="font-bold text-slate-800 text-[9px] flex items-center gap-1 mb-1 uppercase tracking-wider">
                                        <Eye size={11} className="text-indigo-600" /> View
                                    </h3>
                                    <div className="grid grid-cols-2 gap-1.5">
                                        <label className="flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border border-slate-200 bg-white hover:bg-slate-50 cursor-pointer shadow-sm active:scale-95 transition-all text-[9px]">
                                            <input type="file" className="hidden" onChange={handleFileChange} accept="image/*" />
                                            <ImageIcon size={11} className="text-slate-500" /> Floor Plan
                                        </label>
                                        <button onClick={() => setMode('scale')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'scale' ? 'bg-indigo-600 border-indigo-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <Ruler size={11} className={mode === 'scale' ? 'text-white' : 'text-slate-500'} /> Scale
                                        </button>
                                        <button onClick={() => setMode('pan')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'pan' ? 'bg-slate-800 border-slate-800 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <Maximize size={11} className={mode === 'pan' ? 'text-white' : 'text-slate-500'} /> Pan
                                        </button>
                                        <button onClick={() => setShowTags(!showTags)} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${!showTags ? 'bg-slate-200 border-slate-200 text-slate-500' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            {showTags ? <Eye size={11} className="text-slate-500" /> : <EyeOff size={11} className="text-slate-400" />} Tags
                                        </button>
                                        <button onClick={toggleIsoView} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${viewMode === 'iso' ? 'bg-fuchsia-600 border-fuchsia-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <Box size={11} className={viewMode === 'iso' ? 'text-white' : 'text-fuchsia-600'} /> Iso
                                        </button>
                                    </div>
                                    {viewMode === 'iso' && (
                                        <div className="mt-1.5 flex flex-col gap-1 border border-slate-200 rounded p-1 bg-slate-50">
                                            <div className="flex justify-between items-center px-1 mb-0.5">
                                                <span className="text-[8px] font-bold text-slate-500 uppercase">Iso Angle</span>
                                                <span className="text-[8px] font-bold text-fuchsia-600">{isoAngle}°</span>
                                            </div>
                                            <div className="grid grid-cols-4 gap-1">
                                                {[45, 135, 225, 315].map(angle => (
                                                    <button
                                                        key={angle}
                                                        onClick={() => handleChangeIsoAngle(angle)}
                                                        className={`text-[8px] py-1 rounded border shadow-sm transition-all text-center ${isoAngle === angle ? 'bg-fuchsia-600 text-white border-fuchsia-600 font-bold' : 'bg-white text-slate-500 border-slate-200 hover:bg-slate-100'}`}
                                                    >
                                                        {angle}°
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                    {showTags && (
                                        <div className="grid grid-cols-4 gap-1 mt-1.5">
                                            <button onClick={() => setTagPrefs(p => ({ ...p, showSize: !p.showSize }))} className={`text-[8px] py-1 rounded border shadow-sm transition-all text-center ${tagPrefs.showSize ? 'bg-slate-700 text-white border-slate-700' : 'bg-white text-slate-500 border-slate-200'}`}>Size</button>
                                            <button onClick={() => setTagPrefs(p => ({ ...p, showLength: !p.showLength }))} className={`text-[8px] py-1 rounded border shadow-sm transition-all text-center ${tagPrefs.showLength ? 'bg-slate-700 text-white border-slate-700' : 'bg-white text-slate-500 border-slate-200'}`}>Len</button>
                                            <button onClick={() => setTagPrefs(p => ({ ...p, showFlow: !p.showFlow }))} className={`text-[8px] py-1 rounded border shadow-sm transition-all text-center ${tagPrefs.showFlow ? 'bg-indigo-700 text-white border-indigo-700' : 'bg-white text-slate-500 border-slate-200'}`}>Flow</button>
                                            <button onClick={() => setTagPrefs(p => ({ ...p, showPressure: !p.showPressure }))} className={`text-[8px] py-1 rounded border shadow-sm transition-all text-center ${tagPrefs.showPressure ? 'bg-red-600 text-white border-red-600' : 'bg-white text-slate-500 border-slate-200'}`}>Pres</button>
                                        </div>
                                    )}
                                </div>



                                {/* Draw Section */}
                                <div className="border-b border-slate-200 pb-2">
                                    <h3 className="font-bold text-slate-800 text-[9px] flex items-center gap-1 mb-1 uppercase tracking-wider">
                                        <Edit3 size={11} className="text-indigo-600" /> Draw
                                    </h3>
                                    <div className="grid grid-cols-2 gap-1.5">
                                        <button onClick={() => setMode('sprinkler')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'sprinkler' ? 'bg-emerald-600 border-emerald-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <Droplets size={11} className={mode === 'sprinkler' ? 'text-white' : 'text-emerald-600'} /> Head
                                        </button>
                                        <button onClick={() => setMode('draw')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'draw' ? 'bg-blue-600 border-blue-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <Plus size={11} className={mode === 'draw' ? 'text-white' : 'text-blue-600'} /> Pipe
                                        </button>
                                        <button onClick={() => setMode('draw_vertical')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'draw_vertical' ? 'bg-orange-600 border-orange-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <ArrowUpDown size={11} className={mode === 'draw_vertical' ? 'text-white' : 'text-orange-600'} /> V-Pipe
                                        </button>
                                        <button onClick={() => setMode('auto_sprinkler')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'auto_sprinkler' ? 'bg-violet-600 border-violet-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <LayoutGrid size={11} className={mode === 'auto_sprinkler' ? 'text-white' : 'text-violet-600'} /> Auto Grid
                                        </button>
                                        <button onClick={() => setMode('delete')} className={`flex items-center justify-center gap-1.5 px-1 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] ${mode === 'delete' ? 'bg-red-600 border-red-600 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                            <Trash2 size={11} className={mode === 'delete' ? 'text-white' : 'text-red-500'} /> Delete
                                        </button>
                                    </div>
                                    <div className="grid grid-cols-4 gap-1.5 mt-1.5">
                                        {['BV', 'GV', 'FS', 'CV'].map(eqType => (
                                            <button key={eqType} onClick={() => setMode(`eq_${eqType}`)} className={`flex items-center justify-center gap-1.5 px-0.5 py-1.5 rounded border transition-all shadow-sm active:scale-95 text-[9px] font-bold ${mode === `eq_${eqType}` ? 'bg-amber-500 border-amber-500 text-white' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                                                {eqType}
                                            </button>
                                        ))}
                                    </div>
                                    {mode === 'auto_sprinkler' && (
                                        <div className="flex bg-indigo-50 px-1 py-1 rounded border border-indigo-100 gap-1.5 mt-1 text-[8px] text-indigo-700 justify-center items-center">
                                            <Info size={10} />
                                            <span className="font-medium tracking-tight">Drag area on drawing</span>
                                        </div>
                                    )}
                                </div>



                                {/* Actions Section */}
                                <div className="pb-1 border-t border-slate-100 pt-2">
                                    <div className="grid grid-cols-2 gap-1.5 mb-2">
                                        <button onClick={handleUndo} disabled={historyIndex <= 0} className="flex items-center justify-center gap-1 px-1 py-1 rounded border border-slate-200 bg-white text-slate-600 shadow-sm disabled:opacity-40 text-[9px] hover:bg-slate-50 transition-all active:scale-95" title="Undo">
                                            <RotateCcw size={10} /> Undo
                                        </button>
                                        <button onClick={handleRedo} disabled={historyIndex >= history.length - 1} className="flex items-center justify-center gap-1 px-1 py-1 rounded border border-slate-200 bg-white text-slate-600 shadow-sm disabled:opacity-40 text-[9px] hover:bg-slate-50 transition-all active:scale-95" title="Redo">
                                            <RotateCw size={10} /> Redo
                                        </button>
                                    </div>

                                    {/* Hydraulic Results - Moved Below Undo */}
                                    {totalDemand.flow > 0 && (
                                        <div className="bg-gradient-to-br from-indigo-50 to-slate-50 p-1.5 mb-2 rounded border border-indigo-100 shadow-sm space-y-1">
                                            <div className="flex justify-between items-center px-1">
                                                <span className="text-[8px] font-bold text-slate-400 uppercase tracking-widest">Total Flow</span>
                                                <div className="text-right flex items-baseline gap-1">
                                                    <span className="text-sm font-black text-indigo-700">{safeFixed(totalDemand.flow, 1)}</span>
                                                    <span className="text-[7px] text-indigo-400 font-bold uppercase">GPM</span>
                                                </div>
                                            </div>
                                            <div className="h-px bg-slate-200/60 mx-1"></div>
                                            <div className="flex justify-between items-center px-1">
                                                <span className="text-[8px] font-bold text-slate-400 uppercase tracking-widest">Max Pressure</span>
                                                <div className="text-right flex items-baseline gap-1">
                                                    <span className="text-sm font-black text-rose-600">{safeFixed(totalDemand.pressure, 1)}</span>
                                                    <span className="text-[7px] text-rose-400 font-bold uppercase">PSI</span>
                                                </div>
                                            </div>
                                        </div>
                                    )}


                                </div>
                            </div>
                        </div>




                    </div>






                    {/* Main Canvas Area */}
                    <div
                        className={`flex-1 relative bg-white overflow-hidden canvas-grid print:hidden ${mode === 'pan'
                            ? 'cursor-move'
                            : 'cursor-crosshair'
                            }`}
                        ref={containerRef}
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onClick={handleCanvasClick}
                        onDoubleClick={handleCanvasDoubleClick}
                        onWheel={(e) => adjustZoom(e.deltaY > 0 ? -1 : 1)}
                    >
                        <div
                            id="top-controls-overlay"
                            className="absolute top-4 left-4 z-10 flex flex-col items-start gap-2"
                            onMouseDown={e => e.stopPropagation()}
                            onMouseUp={e => e.stopPropagation()}
                            onClick={e => e.stopPropagation()}
                            onDoubleClick={e => e.stopPropagation()}
                        >
                            <div className="flex items-center gap-2">
                                <div className="bg-white/95 backdrop-blur-sm px-3 py-1.5 rounded-full border border-slate-200 shadow-sm text-[10px] text-slate-600 flex items-center gap-2">
                                    <span className="flex items-center gap-1"><Info size={12} /> Mode: <span className="font-bold uppercase text-slate-900">{mode}</span></span>
                                    <span className="w-px h-3 bg-slate-200"></span>
                                    <span className="font-medium">Scale: {pixelsPerMeter ? `${pixelsPerMeter.toFixed(2)} px/m` : 'Not Set'}</span>
                                </div>

                                <div className="bg-white/95 backdrop-blur-sm px-3 py-1 rounded-full border border-slate-200 shadow-sm text-[10px] text-slate-600 flex items-center gap-2">
                                    <span className="font-bold uppercase text-slate-700">Project Name:</span>
                                    <input type="text" value={projectName} onChange={e => setProjectName(e.target.value)} className="bg-slate-50 border border-slate-200 rounded px-2 py-0.5 outline-none w-32 focus:border-indigo-400 focus:bg-white transition-colors" placeholder="ระบุชื่อโครงการ" />
                                    <span className="w-px h-3 bg-slate-200 mx-1"></span>
                                    <span className="font-bold uppercase text-slate-700">Sampling Area:</span>
                                    <input type="text" value={samplingArea} onChange={e => setSamplingArea(e.target.value)} className="bg-slate-50 border border-slate-200 rounded px-2 py-0.5 outline-none w-32 focus:border-indigo-400 focus:bg-white transition-colors" placeholder="ระบุ Sampling Area" />
                                </div>
                            </div>

                            <div className="flex items-center gap-2">
                                <button
                                    onClick={handleCalculate}
                                    className="h-7 px-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-full text-[10px] flex items-center gap-2 font-bold transition-all active:scale-95 uppercase tracking-wider shadow-sm"
                                >
                                    <Calculator size={13} /> CALCULATE
                                </button>

                                <button
                                    onClick={() => setShowReport(true)}
                                    className="h-7 w-8 bg-emerald-600 hover:bg-emerald-700 text-white rounded-full flex items-center justify-center transition-all active:scale-95 shadow-sm"
                                    title="View Report"
                                >
                                    <FileText size={14} />
                                </button>
                            </div>
                        </div>

                        {/* Zoom Controls */}
                        <div id="zoom-controls-overlay" className="absolute bottom-6 right-6 z-10 flex flex-col gap-2">
                            <button onClick={handleZoomAllCenter} title="Zoom Fit All" className="p-2 bg-white rounded-full shadow-lg hover:bg-slate-50 text-indigo-700 transition-transform active:scale-90 flex items-center justify-center border border-slate-100"><Target size={16} /></button>
                            <button onClick={handleCaptureImage} title="Capture Image" className="p-2 bg-white rounded-full shadow-lg hover:bg-slate-50 text-emerald-700 transition-transform active:scale-90 flex items-center justify-center border border-slate-100"><ImageIcon size={16} /></button>
                            <button onClick={handleCaptureToReport} title="Capture to Report" className="p-2 bg-white rounded-full shadow-lg hover:bg-slate-50 text-orange-600 transition-transform active:scale-90 flex items-center justify-center border border-slate-100"><FileText size={16} /></button>
                            <div className="w-full h-px bg-slate-200 my-0.5"></div>
                            <button onClick={() => adjustZoom(1)} title="Zoom In" className="p-2 bg-white rounded-full shadow-lg hover:bg-slate-50 text-slate-700 transition-transform active:scale-90 border border-slate-100"><ZoomIn size={16} /></button>
                            <button onClick={() => adjustZoom(-1)} title="Zoom Out" className="p-2 bg-white rounded-full shadow-lg hover:bg-slate-50 text-slate-700 transition-transform active:scale-90 border border-slate-100"><ZoomOut size={16} /></button>
                        </div>

                        {/* Transform Container */}
                        <div
                            style={{
                                transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale}) ${viewMode === 'iso' ? `rotateX(60deg) rotateZ(-${isoAngle}deg)` : ''}`,
                                transformOrigin: '0 0',
                                width: '100%', height: '100%',
                                pointerEvents: 'none'
                            }}
                        >
                            {/* Background Image */}
                            {pdfUrl && viewMode !== 'iso' && <img src={pdfUrl} className="absolute top-0 left-0 opacity-80" style={{ maxWidth: 'none', pointerEvents: 'none' }} />}

                            <svg className="absolute top-0 left-0 overflow-visible" style={{ width: '1px', height: '1px' }}>
                                {/* Pipe Alignment Guide (Orange Dashed Line on Pipe) */}
                                {pipeAlignmentGuide && (
                                    <g>
                                        <line
                                            x1={pipeAlignmentGuide.p1.x} y1={pipeAlignmentGuide.p1.y}
                                            x2={pipeAlignmentGuide.p2.x} y2={pipeAlignmentGuide.p2.y}
                                            stroke="#f97316" // Orange 500
                                            strokeWidth={1.5 / transform.scale}
                                            strokeDasharray={`${6 / transform.scale},${3 / transform.scale}`}
                                            opacity={0.8}
                                        />
                                        {/* Midpoint Triangle Indicator REMOVED as requested */}
                                    </g>
                                )}

                                {/* Alignment Guides (Red Crosshair) - Changed from Pink to Red */}
                                {alignmentLines.map((line, i) => (
                                    <line
                                        key={i}
                                        x1={line.x1} y1={line.y1}
                                        x2={line.x2} y2={line.y2}
                                        stroke="#ef4444"
                                        strokeWidth={1 / transform.scale}
                                        strokeDasharray={`${4 / transform.scale},${4 / transform.scale}`}
                                        opacity={0.8}
                                    />
                                ))}

                                {/* Sprinkler Distance Guide (Green Dashed) */}
                                {sprinklerDistanceGuide && (
                                    <g>
                                        <line
                                            x1={sprinklerDistanceGuide.start.x} y1={sprinklerDistanceGuide.start.y}
                                            x2={sprinklerDistanceGuide.end.x} y2={sprinklerDistanceGuide.end.y}
                                            stroke="#10b981"
                                            strokeWidth={1 / transform.scale}
                                            strokeDasharray={`${4 / transform.scale},${2 / transform.scale}`}
                                            opacity={0.8}
                                        />
                                        <text
                                            x={(sprinklerDistanceGuide.start.x + sprinklerDistanceGuide.end.x) / 2}
                                            y={(sprinklerDistanceGuide.start.y + sprinklerDistanceGuide.end.y) / 2 - 10 / transform.scale}
                                            textAnchor="middle"
                                            fontSize={10 / transform.scale}
                                            fill="#10b981"
                                            fontWeight="bold"
                                            style={{
                                                textShadow: '0px 0px 4px rgba(255,255,255,0.8)',
                                                pointerEvents: 'none'
                                            }}
                                        >
                                            {sprinklerDistanceGuide.text}
                                        </text>
                                    </g>
                                )}

                                {tempRect && (() => {
                                    const x = Math.min(tempRect.start.x, tempRect.end.x);
                                    const y = Math.min(tempRect.start.y, tempRect.end.y);
                                    const w = Math.abs(tempRect.end.x - tempRect.start.x);
                                    const h = Math.abs(tempRect.end.y - tempRect.start.y);

                                    // Calculate Area
                                    const areaText = pixelsPerMeter
                                        ? `${((w / pixelsPerMeter) * (h / pixelsPerMeter)).toFixed(2)} m²`
                                        : `${Math.round(w * h)} px²`;

                                    return (
                                        <g>
                                            <rect
                                                x={x}
                                                y={y}
                                                width={w}
                                                height={h}
                                                fill="rgba(139, 92, 246, 0.1)"
                                                stroke="#8b5cf6"
                                                strokeWidth={2 / transform.scale}
                                                strokeDasharray="5,5"
                                            />
                                            <text
                                                x={x + w / 2}
                                                y={y + h / 2}
                                                textAnchor="middle"
                                                dominantBaseline="central"
                                                fontSize={14 / transform.scale}
                                                fill="#6d28d9"
                                                fontWeight="bold"
                                                style={{
                                                    textShadow: '0px 0px 4px rgba(255,255,255,1), 0px 0px 2px rgba(255,255,255,1)',
                                                    pointerEvents: 'none',
                                                    userSelect: 'none'
                                                }}
                                            >
                                                {areaText}
                                            </text>
                                        </g>
                                    );
                                })()}

                                {/* Lasso Removed */}

                                {/* Drawn Pipes - Reverted to Single Line */}
                                {(() => {
                                    try {
                                        return drawnPipes.map(pipe => {
                                            const spec = pipeSpecs.find(s => s.nominal === pipe.size) || pipeSpecs[0];

                                            let px1 = Number(pipe.start?.x) || 0;
                                            let py1 = Number(pipe.start?.y) || 0;
                                            let px2 = Number(pipe.end?.x) || 0;
                                            let py2 = Number(pipe.end?.y) || 0;
                                            let pathD = "";
                                            let midX = (px1 + px2) / 2;
                                            let midY = (py1 + py2) / 2;

                                            if (viewMode === 'iso') {
                                                const kS = `${px1.toFixed(4)},${py1.toFixed(4)}`;
                                                const kE = `${px2.toFixed(4)},${py2.toFixed(4)}`;
                                                const oS = isoMap[kS] || { x: 0, y: 0 };
                                                const oE = isoMap[kE] || { x: 0, y: 0 };
                                                px1 += oS.x; py1 += oS.y;
                                                px2 += oE.x; py2 += oE.y;

                                                if (pipe.isVertical) {
                                                    // The vertical Z difference is mathematically simply the difference generated by BFS offsets.
                                                    // `oS` is cumulative Z at start, `oE` is cumulative Z at end.
                                                    // Vector `(oE.x - oS.x, oE.y - oS.y)` directly represents perfectly vertical elevation shift.
                                                    // By moving `px1` up/down by this EXACT shift, we complete the vertical pipe portion. 
                                                    // Then a flat horizontal tracer bridges the 2D layout gap.
                                                    let p1_up_x = px1 + (oE.x - oS.x);
                                                    let p1_up_y = py1 + (oE.y - oS.y);
                                                    pathD = `M ${px1} ${py1} L ${p1_up_x} ${p1_up_y} L ${px2} ${py2}`;
                                                    midX = (px1 + p1_up_x) / 2;
                                                    midY = (py1 + p1_up_y) / 2;
                                                } else {
                                                    pathD = `M ${px1} ${py1} L ${px2} ${py2}`;
                                                }
                                            } else {
                                                if (pipe.isVertical) {
                                                    pathD = ""; // Hide the vertical line in 2D view
                                                } else {
                                                    pathD = `M ${px1} ${py1} L ${px2} ${py2}`;
                                                }
                                            }

                                            return (
                                                <g key={pipe.id}>
                                                    <path
                                                        d={pathD}
                                                        stroke={spec.color}
                                                        strokeWidth={3 / transform.scale}
                                                        strokeLinecap="round"
                                                        strokeLinejoin="round"
                                                        fill="none"
                                                        strokeDasharray={pipe.isVertical && viewMode !== 'iso' ? `${10 / transform.scale},${6 / transform.scale}` : ""}
                                                    />
                                                    {pipe.isVertical && (
                                                        <text
                                                            x={midX}
                                                            y={midY - 8 / transform.scale}
                                                            textAnchor="middle"
                                                            fontSize={11 / transform.scale}
                                                            fill="#ea580c"
                                                            fontWeight="bold"
                                                            style={{ textShadow: '1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff' }}
                                                        >
                                                            (V) {pipe.verticalHeight} m.
                                                        </text>
                                                    )}

                                                    {/* Equipments on Pipe */}
                                                    {placedEquipments.filter(e => e.pipeId === pipe.id || (!e.pipeId && distanceToSegment(e, pipe.start, pipe.end) < 5)).map(eq => {
                                                        const dx = pipe.end.x - pipe.start.x;
                                                        const dy = pipe.end.y - pipe.start.y;
                                                        const len2 = dx * dx + dy * dy;
                                                        const t = len2 === 0 ? 0 : ((eq.x - pipe.start.x) * dx + (eq.y - pipe.start.y) * dy) / len2;
                                                        const ex = px1 + t * (px2 - px1);
                                                        const ey = py1 + t * (py2 - py1);
                                                        return (
                                                            <g key={`eq-${eq.id}`} className="cursor-pointer">
                                                                <rect x={ex - 12 / transform.scale} y={ey - 8 / transform.scale} rx={3 / transform.scale} width={24 / transform.scale} height={16 / transform.scale} fill={spec.color} stroke="#ffffff" strokeWidth={1 / transform.scale} />
                                                                <text x={ex} y={ey + 0.5 / transform.scale} textAnchor="middle" dominantBaseline="middle" fontSize={9 / transform.scale} fill={getContrastColor(spec.color)} fontWeight="bold" style={{ pointerEvents: 'none' }}>{eq.type}</text>
                                                            </g>
                                                        )
                                                    })}
                                                </g>
                                            );
                                        });
                                    } catch (e) { console.error("Pipe render error", e); return null; }
                                })()}

                                {/* Nodes (Joints) - Dots only, labels moved to unrotated overlay */}
                                {visualNodes.map(node => {
                                    if (viewMode !== 'iso' && node.isVPipeBottom) return null;
                                    const isSource = node.id === sourceNodeId;
                                    const nx = viewMode === 'iso' && node.isoOffset ? node.x + node.isoOffset.x : node.x;
                                    const ny = viewMode === 'iso' && node.isoOffset ? node.y + node.isoOffset.y : node.y;

                                    return (
                                        <g key={node.id} transform={`translate(${nx}, ${ny})`}>
                                            <circle
                                                r={(isSource ? 3.5 : 1.8) / transform.scale}
                                                fill="#ffffff"
                                                stroke={isSource ? "#ef4444" : "#94a3b8"}
                                                strokeWidth={1.2 / transform.scale}
                                            />
                                        </g>
                                    );
                                })}

                                {/* Sprinklers */}
                                {(() => {
                                    try {
                                        return placedSprinklers.map(s => {
                                            let nx = Number(s.x) || 0;
                                            let ny = Number(s.y) || 0;
                                            if (viewMode === 'iso') {
                                                const k = `${nx.toFixed(4)},${ny.toFixed(4)}`;
                                                const off = isoMap[k] || { x: 0, y: 0 };
                                                nx += off.x;
                                                ny += off.y;
                                            }
                                            return (
                                                <g key={s.id} transform={`translate(${nx}, ${ny})`}>
                                                    <circle r={6 / transform.scale} fill="#10b981" fillOpacity="0.2" stroke="#059669" strokeWidth={1 / transform.scale} />
                                                    <circle r={2 / transform.scale} fill="#059669" />
                                                </g>
                                            );
                                        });
                                    } catch (e) { console.error("Sprinkler render error", e); return null; }
                                })()}



                                {/* Temp Pipe (Ghost) */}
                                {tempPipe && (() => {
                                    const dx = tempPipe.end.x - tempPipe.start.x;
                                    const dy = tempPipe.end.y - tempPipe.start.y;
                                    const lenPx = Math.sqrt(dx * dx + dy * dy);
                                    // Modified here: changed toFixed(2) to toFixed(1)
                                    const lenText = pixelsPerMeter
                                        ? `${(lenPx / pixelsPerMeter).toFixed(1)} m.`
                                        : `${Math.round(lenPx)} px`;

                                    // Standard single line width
                                    const w = 3 / transform.scale;

                                    return (
                                        <g>
                                            <line
                                                x1={tempPipe.start.x} y1={tempPipe.start.y}
                                                x2={tempPipe.end.x} y2={tempPipe.end.y}
                                                stroke={pipeSpecs.find(s => s.nominal === tempPipe.size)?.color || 'black'}
                                                strokeWidth={w}
                                                strokeOpacity="0.5"
                                                strokeDasharray="5,5"
                                            />
                                            {/* Distance Label */}
                                            <text
                                                x={(tempPipe.start.x + tempPipe.end.x) / 2}
                                                y={(tempPipe.start.y + tempPipe.end.y) / 2 - 10 / transform.scale}
                                                textAnchor="middle"
                                                fontSize={12 / transform.scale}
                                                fill="#0f172a"
                                                fontWeight="bold"
                                                style={{
                                                    textShadow: '0px 0px 4px rgba(255,255,255,0.8)',
                                                    pointerEvents: 'none'
                                                }}
                                            >
                                                {lenText}
                                            </text>
                                        </g>
                                    );
                                })()}

                                {/* Snap Marker */}
                                {snapPoint && (
                                    <circle
                                        cx={snapPoint.x} cy={snapPoint.y}
                                        r={5 / transform.scale}
                                        fill="none" stroke="#ef4444" strokeWidth={2 / transform.scale}
                                    />
                                )}

                                {/* Scale Line */}
                                {scalePoints.length === 2 && (
                                    <line
                                        x1={scalePoints[0].x} y1={scalePoints[0].y}
                                        x2={scalePoints[1].x} y2={scalePoints[1].y}
                                        stroke="#f00" strokeWidth={2 / transform.scale}
                                    />
                                )}
                            </svg>
                        </div>

                        {/* UNROTATED Overlay for Tags */}
                        <div
                            style={{
                                transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`,
                                transformOrigin: '0 0',
                                width: '100%', height: '100%',
                                pointerEvents: 'none',
                                position: 'absolute',
                                top: 0,
                                left: 0
                            }}
                        >
                            <svg className="absolute top-0 left-0 overflow-visible" style={{ width: '1px', height: '1px' }}>
                                {/* Node Labels (unrotated so always horizontal) */}
                                {visualNodes.map(node => {
                                    if (viewMode !== 'iso' && node.isVPipeBottom) return null;
                                    const isSource = node.id === sourceNodeId;
                                    const nx = viewMode === 'iso' && node.isoOffset ? node.x + node.isoOffset.x : node.x;
                                    const ny = viewMode === 'iso' && node.isoOffset ? node.y + node.isoOffset.y : node.y;

                                    // Convert to screen-projected coords (for iso mode)
                                    let sx = nx, sy = ny;
                                    if (viewMode === 'iso') {
                                        const rad = (isoAngle * Math.PI) / 180;
                                        const cosA = Math.cos(rad);
                                        const sinA = Math.sin(rad);
                                        sx = nx * cosA + ny * sinA;
                                        sy = (-nx * sinA + ny * cosA) * 0.5;
                                    }

                                    return (
                                        <text
                                            key={`node-label-${node.id}`}
                                            x={sx + (isSource ? 5 : 3) / transform.scale}
                                            y={sy + (isSource ? -5 : -3) / transform.scale}
                                            fontSize={(isSource ? 11 : 9) / transform.scale}
                                            fill={isSource ? "#ef4444" : "#64748b"}
                                            fontWeight="bold"
                                            style={{
                                                textShadow: '1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff',
                                                pointerEvents: 'none'
                                            }}
                                        >
                                            {isSource ? `#${node.displayId} (S)` : `#${node.displayId}`}
                                        </text>
                                    );
                                })}
                                {/* Results Tags Flow Arrow ONLY */}
                                {tagLayout.map(tag => (
                                    <React.Fragment key={`arrow-${tag.id}`}>
                                        <g transform={`translate(${tag.midX}, ${tag.midY}) rotate(${tag.angle * 180 / Math.PI})`}>
                                            <path
                                                d={`M ${-4 / transform.scale} ${-6 / transform.scale} L ${4 / transform.scale} 0 L ${-4 / transform.scale} ${6 / transform.scale}`}
                                                stroke="#000000"
                                                strokeWidth={1 / transform.scale}
                                                fill="none"
                                                strokeLinecap="round"
                                                strokeLinejoin="round"
                                                style={{ filter: 'drop-shadow(0px 0px 1px rgba(255,255,255,1))' }}
                                            />
                                        </g>
                                    </React.Fragment>
                                ))}

                                {showTags && tagLayout.map(tag => {
                                    const ptTag = { x: tag.tagX, y: tag.tagY };

                                    const texts = [];
                                    if (tagPrefs.showSize) {
                                        texts.push({ text: `${tag.res.size}"`, color: "#1e293b", fontSize: 11 });
                                    }
                                    if (tagPrefs.showLength) {
                                        texts.push({ text: `${safeFixed(tag.res.lengthM, 1)}m`, color: "#1e293b", fontSize: 11 });
                                    }
                                    if (tagPrefs.showFlow) {
                                        texts.push({ text: `${safeFixed(tag.res.flow, 1)}`, color: "#4338ca", fontSize: 11 });
                                    }
                                    if (tagPrefs.showPressure) {
                                        texts.push({ text: `${safeFixed(tag.res.pressure, 1)}`, color: "#dc2626", fontSize: 11 });
                                    }

                                    const startY = ptTag.y - ((texts.length - 1) * 12 / transform.scale) / 2;

                                    return (
                                        <g key={`tag-${tag.id}`}>
                                            {texts.map((t, idx) => (
                                                <text
                                                    key={idx}
                                                    x={ptTag.x}
                                                    y={startY + (idx * 12 / transform.scale)}
                                                    textAnchor="middle"
                                                    dominantBaseline="middle"
                                                    fill={t.color}
                                                    fontSize={t.fontSize / transform.scale}
                                                    fontWeight="normal"
                                                    style={{
                                                        pointerEvents: 'none',
                                                        textShadow: '1px 1px 0px #fff, -1px -1px 0px #fff, 1px -1px 0px #fff, -1px 1px 0px #fff, 0px 0px 2px #fff'
                                                    }}
                                                >
                                                    {t.text}
                                                </text>
                                            ))}
                                        </g>
                                    );
                                })}
                            </svg>
                        </div>
                    </div>

                    {/* Scale Dialog Modal */}
                    {
                        showScaleDialog && (
                            <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center print:hidden">
                                <div className="bg-white p-6 rounded-lg shadow-2xl w-80 animate-in zoom-in-95">
                                    <h3 className="font-bold text-lg mb-4 flex items-center gap-2">
                                        <Ruler className="text-indigo-600" /> Calibrate Scale
                                    </h3>
                                    <div className="mb-4 bg-slate-50 p-2 rounded text-sm text-slate-600">
                                        <div className="flex justify-between">
                                            <span>Measured Length:</span>
                                            <span className="font-mono font-bold">
                                                {(() => {
                                                    const dx = scalePoints[1].x - scalePoints[0].x;
                                                    const dy = scalePoints[1].y - scalePoints[0].y;
                                                    return Math.sqrt(dx * dx + dy * dy).toFixed(2);
                                                })()} px
                                            </span>
                                        </div>
                                    </div>
                                    <p className="text-sm text-slate-500 mb-2">
                                        Enter Real Distance:
                                    </p>
                                    <div className="flex items-center gap-2 mb-4">
                                        <input
                                            type="number"
                                            autoFocus
                                            placeholder="0.00"
                                            className="w-full p-2 border rounded text-lg"
                                            value={realWorldDist}
                                            onChange={e => setRealWorldDist(e.target.value)}
                                            onKeyDown={e => e.key === 'Enter' && applyScale()}
                                            step="0.01"
                                        />
                                        <span className="text-slate-500 font-medium">m</span>
                                    </div>

                                    {realWorldDist && !isNaN(parseFloat(realWorldDist)) && parseFloat(realWorldDist) > 0 && (
                                        <div className="mb-4 text-xs text-center text-emerald-600 font-medium">
                                            Result: {((Math.sqrt(Math.pow(scalePoints[1].x - scalePoints[0].x, 2) + Math.pow(scalePoints[1].y - scalePoints[0].y, 2))) / parseFloat(realWorldDist)).toFixed(4)} px/m
                                        </div>
                                    )}

                                    <div className="flex justify-end gap-2">
                                        <button onClick={() => { setShowScaleDialog(false); setScalePoints([]); }} className="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded">Cancel</button>
                                        <button onClick={applyScale} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded font-medium">Apply</button>
                                    </div>
                                </div>
                            </div>
                        )
                    }

                    {/* Pipe Size Edit Modal */}
                    {
                        editingPipeId && (
                            <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center print:hidden" onClick={() => setEditingPipeId(null)}>
                                <div className="bg-white p-4 rounded-lg shadow-xl w-64 animate-in zoom-in-95" onClick={e => e.stopPropagation()}>
                                    <h3 className="font-bold text-sm mb-3 text-slate-700 flex items-center gap-2">
                                        <Edit3 size={16} /> Select New Pipe Size
                                    </h3>
                                    <div className="grid grid-cols-3 gap-2">
                                        {pipeSpecs.map(spec => (
                                            <button
                                                key={spec.nominal}
                                                onClick={() => updatePipeSize(spec.nominal)}
                                                className="text-xs py-2 rounded border hover:bg-slate-50 transition-colors font-medium"
                                                style={{ borderColor: spec.color, color: spec.color }}
                                            >
                                                {spec.nominal}"
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )
                    }

                    {/* Report Modal */}
                    {
                        showReport && (
                            // Changed: Added print:items-start to align content to top during print, removing vertical centering
                            <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 print:absolute print:inset-0 print:bg-white print:z-[9999] print:block">
                                <div className="bg-white rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col animate-in zoom-in-95 print:shadow-none print:w-full print:max-w-none print:h-auto print:max-h-none print:rounded-none">
                                    <div className="p-4 border-b flex justify-between items-center bg-gray-50 rounded-t-lg print:hidden">
                                        <h3 className="font-bold text-lg text-gray-800 flex items-center gap-2">
                                            <FileText className="text-blue-600" /> Hydraulic Calculations Sheet
                                        </h3>
                                        <button onClick={() => setShowReport(false)} className="p-1 hover:bg-gray-200 rounded-full transition-colors text-gray-500">
                                            <X size={20} />
                                        </button>
                                    </div>
                                    <div className="p-6 overflow-auto print:p-0 print:overflow-visible">
                                        <div className="mb-4 text-center hidden print:block">
                                            <h2 className="text-xl font-bold uppercase pt-2 mb-2">Hydraulic Calculations Sheet</h2>
                                            {/* Added Parameter Display */}
                                            <div className="flex flex-col gap-y-2 text-xs text-black mt-2 font-mono border-t border-b border-gray-200 py-2">
                                                <div className="flex justify-center flex-wrap gap-x-6 gap-y-2">
                                                    <span><strong>Project Name :</strong> {projectName || "-"}</span>
                                                    <span><strong>Sampling Area :</strong> {samplingArea || "-"}</span>
                                                    <span><strong>Hazard:</strong> {hazardClasses.find(h => h.id === selectedHazard)?.label}</span>
                                                </div>
                                                <div className="flex justify-center flex-wrap gap-x-6 gap-y-2">
                                                    <span><strong>Density:</strong> {designDensity} gpm/ft²</span>
                                                    <span><strong>Area of operation:</strong> {areaOfOperation} ft²</span>
                                                    <span><strong>Area/head:</strong> {areaPerHead} ft²</span>
                                                    <span><strong>K-Factor:</strong> {kFactor}</span>
                                                </div>
                                            </div>
                                        </div>
                                        <table className="w-full text-sm text-left border-collapse">
                                            <thead className="bg-gray-100 font-bold text-gray-700 border-b-2 border-gray-300">
                                                <tr>
                                                    <th className="p-3 border-r border-gray-200">Node</th>
                                                    <th className="p-3 border-r border-gray-200">Flow (gpm)</th>
                                                    {/* Moved Sprinkler Flow to 3rd Column */}
                                                    <th className="p-3 border-r border-gray-200">Sprinkler Flow (gpm)</th>
                                                    <th className="p-3 border-r border-gray-200">Pipe Size (in)</th>
                                                    <th className="p-3 border-r border-gray-200">Length (m)</th>
                                                    <th className="p-3 border-r border-gray-200">Fittings / Eq. Len</th>
                                                    <th className="p-3 border-r border-gray-200">Friction Loss (psi)</th>
                                                    <th className="p-3 border-r border-gray-200">Required Pressure (psi)</th>
                                                    <th className="p-3 print:hidden">
                                                        Velocity (m/s)
                                                        <span className="block text-[10px] font-normal text-gray-500 text-nowrap">&lt; 9.0 m/s</span>
                                                    </th>
                                                </tr>
                                            </thead>
                                            <tbody className="divide-y divide-gray-100">
                                                {results.length > 0 ? (
                                                    results.map((row, i) => (
                                                        <tr key={i} className="hover:bg-gray-50 transition-colors">
                                                            {/* Node Color Logic: Green if has headFlow, else Blue */}
                                                            <td className={`p-3 font-medium border-r border-gray-200 ${row.headFlow > 0 ? 'text-green-600' : 'text-blue-700'}`}>
                                                                {row.nodes}
                                                            </td>
                                                            <td className="p-3 font-bold text-gray-800 border-r border-gray-200">{safeFixed(row.flow, 1)}</td>
                                                            {/* Sprinkler Flow Moved Here */}
                                                            <td className={`p-3 border-r border-gray-200 ${row.headFlow > 0 ? 'text-green-600 font-bold' : 'text-gray-400'}`}>
                                                                {row.headFlow > 0 ? safeFixed(row.headFlow, 1) : '-'}
                                                            </td>
                                                            <td className="p-3 text-gray-600 border-r border-gray-200">{row.size}"</td>
                                                            <td className="p-3 text-gray-600 border-r border-gray-200">{safeFixed(row.lengthM, 1)}</td>
                                                            <td className="p-3 text-xs text-gray-500 border-r border-gray-200">
                                                                {row.fittings ? (
                                                                    <>
                                                                        <div>{row.fittings}</div>
                                                                        <div className="font-bold">+{safeFixed(row.eqLen, 1)} m</div>
                                                                    </>
                                                                ) : '-'}
                                                            </td>
                                                            <td className="p-3 text-gray-600 border-r border-gray-200">{safeFixed(row.loss)}</td>
                                                            <td className="p-3 font-medium text-red-700 border-r border-gray-200">{safeFixed(row.pressure, 1)}</td>
                                                            <td className={`p-3 print:hidden ${row.velocity > 9.0 ? "text-red-600 font-bold" : "text-gray-500"}`}>{safeFixed(row.velocity)}</td>
                                                        </tr>
                                                    ))
                                                ) : (
                                                    <tr>
                                                        <td colSpan="9" className="p-8 text-center text-gray-400 italic">
                                                            No calculation data available. Please draw pipes and calculate first.
                                                        </td>
                                                    </tr>
                                                )}
                                            </tbody>
                                            {results.length > 0 && (
                                                <tfoot className="bg-gray-50 font-bold border-t-2 border-gray-300">
                                                    <tr>
                                                        <td className="p-3 border-r border-gray-200">System Total</td>
                                                        <td className="p-3 text-blue-700 border-r border-gray-200">{safeFixed(totalDemand.flow, 1)}</td>
                                                        {/* Spanning the middle columns (SprinklerFlow, Size, Length, Loss) */}
                                                        <td colSpan="5" className="border-r border-gray-200"></td>
                                                        <td className="p-3 text-red-700 border-r border-gray-200">{safeFixed(totalDemand.pressure, 1)}</td>
                                                        <td className="print:hidden"></td>
                                                    </tr>
                                                </tfoot>
                                            )}
                                        </table>

                                        <div className="hidden print:block print-page-break"></div>

                                        {/* Equivalent Lengths Table Section - USING CENTRALIZED DATA */}
                                        <div className="mt-8 mb-4 break-inside-avoid print:mt-8">
                                            <h3 className="font-bold text-lg text-gray-800 mb-2 border-b pb-2 print:text-base">
                                                Equivalent Schedule 40 Steel Pipe Length Chart
                                            </h3>
                                            <p className="text-xs text-gray-500 mb-2 italic print:text-[10px]">
                                                *Due to the variations in design of swing check valves, the pipe equivalents indicated in the above chart are considered average.
                                            </p>
                                            <div className="overflow-x-auto print:overflow-visible">
                                                <table className="w-full text-xs text-center border-collapse border border-gray-300 print:text-[9px] print:w-full">
                                                    <thead className="bg-gray-100 font-bold text-gray-700">
                                                        <tr>
                                                            <th className="p-2 border border-gray-300 text-left min-w-[150px] print:p-1 print:min-w-0">Fittings</th>
                                                            <th className="p-2 border border-gray-300 print:p-1">Code</th>
                                                            {nfpaData.displaySizes.map(h => (
                                                                <th key={h} className="p-2 border border-gray-300 print:p-1">{h}"</th>
                                                            ))}
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        {nfpaData.fittings.map((row, i) => (
                                                            <tr key={i} className="hover:bg-gray-50">
                                                                <td className="p-2 border border-gray-300 text-left font-medium print:p-1">{row.name}</td>
                                                                <td className="p-2 border border-gray-300 text-gray-500 print:p-1">{row.code}</td>
                                                                {nfpaData.displaySizes.map((size) => (
                                                                    <td key={size} className="p-2 border border-gray-300 print:p-1">
                                                                        {row.values[size] !== undefined ? row.values[size] : "-"}
                                                                    </td>
                                                                ))}
                                                            </tr>
                                                        ))}
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>

                                        {/* Captured Report Images - 2 per page, reorderable */}
                                        {reportImages.length > 0 && (() => {
                                            const moveToPosition = (fromIdx, toPos) => {
                                                const newIdx = Math.max(0, Math.min(toPos - 1, reportImages.length - 1));
                                                if (newIdx === fromIdx) return;
                                                setReportImages(prev => {
                                                    const arr = [...prev];
                                                    const [item] = arr.splice(fromIdx, 1);
                                                    arr.splice(newIdx, 0, item);
                                                    return arr;
                                                });
                                            };

                                            return reportImages.map((img, idx) => (
                                                <React.Fragment key={img.id}>
                                                    {idx % 2 === 0 && <div className="hidden print:block print-page-break"></div>}
                                                    <div className={`break-inside-avoid ${idx % 2 === 0 ? 'mt-6 print:mt-2' : 'mt-4 print:mt-2'}`}>
                                                        <div className="relative group">
                                                            <img src={img.dataUrl} alt={img.label} className="w-full border border-gray-200 rounded print:border-0 print:rounded-none" style={{ maxHeight: '48vh' }} />
                                                            {/* Control bar */}
                                                            <div className="absolute top-2 right-2 flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity print:hidden">
                                                                <button
                                                                    onClick={() => setReportImages(prev => prev.filter(r => r.id !== img.id))}
                                                                    className="p-1 bg-red-500 hover:bg-red-600 text-white rounded-full"
                                                                    title="Remove from report"
                                                                >
                                                                    <X size={14} />
                                                                </button>
                                                            </div>
                                                            {/* Order input badge */}
                                                            <div className="absolute top-2 left-2 flex items-center gap-1 bg-black/70 text-white text-xs px-2 py-1 rounded-full print:hidden">
                                                                <span>Order:</span>
                                                                <input
                                                                    type="number"
                                                                    min={1}
                                                                    max={reportImages.length}
                                                                    defaultValue={idx + 1}
                                                                    key={`${img.id}-${idx}`}
                                                                    onBlur={(e) => {
                                                                        const val = parseInt(e.target.value);
                                                                        if (!isNaN(val)) moveToPosition(idx, val);
                                                                    }}
                                                                    onKeyDown={(e) => {
                                                                        if (e.key === 'Enter') {
                                                                            const val = parseInt(e.target.value);
                                                                            if (!isNaN(val)) moveToPosition(idx, val);
                                                                            e.target.blur();
                                                                        }
                                                                    }}
                                                                    className="w-8 text-center bg-white/20 border border-white/40 rounded text-white text-xs outline-none focus:bg-white/30"
                                                                    style={{ appearance: 'textfield', MozAppearance: 'textfield', WebkitAppearance: 'none' }}
                                                                />
                                                                <span>/ {reportImages.length}</span>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </React.Fragment>
                                            ));
                                        })()}
                                    </div>
                                    <div className="p-4 border-t flex justify-end gap-2 bg-gray-50 rounded-b-lg print:hidden">
                                        <button
                                            onClick={() => window.print()}
                                            className="px-4 py-2 bg-white border border-gray-300 text-gray-700 rounded hover:bg-gray-50 font-medium flex items-center gap-2"
                                        >
                                            Print
                                        </button>
                                        <button
                                            onClick={() => setShowReport(false)}
                                            className="px-4 py-2 bg-gray-900 text-white rounded hover:bg-gray-800 font-medium"
                                        >
                                            Close
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )
                    }
                </div >
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>

</body>

</html>
